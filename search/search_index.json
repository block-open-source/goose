{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"goose  <p>goose is a programming agent that runs on your machine.</p> <p> </p> <p> Usage \u2022 Configuration \u2022 Tips \u2022 FAQ \u2022 Open Source </p> <p><code>goose</code> assists in solving a wide range of programming and operational tasks. It is a live virtual developer you can interact with, guide, and learn from.</p> <p>To solve problems, <code>goose</code> breaks down instructions into sequences of tasks and carries them out using tools. Its ability to connect its changes with real outcomes (e.g. errors) and course correct is its most powerful and exciting feature. <code>goose</code> is free open source software and is built to be extensible and customizable.</p> <p></p>"},{"location":"index.html#usage","title":"Usage","text":""},{"location":"index.html#installation","title":"Installation","text":"<p>To install <code>goose</code>, we recommend <code>pipx</code></p> <p>First make sure you've installed pipx - for example</p> <pre><code>brew install pipx\npipx ensurepath\n</code></pre> <p>Then you can install <code>goose</code> with</p> <pre><code>pipx install goose-ai\n</code></pre>"},{"location":"index.html#ides","title":"IDEs","text":"<p>There is an early version of a VS Code extension with goose support you can try here: https://github.com/square/goose-vscode - more to come soon.</p>"},{"location":"index.html#llm-provider-access-setup","title":"LLM provider access setup","text":"<p><code>goose</code> works on top of LLMs (you need to bring your own LLM). By default, <code>goose</code> uses <code>openai</code> as LLM provider. You need to set OPENAI_API_KEY as an environment variable if you would like to use <code>openai</code>. <pre><code>export OPENAI_API_KEY=your_open_api_key\n</code></pre></p> <p>Otherwise, please refer Configuration to customise <code>goose</code></p>"},{"location":"index.html#start-goose-session","title":"Start <code>goose</code> session","text":"<p>From your terminal, navigate to the directory you'd like to start from and run: <pre><code>goose session start\n</code></pre></p> <p>You will see a prompt <code>G\u276f</code>:</p> <p><pre><code>G\u276f type your instructions here exactly as you would tell a developer.\n</code></pre> Now you are interact with <code>goose</code> in conversational sessions - something like a natural language driven code interpreter. The default toolkit lets it take actions through shell commands and file edits. You can interrupt <code>goose</code> at any time to help redirect its efforts.</p>"},{"location":"index.html#exit-goose-session","title":"Exit <code>goose</code> session","text":"<p>If you are looking to exit, use <code>CTRL+D</code>, although <code>goose</code> should help you figure that out if you forget. See below for some examples.</p>"},{"location":"index.html#resume-goose-session","title":"Resume <code>goose</code> session","text":"<p>When you exit a session, it will save the history in <code>~/.config/goose/sessions</code> directory and you can resume it later on:</p> <pre><code>goose session resume\n</code></pre>"},{"location":"index.html#configuration","title":"Configuration","text":"<p><code>goose</code> can detect what LLM and toolkits it can work with from the configuration file <code>~/.config/goose/profiles.yaml</code> automatically.</p>"},{"location":"index.html#configuration-options","title":"Configuration options","text":"<p>Example:</p> <pre><code>default:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: truncate\n  toolkits:\n  - name: developer\n    requires: {}\n  - name: screen\n    requires: {}\n</code></pre> <p>You can edit this configuration file to use different LLMs and toolkits in <code>goose</code>. `goose can also be extended to support any LLM or combination of LLMs</p>"},{"location":"index.html#provider","title":"provider","text":"<p>Provider of LLM. LLM providers that currently are supported by <code>goose</code> (more can be supported by plugins):</p> Provider Required environment variable(s) to access provider openai <code>OPENAI_API_KEY</code> anthropic <code>ANTHROPIC_API_KEY</code> databricks <code>DATABRICKS_HOST</code> and <code>DATABRICKS_TOKEN</code> ollama * <code>OLLAMA_HOST</code> and ollama running <ul> <li>ollama is for local LLMs, and is limited by the tool calling model you can choose and run on local hardware, considered experimental.</li> </ul>"},{"location":"index.html#processor","title":"processor","text":"<p>Model for complex, multi-step tasks such as writing code and executing commands. Example: <code>gpt-4o</code>.  You should choose the model based the provider you configured.</p>"},{"location":"index.html#accelerator","title":"accelerator","text":"<p>Small model for fast, lightweight tasks. Example: <code>gpt-4o-mini</code>. You should choose the model based the provider you configured.</p>"},{"location":"index.html#moderator","title":"moderator","text":"<p>Rules designed to control or manage the output of the model. Moderators that currently are supported by <code>goose</code>:</p> <ul> <li><code>passive</code>: does not actively intervene in every response</li> <li><code>truncate</code>: truncates the first contexts when the contexts exceed the max token size</li> </ul>"},{"location":"index.html#toolkits","title":"toolkits","text":"<p><code>goose</code> can be extended with toolkits, and out of the box there are some available:</p> <ul> <li><code>developer</code>: for general-purpose development capabilities, including plan management, shell execution, and file operations, with default shell strategies like using ripgrep.</li> <li><code>screen</code>: for letting goose take a look at your screen to help debug or work on designs (gives goose eyes)</li> <li><code>github</code>: for awareness and suggestions on how to use github</li> <li><code>repo_context</code>: for summarizing and understanding a repository you are working in.</li> <li><code>jira</code>: for working with JIRA (issues, backlogs, tasks, bugs etc)</li> </ul>"},{"location":"index.html#configuring-goose-per-repo","title":"Configuring goose per repo","text":"<p>If you are using the <code>developer</code> toolkit, <code>goose</code> adds the content from <code>.goosehints</code>  file in working directory to the system prompt of the <code>developer</code> toolkit. The hints file is meant to provide additional context about your project. The context can be user-specific or at the project level in which case, you can commit it to git. <code>.goosehints</code> file is Jinja templated so you could have something like this:</p> <pre><code>Here is an overview of how to contribute:\n&amp;#123;% include 'CONTRIBUTING.md' %&amp;#125;\n\nThe following justfile shows our common commands:\n&amp;#123;% include 'justfile' %&amp;#125;\n</code></pre>"},{"location":"index.html#examples","title":"Examples","text":""},{"location":"index.html#provider-as-anthropic","title":"provider as <code>anthropic</code>","text":"<pre><code>default:\n  provider: anthropic\n  processor: claude-3-5-sonnet-20240620\n  accelerator: claude-3-5-sonnet-20240620\n...\n</code></pre>"},{"location":"index.html#provider-as-databricks","title":"provider as <code>databricks</code>","text":"<pre><code>default:\n  provider: databricks\n  processor: databricks-meta-llama-3-1-70b-instruct\n  accelerator: databricks-meta-llama-3-1-70b-instruct\n  moderator: passive\n  toolkits:\n  - name: developer\n    requires: {}\n</code></pre>"},{"location":"index.html#tips","title":"Tips","text":"<p>Here are some collected tips we have for working efficiently with <code>goose</code></p> <ul> <li><code>goose</code> can and will edit files. Use a git strategy to avoid losing anything - such as staging your   personal edits and leaving <code>goose</code> edits unstaged until reviewed. Or consider using individual commits which can be reverted.</li> <li><code>goose</code> can and will run commands. You can ask it to check with you first if you are concerned. It will check commands for safety as well.</li> <li>You can interrupt <code>goose</code> with <code>CTRL+C</code> to correct it or give it more info.</li> <li><code>goose</code> works best when solving concrete problems - experiment with how far you need to break that problem   down to get <code>goose</code> to solve it. Be specific! E.g. it will likely fail to <code>\"create a banking app\"</code>,   but probably does a good job if prompted with <code>\"create a Fastapi app with an endpoint for deposit and withdrawal   and with account balances stored in mysql keyed by id\"</code></li> <li>If <code>goose</code> doesn't have enough context to start with, it might go down the wrong direction. Tell it   to read files that you are referring to or search for objects in code. Even better, ask it to summarize   them for you, which will help it set up its own next steps.</li> <li>Refer to any objects in files with something that is easy to search for, such as `\"the MyExample class\"</li> <li><code>goose</code> loves to know how to run tests to get a feedback loop going, just like you do. If you tell it how you test things locally and quickly, it can make use of that when working on your project</li> <li>You can use <code>goose</code> for tasks that would require scripting at times, even looking at your screen and correcting designs/helping you fix bugs, try asking it to help you in a way you would ask a person.</li> <li><code>goose</code> will make mistakes, and go in the wrong direction from times, feel free to correct it, or start again.</li> <li>You can tell <code>goose</code> to run things for you continuously (and it will iterate, try, retry) but you can also tell it to check with you before doing things (and then later on tell it to go off on its own and do its best to solve).</li> <li><code>goose</code> can run anywhere, doesn't have to be in a repo, just ask it!</li> </ul>"},{"location":"index.html#examples_1","title":"Examples","text":"<p>Here are some examples that have been used:</p> <pre><code>G\u276f Looking at the in progress changes in this repo, help me finish off the feature. CONTRIBUTING.md shows how to run the tests.\n</code></pre> <pre><code>G\u276f In this golang project, I want you to add open telemetry to help me get started with it. Look in the moneymovements module, run the `just test` command to check things work.\n</code></pre> <pre><code>G\u276f This project uses an old version of jooq. Upgrade to the latest version, and ensure there are no incompatibilities by running all tests. Dependency versions are in gradle/libs.versions.toml and to run gradle, use the binary located in bin/gradle\n</code></pre> <pre><code>G\u276f This is a fresh checkout of a golang project. I do not have my golang environment set up. Set it up and run tests for this project, and ensure they pass. Use the zookeeper jar included in this repository rather than installing zookeeper via brew.\n</code></pre> <pre><code>G\u276f In this repo, I want you to look at how to add a new provider for azure.\nSome hints are in this github issue: https://github.com/square/exchange/issues\n/4 (you can use gh cli to access it).\n</code></pre> <pre><code>G\u276f I want you to help me increase the test coverage in src/java... use mvn test to run the unit tests to check it works.\n</code></pre>"},{"location":"index.html#faq","title":"FAQ","text":"<p>Q: Why did I get error message of \"The model <code>gpt-4o</code> does not exist or you do not have access to it.` when I talked goose?</p> <p>A: You can find out the LLM provider and models in the configuration file <code>~/.config/goose/profiles.yaml</code> here to check whether your LLM provider account has access to the models.  For example, after you have made a successful payment of $5 or more (usage tier 1), you'll be able to access the GPT-4, GPT-4 Turbo, GPT-4o models via the OpenAI API. How can I access GPT-4, GPT-4 Turbo, GPT-4o, and GPT-4o mini?.</p>"},{"location":"index.html#open-source","title":"Open Source","text":"<p>Yes, <code>goose</code> is open source and always will be. <code>goose</code> is released under the ASL2.0 license meaning you can use it however you like. See LICENSE.md for more details.</p> <p>To run <code>goose</code> from source, please see <code>CONTRIBUTING.md</code> for instructions on how to set up your environment and you can then run <code>uv run</code>goose<code>session start</code>.</p>"},{"location":"available-toolkits.html","title":"Available Toolkits in Goose","text":"<p>Goose provides a variety of toolkits designed to help developers with different tasks. Here's an overview of each available toolkit and its functionalities:</p>"},{"location":"available-toolkits.html#1-developer-toolkit","title":"1. Developer Toolkit","text":"<p>The Developer toolkit offers general-purpose development capabilities, including:</p> <ul> <li>System Configuration Details: Retrieves system configuration details.</li> <li>Task Management: Update the plan by overwriting all current tasks.</li> <li>File Operations:</li> <li><code>patch_file</code>: Patch a file by replacing specific content.</li> <li><code>read_file</code>: Read the content of a specified file.</li> <li><code>write_file</code>: Write content to a specified file.</li> <li>Shell Command Execution: Execute shell commands with safety checks.</li> </ul>"},{"location":"available-toolkits.html#2-github-toolkit","title":"2. GitHub Toolkit","text":"<p>The GitHub toolkit provides detailed configuration and procedural guidelines for GitHub operations.</p>"},{"location":"available-toolkits.html#3-lint-toolkit","title":"3. Lint Toolkit","text":"<p>The Lint toolkit ensures that all toolkits have proper documentation. It performs the following checks:</p> <ul> <li>Toolkit must have a docstring.</li> <li>The first line of the docstring should contain more than 5 words and fewer than 12 words.</li> <li>The first letter of the docstring should be capitalized.</li> </ul>"},{"location":"available-toolkits.html#4-repocontext-toolkit","title":"4. RepoContext Toolkit","text":"<p>The RepoContext toolkit provides context about the current repository. It includes:</p> <ul> <li>Repository Size: Get the size of the repository.</li> <li>Monorepo Check: Determine if the repository is a monorepo.</li> <li>Project Summarization: Summarize the current project based on the repository or the current project directory.</li> </ul>"},{"location":"available-toolkits.html#5-screen-toolkit","title":"5. Screen Toolkit","text":"<p>The Screen toolkit assists users in taking screenshots for debugging or designing purposes. It provides:</p> <ul> <li>Take Screenshot: Capture a screenshot and provide the path to the screenshot file.</li> <li>System Instructions: Instructions on how to work with screenshots.</li> </ul>"},{"location":"available-toolkits.html#6-summarizerepo-toolkit","title":"6. SummarizeRepo Toolkit","text":"<p>The SummarizeRepo toolkit helps in summarizing a repository. It includes:</p> <ul> <li>Summarize Repository: Clone the repository (if not already cloned) and summarize the files based on specified extensions.</li> </ul>"},{"location":"available-toolkits.html#7-summarizeproject-toolkit","title":"7. SummarizeProject Toolkit","text":"<p>The SummarizeProject toolkit generates or retrieves a summary of a project directory based on specified file extensions. It includes:</p> <ul> <li>Get Project Summary: Generate or retrieve a summary of the project in the specified directory.</li> </ul>"},{"location":"available-toolkits.html#8-summarizefile-toolkit","title":"8. SummarizeFile Toolkit","text":"<p>The SummarizeFile toolkit helps in summarizing a specific file. It includes:</p> <ul> <li>Summarize File: Summarize the contents of a specified file with optional instructions.</li> </ul>"},{"location":"cli.html","title":"Goose CLI Commands","text":"<p>Goose provides a command-line interface (CLI) with various commands to manage sessions, toolkits, and more. Below is a list of the available commands and their descriptions:</p>"},{"location":"cli.html#goose-cli","title":"Goose CLI","text":""},{"location":"cli.html#version","title":"<code>version</code>","text":"<p>Usage: <pre><code>  goose version\n</code></pre></p> <p>Lists the version of Goose and any associated plugins.</p>"},{"location":"cli.html#session","title":"<code>session</code>","text":""},{"location":"cli.html#start","title":"<code>start</code>","text":"<p>Usage: <pre><code>  goose session start [--profile PROFILE] [--plan PLAN]\n</code></pre></p> <p>Starts a new Goose session.</p>"},{"location":"cli.html#resume","title":"<code>resume</code>","text":"<p>Usage: <pre><code>  goose session resume [NAME] [--profile PROFILE]\n</code></pre></p> <p>Resumes an existing Goose session.</p>"},{"location":"cli.html#list","title":"<code>list</code>","text":"<p>Usage: <pre><code>  goose session list\n</code></pre></p> <p>Lists all Goose sessions.</p>"},{"location":"cli.html#clear","title":"<code>clear</code>","text":"<p>Usage: <pre><code>  goose session clear [--keep KEEP]\n</code></pre></p> <p>Deletes old Goose sessions, keeping the most recent ones as specified by the <code>--keep</code> option.</p>"},{"location":"cli.html#toolkit","title":"<code>toolkit</code>","text":""},{"location":"cli.html#list_1","title":"<code>list</code>","text":"<p>Usage: <pre><code>  goose toolkit list\n</code></pre></p> <p>Lists all available toolkits with their descriptions.</p>"},{"location":"configuration.html","title":"Configuring Goose","text":""},{"location":"configuration.html#profiles","title":"Profiles","text":"<p>If you need to customize goose, one way is via editing: <code>~/.config/goose/profiles.yaml</code>.</p> <p>It will look by default something like (and when you run <code>goose session start</code> without the <code>--profile</code> flag it will use the <code>default</code> profile):</p> <pre><code>default:\n  provider: open-ai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: passive\n  toolkits:\n    - name: developer\n      requires: {}\n</code></pre>"},{"location":"configuration.html#fields","title":"Fields","text":""},{"location":"configuration.html#provider","title":"provider","text":"<p>Provider of LLM. LLM providers that currently are supported by Goose:</p> Provider Required environment variable(s) to access provider openai <code>OPENAI_API_KEY</code> anthropic <code>ANTHROPIC_API_KEY</code> databricks <code>DATABRICKS_HOST</code> and <code>DATABRICKS_TOKEN</code>"},{"location":"configuration.html#processor","title":"processor","text":"<p>This is the model used for the main Goose loop and main tools -- it should be be capable of complex, multi-step tasks such as writing code and executing commands. Example: <code>gpt-4o</code>. You should choose the model based the provider you configured.</p>"},{"location":"configuration.html#accelerator","title":"accelerator","text":"<p>Small model for fast, lightweight tasks. Example: <code>gpt-4o-mini</code>. You should choose the model based the provider you configured.</p>"},{"location":"configuration.html#moderator","title":"moderator","text":"<p>Rules designed to control or manage the output of the model. Moderators that currently are supported by Goose:</p> <ul> <li><code>passive</code>: does not actively intervene in every response</li> <li><code>truncate</code>: truncates the first contexts when the contexts exceed the max token size</li> </ul>"},{"location":"configuration.html#example-profilesyaml-files","title":"Example <code>profiles.yaml</code> files","text":""},{"location":"configuration.html#provider-as-anthropic","title":"provider as <code>anthropic</code>","text":"<pre><code>default:\n  provider: anthropic\n  processor: claude-3-5-sonnet-20240620\n  accelerator: claude-3-5-sonnet-20240620\n</code></pre>"},{"location":"configuration.html#provider-as-databricks","title":"provider as <code>databricks</code>","text":"<pre><code>default:\n  provider: databricks\n  processor: databricks-meta-llama-3-1-70b-instruct\n  accelerator: databricks-meta-llama-3-1-70b-instruct\n  moderator: passive\n  toolkits:\n    - name: developer\n      requires: {}\n</code></pre> <p>You can tell it to use another provider for example for Anthropic:</p> <pre><code>default:\n  provider: anthropic\n  processor: claude-3-5-sonnet-20240620\n  accelerator: claude-3-5-sonnet-20240620\n  moderator: passive\n  toolkits:\n    - name: developer\n      requires: {}\n</code></pre> <p>this will then use the claude-sonnet model, you will need to set the <code>ANTHROPIC_API_KEY</code> to your anthropic API key.</p> <p>You can also customize Goose's behavior through toolkits. These are set up automatically for you in the same <code>~/.config/goose/profiles.yaml</code> file, but you can include or remove toolkits as you see fit.</p> <p>For example, Goose's <code>unit-test-gen</code> command sets up a new profile in this file for you:</p> <pre><code>unit-test-gen:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: passive\n  toolkits:\n    - name: developer\n      requires: {}\n    - name: unit-test-gen\n      requires: {}\n    - name: java\n      requires: {}\n</code></pre>"},{"location":"configuration.html#adding-a-toolkit","title":"Adding a toolkit","text":"<p>To make a toolkit available to Goose, add it to your project's pyproject.toml. For example in the Goose pyproject.toml file: <pre><code>[project.entry-points.\"goose.toolkit\"]\ndeveloper = \"goose.toolkit.developer:Developer\"\ngithub = \"goose.toolkit.github:Github\"\n# Add a line like this - the key becomes the name used in profiles\nmy-new-toolkit = \"goose.toolkit.my_toolkits:MyNewToolkit\"  # this is the path to the class that implements the toolkit\n</code></pre></p> <p>Then to set up a profile that uses it, add something to <code>~/.config/goose/profiles.yaml</code>: <pre><code>my-profile:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: passive\n  toolkits:  # new toolkit gets added here\n    - developer\n    - my-new-toolkit\n</code></pre></p> <p>And now you can run Goose with this new profile to use the new toolkit!</p> <pre><code>goose session start --profile my-profile\n</code></pre> <p>Or, if you're developing a new toolkit and want to test it: <pre><code>uv run goose session start --profile my-profile\n</code></pre></p>"},{"location":"configuration.html#tuning-it-to-your-repo","title":"Tuning it to your repo","text":"<p>Goose ships with the ability to read in the contents of a file named <code>.goosehints</code> from your repo. If you find yourself repeating the same information across sessions to Goose, this file is the right place to add this information.</p> <p>This file will be read into the Goose system prompt if it is present in the current working directory.</p> <p>Note</p> <p><code>.goosehints</code> follows jinja templating rules in case you want to leverage templating to insert file contents or variables.</p>"},{"location":"contributing.html","title":"Contributing","text":"<p> Prerequisites \u2022 Developing and testing \u2022 Building from source \u2022 Developing goose-plugins \u2022 Running ai-exchange from source \u2022 Evaluations \u2022 Conventional Commits </p> <p>We welcome Pull Requests for general contributions. If you have a larger new feature or any questions on how to develop a fix, we recommend you open an issue before starting.</p>"},{"location":"contributing.html#prerequisites","title":"Prerequisites","text":"<p>We provide a shortcut to standard commands using just in our <code>justfile</code>.</p> <p>Goose uses uv for dependency management, and formats with ruff - install UV first: https://pypi.org/project/uv/ </p>"},{"location":"contributing.html#developing-and-testing","title":"Developing and testing","text":"<p>Now that you have a local environment, you can make edits and run our tests. </p>"},{"location":"contributing.html#creating-plugins","title":"Creating plugins","text":"<p>Goose is highly configurable through plugins - it reads in modules that its dependencies install (e.g.<code>goose-plugins</code>) and uses those that start with certain prefixes (e.g. <code>goose.toolkit</code>) to inject their functionality. For example, you will note that Goose's CLI is actually merged with additional CLI methods that are exported from <code>goose-plugins</code>.</p> <p>If you are building a net new feature, you should try to fit it inside a plugin. Goose and <code>goose-plugins</code> both support plugins, but there's an important difference in how contributions to each are reviewed. Use the guidelines below to decide where to contribute:</p> <p>When to Add to Goose:</p> <p>Plugins added directly to Goose are subject to rigorous review. This is because they are part of the core system and need to meet higher standards for stability, performance, and maintainability, often being validated through benchmarking.</p> <p>When to Add to <code>goose-plugins</code>:</p> <p>Plugins in <code>goose-plugins</code> undergo less detailed reviews and are more modular or experimental. They can prove their value through usage or iteration over time and may be eventually moved over to Goose.</p> <p>To see how to add a toolkit, see the toolkits documentation.</p>"},{"location":"contributing.html#running-tests","title":"Running tests","text":"<pre><code>uv run pytest tests -m \"not integration\"\n</code></pre> <p>or, as a shortcut, </p> <pre><code>just test\n</code></pre>"},{"location":"contributing.html#building-from-source","title":"Building from source","text":"<p>If you want to develop features on <code>goose</code>:</p> <ol> <li>Clone Goose: <pre><code>git clone git@github.com:square/goose.git ~/Development/goose\n</code></pre></li> <li>Get <code>uv</code> with <code>brew install uv</code></li> <li>Set up your Python virtualenv: <pre><code>cd ~/Development/goose\nuv sync\nuv venv\n</code></pre></li> <li>Run the <code>source</code> command that follows the <code>uv venv</code> command to activate the virtualenv.</li> <li>Run Goose: <pre><code>uv run goose session start  # or any of goose's commands (e.g. goose --help)\n</code></pre></li> </ol>"},{"location":"contributing.html#running-from-source","title":"Running from source","text":"<p>When you build from source you may want to run it from elsewhere.</p> <ol> <li>Run <code>uv sync</code> as above</li> <li>Run <code>export goose_dev=`uv run which goose`</code></li> <li>You can use that from anywhere in your system, for example <code>cd ~/ &amp;&amp; $goose_dev session start</code>, or from your path if you like (advanced users only) to be running the latest.</li> </ol>"},{"location":"contributing.html#developing-goose-plugins","title":"Developing goose-plugins","text":"<ol> <li>Clone the <code>goose-plugins</code> repo: <pre><code> git clone git@github.com:square/goose-plugins.git ~/Development/goose-plugins\n</code></pre></li> <li>Follow the steps for creating a virtualenv in the <code>goose</code> section above</li> <li>Install <code>goose-plugins</code> in <code>goose</code>. This means any changes to <code>goose-plugins</code> in this folder will immediately be reflected in <code>goose</code>: <pre><code>uv add --editable ~/Development/goose-plugins\n</code></pre></li> <li>Make your changes in <code>goose-plugins</code>, add the toolkit to the <code>profiles.yaml</code> file and run <code>uv run goose session --start</code> to see them in action.</li> </ol>"},{"location":"contributing.html#running-ai-exchange-from-source","title":"Running ai-exchange from source","text":"<p>goose depends heavily on the <code>ai-exchange</code> project, you can clone that repo and then work on both by running: </p> <pre><code>uv add --editable &lt;path/to/cloned/exchange&gt;\n</code></pre> <p>then when you run goose with <code>uv run goose session start</code> it will be running it all from source. </p>"},{"location":"contributing.html#evaluations","title":"Evaluations","text":"<p>Given that so much of Goose involves interactions with LLMs, our unit tests only go so far to confirming things work as intended.</p> <p>We're currently developing a suite of evaluations, to make it easier to make improvements to Goose more confidently.</p> <p>In the meantime, we typically incubate any new additions that change the behavior of the Goose through opt-in plugins - <code>Toolkit</code>s, <code>Moderator</code>s, and <code>Provider</code>s. We welcome contributions of plugins that add new capabilities to goose. We recommend sending in several examples of the new capabilities in action with your pull request.</p> <p>Additions to the developer toolkit change the core performance, and so will need to be measured carefully.</p>"},{"location":"contributing.html#conventional-commits","title":"Conventional Commits","text":"<p>This project follows the Conventional Commits specification for PR titles. Conventional Commits make it easier to understand the history of a project and facilitate automation around versioning and changelog generation.</p>"},{"location":"creating-a-new-toolkit.html","title":"Creating a New Toolkit","text":"<p>To add a toolkit, in your code (which doesn't necessarily need to be in the Goose package thanks to plugin metadata!), create a class that derives from the <code>Toolkit</code> class.</p>"},{"location":"creating-a-new-toolkit.html#example-toolkit-class","title":"Example toolkit class","text":"<p>Below is an example of a simple toolkit called <code>Demo</code> that derives from the <code>Toolkit</code> class. This toolkit provides an <code>authenticate</code> tool that outputs an authentication code for a user. It also provides system instructions for the model.  <pre><code>import os\nimport platform\n\nfrom goose.toolkit.base import Toolkit, tool\n\n\nclass Demo(Toolkit):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    # Provide any additional tools as needed!\n    # The docstring of the tool provides instructions to the LLM, so they are important to tune\n    # you do not have to provide any tools, but any function decorated with @tool will be available\n    @tool\n    def authenticate(self, user: str):\n        \"\"\"Output an authentication code for this user\n\n        Args:\n            user (str): The username to authenticate for\n        \"\"\"\n        # notifier supports any rich renderable https://rich.readthedocs.io/en/stable/introduction.html#quick-start\n        self.notifier.log(f\"[bold red]auth: {str(hash(user))}[/]\")\n\n    # Provide any system instructions for the model\n    # This can be generated dynamically, and is run at startup time\n    def system(self) -&gt; str:\n        print(\"new\")\n        return f\"\"\"**You must preceed your first message by using the authenticate tool for the current user**\n\n        ```\n        platform: {platform.system()}\n        cwd: {os.getcwd()}\n        user: {os.environ.get('USER')}\n        ```\n        \"\"\"\n</code></pre></p>"},{"location":"creating-a-new-toolkit.html#exposing-the-new-toolkit-to-goose","title":"Exposing the New Toolkit to Goose","text":"<p>To make the toolkit available, add it to the <code>pyproject.toml</code> file and then update your <code>profiles.yaml</code> file.</p>"},{"location":"creating-a-new-toolkit.html#update-the-pyprojecttoml-file","title":"Update the <code>pyproject.toml</code> file","text":"<p>If you're adding the new toolkit to Goose or the Goose Plugins repo, simply find the <code>[project.entry-points.\"goose.toolkit\"]</code> section in <code>pyproject.toml</code> and add a line like this: <pre><code>[project.entry-points.\"goose.toolkit\"]\ndeveloper = \"goose.toolkit.developer:Developer\"\ngithub = \"goose.toolkit.github:Github\"\n# Add a line like this - the key becomes the name used in profiles\ndemo = \"goose.toolkit.demo:Demo\"\n</code></pre></p> <p>If you are adding the toolkit to a different package, see the docs for <code>goose-plugins</code> for more information on how to create a plugins repository that can be used by Goose.</p>"},{"location":"creating-a-new-toolkit.html#update-the-profilesyaml-file","title":"Update the <code>profiles.yaml</code> file","text":"<p>And then to set up a profile that uses it, add something to ~/.config/goose/profiles.yaml <pre><code>default:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: passive\n  toolkits:\n    - name: developer\n      requires: {}\ndemo-profile:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: passive\n  toolkits:\n    - developer\n    - demo\n</code></pre></p> <p>And now you can run goose with this new profile to use the new toolkit!</p> <pre><code>goose session start --profile demo-profile\n</code></pre> <p>Note</p> <p>If you're using a plugin from <code>goose-plugins</code>, make sure <code>goose-plugins</code> is installed in your environment. You can install it via pip: </p> <p><code>pipx install goose-ai --preinstall goose-plugins</code></p>"},{"location":"installation.html","title":"Installation","text":"<p>To install Goose, use <code>pipx</code>.First ensure pipx is installed:</p> <pre><code>brew install pipx\npipx ensurepath\n</code></pre> <p>Then install Goose:</p> <pre><code>pipx install goose-ai\n</code></pre> <p>You can then run <code>goose</code> from the command line with <code>goose session start</code>.</p>"},{"location":"plugins.html","title":"Plugins in Goose","text":"<p>Goose's functionality is extended via plugins. These plugins fall into three main categories:</p> <ol> <li>Toolkits: <ul> <li>Provides Goose with tools (functions) it can call and optionally will load additional context into the system prompt (such as 'The Github CLI is called via <code>gh</code> and you should use it to run git commands'). </li> <li>Toolkits can do basically anything, from calling external APIs, to taking a screenshot of your screen, to summarizing your current project.</li> </ul> </li> <li>CLI commands: <ul> <li>Provides additional commands to the Goose CLI. </li> <li>These commands can be used to interact with the Goose system, such as listing available toolkits or summarizing a session.</li> </ul> </li> <li>Providers: <ul> <li>Provides Goose with access to external LLMs. </li> <li>For example, the OpenAI provider allows Goose to interact with the OpenAI API. </li> <li>Most providers for Goose are defined in the Exchange library.</li> </ul> </li> </ol>"},{"location":"providers.html","title":"Providers","text":"<p>Providers in Goose mean \"LLM providers\" that Goose can interact with. Providers are defined in the Exchange library for the most part, but you can define your own. </p> <p>Currently available providers:</p> <ul> <li>Anthropic</li> <li>Azure</li> <li>Bedrock</li> <li>Databricks</li> <li>Ollama</li> <li>OpenAI</li> </ul>"},{"location":"tips.html","title":"Tips","text":""},{"location":"tips.html#tips","title":"tips","text":"<p>Here are some collected tips we have for working efficiently with <code>goose</code></p> <ul> <li><code>goose</code> can and will edit files. Use a git strategy to avoid losing anything - such as staging your personal edits and leaving <code>goose</code> edits unstaged until reviewed. Or consider using individual commits which can be reverted.</li> <li><code>goose</code> can and will run commands. You can ask it to check with you first if you are concerned. It will check commands for safety as well.</li> <li>You can interrupt <code>goose</code> with <code>CTRL+C</code> to correct it or give it more info.</li> <li><code>goose</code> works best when solving concrete problems - experiment with how far you need to break that problem down to get <code>goose</code> to solve it. Be specific! E.g. it will likely fail to <code>\"create a banking app\"</code>, but probably does a good job if prompted with <code>\"create a Fastapi app with an endpoint for deposit and withdrawal and with account balances stored in mysql keyed by id\"</code></li> <li>If <code>goose</code> doesn't have enough context to start with, it might go down the wrong direction. Tell it to read files that you are referring to or search for objects in code. Even better, ask it to summarize them for you, which will help it set up its own next steps.</li> <li>Refer to any objects in files with something that is easy to search for, such as `\"the MyExample class\"</li> <li><code>goose</code> loves to know how to run tests to get a feedback loop going, just like you do. If you tell it how you test things locally and quickly, it can make use of that when working on your project</li> <li>You can use <code>goose</code> for tasks that would require scripting at times, even looking at your screen and correcting designs/helping you fix bugs, try asking it to help you in a way you would ask a person.</li> <li><code>goose</code> will make mistakes, and go in the wrong direction from times, feel free to correct it, or start again.</li> <li>You can tell <code>goose</code> to run things for you continuously (and it will iterate, try, retry) but you can also tell it to check with you before doing things (and then later on tell it to go off on its own and do its best to solve).</li> <li><code>goose</code> can run anywhere, doesn't have to be in a repo, just ask it!</li> </ul>"},{"location":"using-toolkits.html","title":"Using Toolkits","text":"<p>Use <code>goose toolkit list</code> to list the available toolkits.</p>"},{"location":"using-toolkits.html#toolkits-defined-in-goose","title":"Toolkits defined in Goose","text":"<p>Using Goose with toolkits is simple. You can add toolkits to your profile in the <code>profiles.yaml</code> file. Here's an example of how to add <code>my-toolkit</code> toolkit to your profile:</p> <pre><code>my-profile:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: passive\n  toolkits:\n    - my-toolkit\n</code></pre> <p>Then run Goose with the specified profile:</p> <pre><code>goose session start --profile my-profile\n</code></pre>"},{"location":"using-toolkits.html#toolkits-defined-in-goose-plugins","title":"Toolkits defined in Goose Plugins","text":"<ol> <li>First make sure that <code>goose-plugins</code> is intalled with Goose: <pre><code>pipx install goose-ai --preinstall goose-plugins\n</code></pre></li> <li>Update the <code>profiles.yaml</code> file to include the desired toolkit: <pre><code>my-profile:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: passive\n  toolkits:\n    - my-goose-plugins-toolkit\n</code></pre></li> </ol>"},{"location":"reference/index.html","title":"Reference Documentation","text":"<p>Welcome to the reference documentation for the project's Python modules.</p> <p>Below is a list of available modules:</p> <ul> <li>goose</li> <li>goose.build</li> <li>goose.cli</li> <li>goose.cli.config</li> <li>goose.cli.main</li> <li>goose.cli.prompt</li> <li>goose.cli.prompt.completer</li> <li>goose.cli.prompt.create</li> <li>goose.cli.prompt.goose_prompt_session</li> <li>goose.cli.prompt.lexer</li> <li>goose.cli.prompt.prompt_validator</li> <li>goose.cli.prompt.user_input</li> <li>goose.cli.session</li> <li>goose.command</li> <li>goose.command.base</li> <li>goose.command.file</li> <li>goose.notifier</li> <li>goose.profile</li> <li>goose.view</li> <li>goose.toolkit</li> <li>goose.toolkit.base</li> <li>goose.toolkit.developer</li> <li>goose.toolkit.github</li> <li>goose.toolkit.lint</li> <li>goose.toolkit.repo_context</li> <li>goose.toolkit.repo_context.repo_context</li> <li>goose.toolkit.repo_context.utils</li> <li>goose.toolkit.screen</li> <li>goose.toolkit.summarization</li> <li>goose.toolkit.summarization.summarize_file</li> <li>goose.toolkit.summarization.summarize_project</li> <li>goose.toolkit.summarization.summarize_repo</li> <li>goose.toolkit.summarization.utils</li> <li>goose.toolkit.utils</li> <li>goose.utils</li> <li>goose.utils.ask</li> <li>goose.utils.check_shell_command</li> <li>goose.utils.diff</li> <li>goose.utils.file_utils</li> <li>goose.utils.session_file</li> </ul>"},{"location":"reference/SUMMARY.html","title":"Reference Documentation Summary","text":""},{"location":"reference/SUMMARY.html#core-modules","title":"Core Modules","text":"<ul> <li>goose</li> <li>goose.build</li> <li>goose.cli</li> <li>goose.cli.config</li> <li>goose.cli.main</li> <li>goose.cli.prompt</li> <li>goose.cli.prompt.completer</li> <li>goose.cli.prompt.create</li> <li>goose.cli.prompt.goose_prompt_session</li> <li>goose.cli.prompt.lexer</li> <li>goose.cli.prompt.prompt_validator</li> <li>goose.cli.prompt.user_input</li> <li>goose.cli.session</li> <li>goose.command</li> <li>goose.command.base</li> <li>goose.command.file</li> <li>goose.notifier</li> <li>goose.profile</li> <li>goose.view</li> </ul>"},{"location":"reference/SUMMARY.html#toolkit-modules","title":"Toolkit Modules","text":"<ul> <li>goose.toolkit</li> <li>goose.toolkit.base</li> <li>goose.toolkit.developer</li> <li>goose.toolkit.github</li> <li>goose.toolkit.lint</li> <li>goose.toolkit.repo_context</li> <li>goose.toolkit.repo_context.repo_context</li> <li>goose.toolkit.repo_context.utils</li> <li>goose.toolkit.screen</li> <li>goose.toolkit.summarization</li> <li>goose.toolkit.summarization.summarize_file</li> <li>goose.toolkit.summarization.summarize_project</li> <li>goose.toolkit.summarization.summarize_repo</li> <li>goose.toolkit.summarization.utils</li> <li>goose.toolkit.utils</li> </ul>"},{"location":"reference/SUMMARY.html#utility-modules","title":"Utility Modules","text":"<ul> <li>goose.utils</li> <li>goose.utils.ask</li> <li>goose.utils.check_shell_command</li> <li>goose.utils.diff</li> <li>goose.utils.file_utils</li> <li>goose.utils.session_file</li> </ul>"},{"location":"reference/goose/index.html","title":"Index","text":""},{"location":"reference/goose/build.html","title":"Build","text":""},{"location":"reference/goose/build.html#goose.build.build_exchange","title":"<code>build_exchange(profile, notifier)</code>","text":"<p>Build an exchange configured through the profile</p> <p>This will setup any toolkits and use that to build the exchange's collection of tools.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Profile</code> <p>The profile specifying how to setup this exchange</p> required <code>notifier</code> <code>Notifier</code> <p>A notifier instance used by tools to send info</p> required Source code in <code>src/goose/build.py</code> <pre><code>def build_exchange(profile: Profile, notifier: Notifier) -&gt; Exchange:\n    \"\"\"Build an exchange configured through the profile\n\n    This will setup any toolkits and use that to build the exchange's collection\n    of tools.\n\n    Args:\n        profile (Profile): The profile specifying how to setup this exchange\n        notifier (Notifier): A notifier instance used by tools to send info\n    \"\"\"\n\n    provider = get_provider(profile.provider).from_env()\n\n    # Support instantating toolkits in *two* passes for now, no further nesting\n    concrete_toolkits = {}\n\n    # First instantiate all toolkits that are sub dependencies\n    for spec in profile.toolkits:\n        for required in spec.requires.values():\n            concrete_toolkits[required] = get_toolkit(required)(notifier=notifier, requires=Requirements(required))\n\n    # Now that we have the dependencies available, we can instantiate everything else\n    toolkits = []\n    for spec in profile.toolkits:\n        if spec.name in concrete_toolkits:\n            toolkits.append(concrete_toolkits[spec.name])\n            continue\n\n        requires = Requirements(\n            spec.name,\n            {key: concrete_toolkits[val] for key, val in spec.requires.items()},\n        )\n        toolkit = get_toolkit(spec.name)(notifier=notifier, requires=requires)\n        toolkits.append(toolkit)\n\n    # From the toolkits, we derive the exchange prompt and tools\n    system = \"\\n\\n\".join([Message.load(\"system.jinja\").text] + [toolkit.system() for toolkit in toolkits])\n    tools = tuple(chain(*(toolkit.tools() for toolkit in toolkits)))\n    exchange = Exchange(\n        provider=provider,\n        system=system,\n        tools=tools,\n        moderator=get_moderator(profile.moderator)(),\n        model=profile.processor,\n    )\n\n    # This is a bit awkward, but we have to set this after the fact because building\n    # the exchange requires having the toolkits\n    for toolkit in toolkits:\n        toolkit.exchange_view = ExchangeView(profile.processor, profile.accelerator, exchange)\n\n    return exchange\n</code></pre>"},{"location":"reference/goose/notifier.html","title":"Notifier","text":""},{"location":"reference/goose/notifier.html#goose.notifier.Notifier","title":"<code>Notifier</code>","text":"<p>               Bases: <code>ABC</code></p> <p>The interface for a notifier</p> <p>This is expected to be implemented concretely by the each UX</p> Source code in <code>src/goose/notifier.py</code> <pre><code>class Notifier(ABC):\n    \"\"\"The interface for a notifier\n\n    This is expected to be implemented concretely by the each UX\n    \"\"\"\n\n    @abstractmethod\n    def log(self, content: RenderableType) -&gt; None:\n        \"\"\"Append content to the main display\n\n        Args:\n            content (str): The content to render\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def status(self, status: Optional[str]) -&gt; None:\n        \"\"\"Log a status to ephemeral display\n\n        Args:\n            status (str): The status to display\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def start(self) -&gt; None:\n        \"\"\"Start the display for the notifier\"\"\"\n        pass\n\n    @abstractmethod\n    def stop(self) -&gt; None:\n        \"\"\"Stop the display for the notifier\"\"\"\n        pass\n</code></pre>"},{"location":"reference/goose/notifier.html#goose.notifier.Notifier.log","title":"<code>log(content)</code>  <code>abstractmethod</code>","text":"<p>Append content to the main display</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The content to render</p> required Source code in <code>src/goose/notifier.py</code> <pre><code>@abstractmethod\ndef log(self, content: RenderableType) -&gt; None:\n    \"\"\"Append content to the main display\n\n    Args:\n        content (str): The content to render\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/goose/notifier.html#goose.notifier.Notifier.start","title":"<code>start()</code>  <code>abstractmethod</code>","text":"<p>Start the display for the notifier</p> Source code in <code>src/goose/notifier.py</code> <pre><code>@abstractmethod\ndef start(self) -&gt; None:\n    \"\"\"Start the display for the notifier\"\"\"\n    pass\n</code></pre>"},{"location":"reference/goose/notifier.html#goose.notifier.Notifier.status","title":"<code>status(status)</code>  <code>abstractmethod</code>","text":"<p>Log a status to ephemeral display</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str</code> <p>The status to display</p> required Source code in <code>src/goose/notifier.py</code> <pre><code>@abstractmethod\ndef status(self, status: Optional[str]) -&gt; None:\n    \"\"\"Log a status to ephemeral display\n\n    Args:\n        status (str): The status to display\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/goose/notifier.html#goose.notifier.Notifier.stop","title":"<code>stop()</code>  <code>abstractmethod</code>","text":"<p>Stop the display for the notifier</p> Source code in <code>src/goose/notifier.py</code> <pre><code>@abstractmethod\ndef stop(self) -&gt; None:\n    \"\"\"Stop the display for the notifier\"\"\"\n    pass\n</code></pre>"},{"location":"reference/goose/profile.html","title":"Profile","text":""},{"location":"reference/goose/profile.html#goose.profile.Profile","title":"<code>Profile</code>","text":"<p>The configuration for a run of goose</p> Source code in <code>src/goose/profile.py</code> <pre><code>@define\nclass Profile:\n    \"\"\"The configuration for a run of goose\"\"\"\n\n    provider: str\n    processor: str\n    accelerator: str\n    moderator: str\n    toolkits: List[ToolkitSpec] = field(factory=list, converter=ensure_list(ToolkitSpec))\n\n    @toolkits.validator\n    def check_toolkit_requirements(self, _: Type[\"ToolkitSpec\"], toolkits: List[ToolkitSpec]) -&gt; None:\n        # checks that the list of toolkits in the profile have their requirements\n        installed_toolkits = set([toolkit.name for toolkit in toolkits])\n\n        for toolkit in toolkits:\n            toolkit_name = toolkit.name\n            toolkit_requirements = toolkit.requires\n            for _, req in toolkit_requirements.items():\n                if req not in installed_toolkits:\n                    msg = f\"Toolkit {toolkit_name} requires {req} but it is not present\"\n                    raise ValueError(msg)\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        return asdict(self)\n</code></pre>"},{"location":"reference/goose/profile.html#goose.profile.ToolkitSpec","title":"<code>ToolkitSpec</code>","text":"<p>Configuration for a Toolkit</p> Source code in <code>src/goose/profile.py</code> <pre><code>@define\nclass ToolkitSpec:\n    \"\"\"Configuration for a Toolkit\"\"\"\n\n    name: str\n    requires: Mapping[str, str] = field(factory=dict)\n</code></pre>"},{"location":"reference/goose/profile.html#goose.profile.default_profile","title":"<code>default_profile(provider, processor, accelerator, **kwargs)</code>","text":"<p>Get the default profile</p> Source code in <code>src/goose/profile.py</code> <pre><code>def default_profile(provider: str, processor: str, accelerator: str, **kwargs: Dict[str, Any]) -&gt; Profile:\n    \"\"\"Get the default profile\"\"\"\n\n    # TODO consider if the providers should have recommended models\n\n    return Profile(\n        provider=provider,\n        processor=processor,\n        accelerator=accelerator,\n        moderator=\"truncate\",\n        toolkits=[ToolkitSpec(\"developer\")],\n    )\n</code></pre>"},{"location":"reference/goose/view.html","title":"View","text":""},{"location":"reference/goose/view.html#goose.view.ExchangeView","title":"<code>ExchangeView</code>","text":"<p>A read-only view of the underlying Exchange</p> <p>Attributes:</p> Name Type Description <code>processor</code> <code>Exchange</code> <p>A copy of the exchange configured for high capabilities</p> <code>accelerator</code> <code>Exchange</code> <p>A copy of the exchange configured for high speed</p> Source code in <code>src/goose/view.py</code> <pre><code>@define\nclass ExchangeView:\n    \"\"\"A read-only view of the underlying Exchange\n\n\n    Attributes:\n        processor: A copy of the exchange configured for high capabilities\n        accelerator: A copy of the exchange configured for high speed\n\n    \"\"\"\n\n    _processor: str\n    _accelerator: str\n    _exchange: Exchange\n\n    @property\n    def processor(self) -&gt; Exchange:\n        return self._exchange.replace(model=self._processor)\n\n    @property\n    def accelerator(self) -&gt; Exchange:\n        return self._exchange.replace(model=self._accelerator)\n</code></pre>"},{"location":"reference/goose/cli/index.html","title":"Index","text":""},{"location":"reference/goose/cli/config.html","title":"Config","text":""},{"location":"reference/goose/cli/config.html#goose.cli.config.ensure_config","title":"<code>ensure_config(name)</code>","text":"<p>Ensure that the config exists and has the default section</p> Source code in <code>src/goose/cli/config.py</code> <pre><code>def ensure_config(name: str) -&gt; Profile:\n    \"\"\"Ensure that the config exists and has the default section\"\"\"\n    # TODO we should copy a templated default config in to better document\n    # but this is complicated a bit by autodetecting the provider\n\n    provider, processor, accelerator = default_model_configuration()\n    profile = default_profiles()[name](provider, processor, accelerator)\n\n    profiles = {}\n    if not PROFILES_CONFIG_PATH.exists():\n        print(\n            Panel(\n                f\"[yellow]No configuration present, we will create a profile '{name}'\"\n                + f\" at: [/]{str(PROFILES_CONFIG_PATH)}\\n\"\n                + \"You can add your own profile in this file to further configure goose!\"\n            )\n        )\n        default = profile\n        profiles = {name: default}\n        write_config(profiles)\n        return profile\n\n    profiles = read_config()\n    if name not in profiles:\n        print(Panel(f\"[yellow]Your configuration doesn't have a profile named '{name}', adding one now[/yellow]\"))\n        profiles.update({name: profile})\n        write_config(profiles)\n    elif name in profiles:\n        # if the profile stored differs from the default one, we should prompt the user to see if they want\n        # to update it! we need to recursively compare the two profiles, as object comparison will always return false\n        is_profile_eq = profile.to_dict() == profiles[name].to_dict()\n        if not is_profile_eq:\n            yaml = YAML()\n            before = StringIO()\n            after = StringIO()\n            yaml.dump(profiles[name].to_dict(), before)\n            yaml.dump(profile.to_dict(), after)\n            before.seek(0)\n            after.seek(0)\n\n            print(\n                Panel(\n                    Text(\n                        f\"Your profile uses one of the default options - '{name}'\"\n                        + \" - but it differs from the latest version:\\n\\n\",\n                    )\n                    + pretty_diff(before.read(), after.read())\n                )\n            )\n            should_update = Confirm.ask(\n                \"Do you want to update your profile to use the latest?\",\n                default=False,\n            )\n            if should_update:\n                profiles[name] = profile\n                write_config(profiles)\n            else:\n                profile = profiles[name]\n\n    return profile\n</code></pre>"},{"location":"reference/goose/cli/config.html#goose.cli.config.read_config","title":"<code>read_config()</code>","text":"<p>Return config from the configuration file and validates its contents</p> Source code in <code>src/goose/cli/config.py</code> <pre><code>def read_config() -&gt; Dict[str, Profile]:\n    \"\"\"Return config from the configuration file and validates its contents\"\"\"\n\n    yaml = YAML()\n    with PROFILES_CONFIG_PATH.open(\"r\") as f:\n        data = yaml.load(f)\n\n    return {name: Profile(**profile) for name, profile in data.items()}\n</code></pre>"},{"location":"reference/goose/cli/config.html#goose.cli.config.write_config","title":"<code>write_config(profiles)</code>","text":"<p>Overwrite the config with the passed profiles</p> Source code in <code>src/goose/cli/config.py</code> <pre><code>def write_config(profiles: Dict[str, Profile]) -&gt; None:\n    \"\"\"Overwrite the config with the passed profiles\"\"\"\n    PROFILES_CONFIG_PATH.parent.mkdir(parents=True, exist_ok=True)\n    converted = {name: profile.to_dict() for name, profile in profiles.items()}\n    yaml = YAML()\n    with PROFILES_CONFIG_PATH.open(\"w\") as f:\n        yaml.dump(converted, f)\n</code></pre>"},{"location":"reference/goose/cli/main.html","title":"Main","text":""},{"location":"reference/goose/cli/main.html#goose.cli.main.get_version","title":"<code>get_version()</code>","text":"<p>Lists the version of goose and any plugins</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@goose_cli.command(name=\"version\")\ndef get_version() -&gt; None:\n    \"\"\"Lists the version of goose and any plugins\"\"\"\n    from importlib.metadata import entry_points, version\n\n    print(f\"[green]Goose-ai[/green]: [bold][cyan]{version('goose-ai')}[/cyan][/bold]\")\n    print(\"[green]Plugins[/green]:\")\n    entry_points = entry_points(group=\"metadata.plugins\")\n    modules = set()\n\n    for ep in entry_points:\n        module_name = ep.name\n        modules.add(module_name)\n    modules.remove(\"goose-ai\")\n    for module in sorted(list(modules)):\n        # TODO: figure out how to get this to work for goose plugins block\n        # as the module name is set to block.goose.cli\n        # module_name = 'goose-plugins-block'\n        try:\n            module_version = version(module)\n            print(f\"  Module: [green]{module}[/green], Version: [bold][cyan]{module_version}[/cyan][/bold]\")\n        except Exception as e:\n            print(f\"  [red]Could not retrieve version for {module}: {e}[/red]\")\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.session","title":"<code>session()</code>","text":"<p>Start or manage sessions</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@goose_cli.group()\ndef session() -&gt; None:\n    \"\"\"Start or manage sessions\"\"\"\n    pass\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.session_clear","title":"<code>session_clear(keep)</code>","text":"<p>Delete old goose sessions, keeping the most recent sessions up to the specified number</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@session.command(name=\"clear\")\n@click.option(\"--keep\", default=3, help=\"Keep this many entries, default 3\")\ndef session_clear(keep: int) -&gt; None:\n    \"\"\"Delete old goose sessions, keeping the most recent sessions up to the specified number\"\"\"\n    for i, (_, session_file) in enumerate(get_session_files().items()):\n        if i &gt;= keep:\n            session_file.unlink()\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.session_list","title":"<code>session_list()</code>","text":"<p>List goose sessions</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@session.command(name=\"list\")\ndef session_list() -&gt; None:\n    \"\"\"List goose sessions\"\"\"\n    session_files = get_session_files().items()\n    for session_name, session_file in session_files:\n        print(f\"{datetime.fromtimestamp(session_file.stat().st_mtime).strftime('%Y-%m-%d %H:%M:%S')}    {session_name}\")\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.session_resume","title":"<code>session_resume(name, profile)</code>","text":"<p>Resume an existing goose session</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@session.command(name=\"resume\")\n@click.argument(\"name\", required=False)\n@click.option(\"--profile\")\ndef session_resume(name: Optional[str], profile: str) -&gt; None:\n    \"\"\"Resume an existing goose session\"\"\"\n    if name is None:\n        session_files = get_session_files()\n        if session_files:\n            name = list(session_files.keys())[0]\n            print(f\"Resuming most recent session: {name} from {session_files[name]}\")\n        else:\n            print(\"No sessions found.\")\n            return\n    session = Session(name=name, profile=profile)\n    session.run()\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.session_start","title":"<code>session_start(profile, log_level, plan=None)</code>","text":"<p>Start a new goose session</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@session.command(name=\"start\")\n@click.option(\"--profile\")\n@click.option(\"--plan\", type=click.Path(exists=True))\n@click.option(\"--log-level\", type=click.Choice([\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]), default=\"INFO\")\ndef session_start(profile: str, log_level: str, plan: Optional[str] = None) -&gt; None:\n    \"\"\"Start a new goose session\"\"\"\n    if plan:\n        yaml = YAML()\n        with open(plan, \"r\") as f:\n            _plan = yaml.load(f)\n    else:\n        _plan = None\n    session = Session(profile=profile, plan=_plan, log_level=log_level)\n    session.run()\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.toolkit","title":"<code>toolkit()</code>","text":"<p>Manage toolkits</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@goose_cli.group()\ndef toolkit() -&gt; None:\n    \"\"\"Manage toolkits\"\"\"\n    pass\n</code></pre>"},{"location":"reference/goose/cli/session.html","title":"Session","text":""},{"location":"reference/goose/cli/session.html#goose.cli.session.Session","title":"<code>Session</code>","text":"<p>A session handler for managing interactions between a user and the Goose exchange</p> <p>This class encapsulates the entire user interaction cycle, from input prompt to response handling, including interruptions and error management.</p> Source code in <code>src/goose/cli/session.py</code> <pre><code>class Session:\n    \"\"\"A session handler for managing interactions between a user and the Goose exchange\n\n    This class encapsulates the entire user interaction cycle, from input prompt to response handling,\n    including interruptions and error management.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: Optional[str] = None,\n        profile: Optional[str] = None,\n        plan: Optional[dict] = None,\n        log_level: Optional[str] = \"INFO\",\n        **kwargs: Dict[str, Any],\n    ) -&gt; None:\n        self.name = name\n        self.status_indicator = Status(\"\", spinner=\"dots\")\n        self.notifier = SessionNotifier(self.status_indicator)\n\n        self.exchange = build_exchange(profile=load_profile(profile), notifier=self.notifier)\n        setup_logging(log_file_directory=LOG_PATH, log_level=log_level)\n\n        if name is not None and self.session_file_path.exists():\n            messages = self.load_session()\n\n            if messages and messages[-1].role == \"user\":\n                if type(messages[-1].content[-1]) is Text:\n                    # remove the last user message\n                    messages.pop()\n                elif type(messages[-1].content[-1]) is ToolResult:\n                    # if we remove this message, we would need to remove\n                    # the previous assistant message as well. instead of doing\n                    # that, we just add a new assistant message to prompt the user\n                    messages.append(Message.assistant(RESUME_MESSAGE))\n            if messages and type(messages[-1].content[-1]) is ToolUse:\n                # remove the last request for a tool to be used\n                messages.pop()\n\n                # add a new assistant text message to prompt the user\n                messages.append(Message.assistant(RESUME_MESSAGE))\n            self.exchange.messages.extend(messages)\n\n        if len(self.exchange.messages) == 0 and plan:\n            self.setup_plan(plan=plan)\n\n        self.prompt_session = GoosePromptSession()\n\n    def setup_plan(self, plan: dict) -&gt; None:\n        if len(self.exchange.messages):\n            raise ValueError(\"The plan can only be set on an empty session.\")\n        self.exchange.messages.append(Message.user(plan[\"kickoff_message\"]))\n        tasks = []\n        if \"tasks\" in plan:\n            tasks = [dict(description=task, status=\"planned\") for task in plan[\"tasks\"]]\n\n        plan_tool_use = ToolUse(id=\"initialplan\", name=\"update_plan\", parameters=dict(tasks=tasks))\n        self.exchange.add_tool_use(plan_tool_use)\n\n    def process_first_message(self) -&gt; Optional[Message]:\n        # Get a first input unless it has been specified, such as by a plan\n        if len(self.exchange.messages) == 0 or self.exchange.messages[-1].role == \"assistant\":\n            user_input = self.prompt_session.get_user_input()\n            if user_input.to_exit():\n                return None\n            return Message.user(text=user_input.text)\n        return self.exchange.messages.pop()\n\n    def run(self) -&gt; None:\n        \"\"\"\n        Runs the main loop to handle user inputs and responses.\n        Continues until an empty string is returned from the prompt.\n        \"\"\"\n        message = self.process_first_message()\n        while message:  # Loop until no input (empty string).\n            self.notifier.start()\n            try:\n                self.exchange.add(message)\n                self.reply()  # Process the user message.\n            except KeyboardInterrupt:\n                self.interrupt_reply()\n            except Exception:\n                # rewind to right before the last user message\n                self.exchange.rewind()\n                print(traceback.format_exc())\n                print(\n                    \"\\n[red]The error above was an exception we were not able to handle.\\n\\n[/]\"\n                    + \"These errors are often related to connection or authentication\\n\"\n                    + \"We've removed the conversation up to the most recent user message\"\n                    + \" - [yellow]depending on the error you may be able to continue[/]\"\n                )\n            self.notifier.stop()\n\n            print()  # Print a newline for separation.\n            user_input = self.prompt_session.get_user_input()\n            message = Message.user(text=user_input.text) if user_input.to_continue() else None\n\n        self.save_session()\n        self._log_cost()\n\n    def reply(self) -&gt; None:\n        \"\"\"Reply to the last user message, calling tools as needed\n\n        Args:\n            text (str): The text input from the user.\n        \"\"\"\n        self.status_indicator.update(\"responding\")\n        response = self.exchange.generate()\n\n        if response.text:\n            print(Markdown(response.text))\n\n        while response.tool_use:\n            content = []\n            for tool_use in response.tool_use:\n                tool_result = self.exchange.call_function(tool_use)\n                content.append(tool_result)\n            self.exchange.add(Message(role=\"user\", content=content))\n            self.status_indicator.update(\"responding\")\n            response = self.exchange.generate()\n\n            if response.text:\n                print(Markdown(response.text))\n\n    def interrupt_reply(self) -&gt; None:\n        \"\"\"Recover from an interruption at an arbitrary state\"\"\"\n        # Default recovery message if no user message is pending.\n        recovery = \"We interrupted before the next processing started.\"\n        if self.exchange.messages and self.exchange.messages[-1].role == \"user\":\n            # If the last message is from the user, remove it.\n            self.exchange.messages.pop()\n            recovery = \"We interrupted before the model replied and removed the last message.\"\n\n        if (\n            self.exchange.messages\n            and self.exchange.messages[-1].role == \"assistant\"\n            and self.exchange.messages[-1].tool_use\n        ):\n            content = []\n            # Append tool results as errors if interrupted.\n            for tool_use in self.exchange.messages[-1].tool_use:\n                content.append(\n                    ToolResult(\n                        tool_use_id=tool_use.id,\n                        output=\"Interrupted by the user to make a correction\",\n                        is_error=True,\n                    )\n                )\n            self.exchange.add(Message(role=\"user\", content=content))\n            recovery = f\"We interrupted the existing call to {tool_use.name}. How would you like to proceed?\"\n            self.exchange.add(Message.assistant(recovery))\n        # Print the recovery message with markup for visibility.\n        print(f\"[yellow]{recovery}[/]\")\n\n    @property\n    def session_file_path(self) -&gt; Path:\n        return session_path(self.name)\n\n    def save_session(self) -&gt; None:\n        \"\"\"Save the current session to a file in JSON format.\"\"\"\n        if self.name is None:\n            self.generate_session_name()\n\n        try:\n            if self.session_file_path.exists():\n                if not confirm(f\"Session {self.name} exists in {self.session_file_path}, overwrite?\"):\n                    self.generate_session_name()\n            write_to_file(self.session_file_path, self.exchange.messages)\n        except PermissionError as e:\n            raise RuntimeError(f\"Failed to save session due to permissions: {e}\")\n        except (IOError, OSError) as e:\n            raise RuntimeError(f\"Failed to save session due to I/O error: {e}\")\n\n    def load_session(self) -&gt; List[Message]:\n        \"\"\"Load a session from a JSON file.\"\"\"\n        return read_from_file(self.session_file_path)\n\n    def generate_session_name(self) -&gt; None:\n        user_entered_session_name = self.prompt_session.get_save_session_name()\n        self.name = user_entered_session_name if user_entered_session_name else droid()\n        print(f\"Saving to [bold cyan]{self.session_file_path}[/bold cyan]\")\n\n    def _log_cost(self) -&gt; None:\n        get_logger().info(get_total_cost_message(self.exchange.get_token_usage()))\n        print(\"You can view the cost and token usage in the log directory\", LOG_PATH)\n</code></pre>"},{"location":"reference/goose/cli/session.html#goose.cli.session.Session.interrupt_reply","title":"<code>interrupt_reply()</code>","text":"<p>Recover from an interruption at an arbitrary state</p> Source code in <code>src/goose/cli/session.py</code> <pre><code>def interrupt_reply(self) -&gt; None:\n    \"\"\"Recover from an interruption at an arbitrary state\"\"\"\n    # Default recovery message if no user message is pending.\n    recovery = \"We interrupted before the next processing started.\"\n    if self.exchange.messages and self.exchange.messages[-1].role == \"user\":\n        # If the last message is from the user, remove it.\n        self.exchange.messages.pop()\n        recovery = \"We interrupted before the model replied and removed the last message.\"\n\n    if (\n        self.exchange.messages\n        and self.exchange.messages[-1].role == \"assistant\"\n        and self.exchange.messages[-1].tool_use\n    ):\n        content = []\n        # Append tool results as errors if interrupted.\n        for tool_use in self.exchange.messages[-1].tool_use:\n            content.append(\n                ToolResult(\n                    tool_use_id=tool_use.id,\n                    output=\"Interrupted by the user to make a correction\",\n                    is_error=True,\n                )\n            )\n        self.exchange.add(Message(role=\"user\", content=content))\n        recovery = f\"We interrupted the existing call to {tool_use.name}. How would you like to proceed?\"\n        self.exchange.add(Message.assistant(recovery))\n    # Print the recovery message with markup for visibility.\n    print(f\"[yellow]{recovery}[/]\")\n</code></pre>"},{"location":"reference/goose/cli/session.html#goose.cli.session.Session.load_session","title":"<code>load_session()</code>","text":"<p>Load a session from a JSON file.</p> Source code in <code>src/goose/cli/session.py</code> <pre><code>def load_session(self) -&gt; List[Message]:\n    \"\"\"Load a session from a JSON file.\"\"\"\n    return read_from_file(self.session_file_path)\n</code></pre>"},{"location":"reference/goose/cli/session.html#goose.cli.session.Session.reply","title":"<code>reply()</code>","text":"<p>Reply to the last user message, calling tools as needed</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text input from the user.</p> required Source code in <code>src/goose/cli/session.py</code> <pre><code>def reply(self) -&gt; None:\n    \"\"\"Reply to the last user message, calling tools as needed\n\n    Args:\n        text (str): The text input from the user.\n    \"\"\"\n    self.status_indicator.update(\"responding\")\n    response = self.exchange.generate()\n\n    if response.text:\n        print(Markdown(response.text))\n\n    while response.tool_use:\n        content = []\n        for tool_use in response.tool_use:\n            tool_result = self.exchange.call_function(tool_use)\n            content.append(tool_result)\n        self.exchange.add(Message(role=\"user\", content=content))\n        self.status_indicator.update(\"responding\")\n        response = self.exchange.generate()\n\n        if response.text:\n            print(Markdown(response.text))\n</code></pre>"},{"location":"reference/goose/cli/session.html#goose.cli.session.Session.run","title":"<code>run()</code>","text":"<p>Runs the main loop to handle user inputs and responses. Continues until an empty string is returned from the prompt.</p> Source code in <code>src/goose/cli/session.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Runs the main loop to handle user inputs and responses.\n    Continues until an empty string is returned from the prompt.\n    \"\"\"\n    message = self.process_first_message()\n    while message:  # Loop until no input (empty string).\n        self.notifier.start()\n        try:\n            self.exchange.add(message)\n            self.reply()  # Process the user message.\n        except KeyboardInterrupt:\n            self.interrupt_reply()\n        except Exception:\n            # rewind to right before the last user message\n            self.exchange.rewind()\n            print(traceback.format_exc())\n            print(\n                \"\\n[red]The error above was an exception we were not able to handle.\\n\\n[/]\"\n                + \"These errors are often related to connection or authentication\\n\"\n                + \"We've removed the conversation up to the most recent user message\"\n                + \" - [yellow]depending on the error you may be able to continue[/]\"\n            )\n        self.notifier.stop()\n\n        print()  # Print a newline for separation.\n        user_input = self.prompt_session.get_user_input()\n        message = Message.user(text=user_input.text) if user_input.to_continue() else None\n\n    self.save_session()\n    self._log_cost()\n</code></pre>"},{"location":"reference/goose/cli/session.html#goose.cli.session.Session.save_session","title":"<code>save_session()</code>","text":"<p>Save the current session to a file in JSON format.</p> Source code in <code>src/goose/cli/session.py</code> <pre><code>def save_session(self) -&gt; None:\n    \"\"\"Save the current session to a file in JSON format.\"\"\"\n    if self.name is None:\n        self.generate_session_name()\n\n    try:\n        if self.session_file_path.exists():\n            if not confirm(f\"Session {self.name} exists in {self.session_file_path}, overwrite?\"):\n                self.generate_session_name()\n        write_to_file(self.session_file_path, self.exchange.messages)\n    except PermissionError as e:\n        raise RuntimeError(f\"Failed to save session due to permissions: {e}\")\n    except (IOError, OSError) as e:\n        raise RuntimeError(f\"Failed to save session due to I/O error: {e}\")\n</code></pre>"},{"location":"reference/goose/cli/prompt/index.html","title":"Index","text":""},{"location":"reference/goose/cli/prompt/completer.html","title":"Completer","text":""},{"location":"reference/goose/cli/prompt/create.html","title":"Create","text":""},{"location":"reference/goose/cli/prompt/create.html#goose.cli.prompt.create.create_prompt","title":"<code>create_prompt(commands)</code>","text":"<p>Create a prompt session with the given commands.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>dict[str, Command]</code> <p>A dictionary of command names, and instances of Command classes.</p> required Source code in <code>src/goose/cli/prompt/create.py</code> <pre><code>def create_prompt(commands: dict[str, Command]) -&gt; PromptSession:\n    \"\"\"\n    Create a prompt session with the given commands.\n\n    Args:\n        commands (dict[str, Command]): A dictionary of command names, and instances of Command classes.\n    \"\"\"\n    # Define custom style\n    style = Style.from_dict(\n        {\n            \"parameter\": \"bold\",\n            \"command\": \"ansiblue bold\",\n            \"text\": \"default\",\n        }\n    )\n\n    bindings = KeyBindings()\n\n    # Bind the \"Option + Enter\" key to insert a newline\n    @bindings.add(Keys.Escape, Keys.ControlM)\n    def _(event: KeyPressEvent) -&gt; None:\n        buffer = event.app.current_buffer\n        buffer.insert_text(\"\\n\")\n\n    # Bind the \"Enter\" key to accept the completion if the completion menu is open\n    # otherwise just submit the input\n    @bindings.add(Keys.Enter)\n    def _(event: KeyPressEvent) -&gt; None:\n        buffer = event.current_buffer\n        app = get_app()\n\n        if app.layout.has_focus(buffer):\n            # Check if the completion menu is open\n            if buffer.complete_state:\n                # accept completion\n                buffer.complete_state = None\n            else:\n                buffer.validate_and_handle()\n\n    @bindings.add(Keys.ControlY)\n    def _(event: KeyPressEvent) -&gt; None:\n        buffer = event.app.current_buffer\n        app = get_app()\n        if app.layout.has_focus(buffer):\n            # Check if the completion menu is open\n            if buffer.complete_state:\n                # accept completion\n                buffer.complete_state = None\n\n    return PromptSession(\n        completer=GoosePromptCompleter(commands=commands),\n        lexer=PromptLexer(list(commands.keys())),\n        style=style,\n        key_bindings=bindings,\n    )\n</code></pre>"},{"location":"reference/goose/cli/prompt/goose_prompt_session.html","title":"Goose prompt session","text":""},{"location":"reference/goose/cli/prompt/lexer.html","title":"Lexer","text":""},{"location":"reference/goose/cli/prompt/prompt_validator.html","title":"Prompt validator","text":""},{"location":"reference/goose/cli/prompt/user_input.html","title":"User input","text":""},{"location":"reference/goose/command/index.html","title":"Index","text":""},{"location":"reference/goose/command/base.html","title":"Base","text":""},{"location":"reference/goose/command/base.html#goose.command.base.Command","title":"<code>Command</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A command that can be executed by the CLI.</p> Source code in <code>src/goose/command/base.py</code> <pre><code>class Command(ABC):\n    \"\"\"A command that can be executed by the CLI.\"\"\"\n\n    def get_completions(self, query: str) -&gt; List[Completion]:\n        \"\"\"\n        Get completions for the command.\n\n        Args:\n            query (str): The current query.\n        \"\"\"\n        return []\n\n    def execute(self, query: str) -&gt; Optional[str]:\n        \"\"\"\n        Execute's the command and replaces it with the output.\n\n        Args:\n            query (str): The query to execute.\n        \"\"\"\n        return \"\"\n</code></pre>"},{"location":"reference/goose/command/base.html#goose.command.base.Command.execute","title":"<code>execute(query)</code>","text":"<p>Execute's the command and replaces it with the output.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to execute.</p> required Source code in <code>src/goose/command/base.py</code> <pre><code>def execute(self, query: str) -&gt; Optional[str]:\n    \"\"\"\n    Execute's the command and replaces it with the output.\n\n    Args:\n        query (str): The query to execute.\n    \"\"\"\n    return \"\"\n</code></pre>"},{"location":"reference/goose/command/base.html#goose.command.base.Command.get_completions","title":"<code>get_completions(query)</code>","text":"<p>Get completions for the command.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The current query.</p> required Source code in <code>src/goose/command/base.py</code> <pre><code>def get_completions(self, query: str) -&gt; List[Completion]:\n    \"\"\"\n    Get completions for the command.\n\n    Args:\n        query (str): The current query.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/goose/command/file.html","title":"File","text":""},{"location":"reference/goose/toolkit/index.html","title":"Index","text":""},{"location":"reference/goose/toolkit/base.html","title":"Base","text":""},{"location":"reference/goose/toolkit/base.html#goose.toolkit.base.Requirements","title":"<code>Requirements</code>","text":"<p>A collection of requirements for advanced toolkits</p> <p>Requirements are an advanced use case, most toolkits will not need to use these. They allow one toolkit to interact with another's state.</p> Source code in <code>src/goose/toolkit/base.py</code> <pre><code>@define\nclass Requirements:\n    \"\"\"A collection of requirements for advanced toolkits\n\n    Requirements are an advanced use case, most toolkits will not need to\n    use these. They allow one toolkit to interact with another's state.\n    \"\"\"\n\n    _toolkit: str\n    _requirements: Mapping[str, \"Toolkit\"] = field(factory=dict)\n\n    def get(self, requirement: str) -&gt; \"Toolkit\":\n        \"\"\"Get a requirement by name.\"\"\"\n        if requirement not in self._requirements:\n            raise RuntimeError(\n                f\"The toolkit '{self._toolkit}' requested a requirement '{requirement}' but none was passed!\\n\"\n                + f\"  Make sure to include `requires: {{{requirement}: ...}}` in your profile config\\n\"\n                + f\"  See the documentation for {self._toolkit} for more details\"\n            )\n        return self._requirements[requirement]\n</code></pre>"},{"location":"reference/goose/toolkit/base.html#goose.toolkit.base.Requirements.get","title":"<code>get(requirement)</code>","text":"<p>Get a requirement by name.</p> Source code in <code>src/goose/toolkit/base.py</code> <pre><code>def get(self, requirement: str) -&gt; \"Toolkit\":\n    \"\"\"Get a requirement by name.\"\"\"\n    if requirement not in self._requirements:\n        raise RuntimeError(\n            f\"The toolkit '{self._toolkit}' requested a requirement '{requirement}' but none was passed!\\n\"\n            + f\"  Make sure to include `requires: {{{requirement}: ...}}` in your profile config\\n\"\n            + f\"  See the documentation for {self._toolkit} for more details\"\n        )\n    return self._requirements[requirement]\n</code></pre>"},{"location":"reference/goose/toolkit/base.html#goose.toolkit.base.Toolkit","title":"<code>Toolkit</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A collection of tools with corresponding prompting</p> <p>This class defines the interface that all toolkit implementations must follow, providing a system prompt and a collection of tools. Both are allowed to be empty if they are not required for the toolkit.</p> Source code in <code>src/goose/toolkit/base.py</code> <pre><code>class Toolkit(ABC):\n    \"\"\"A collection of tools with corresponding prompting\n\n    This class defines the interface that all toolkit implementations must follow,\n    providing a system prompt and a collection of tools. Both are allowed to be\n    empty if they are not required for the toolkit.\n    \"\"\"\n\n    def __init__(self, notifier: Notifier, requires: Optional[Requirements] = None) -&gt; None:\n        self.notifier = notifier\n        # This needs to be updated after the fact via build_exchange\n        self.exchange_view = None\n\n    def system(self) -&gt; str:\n        \"\"\"Get the addition to the system prompt for this toolkit.\"\"\"\n        return \"\"\n\n    def tools(self) -&gt; Tuple[Tool, ...]:\n        \"\"\"Get the tools for this toolkit\n\n        This default method looks for functions on the toolkit annotated\n        with @tool.\n        \"\"\"\n        candidates = inspect.getmembers(self, predicate=inspect.ismethod)\n        return (Tool.from_function(candidate) for _, candidate in candidates if getattr(candidate, \"_is_tool\", None))\n</code></pre>"},{"location":"reference/goose/toolkit/base.html#goose.toolkit.base.Toolkit.system","title":"<code>system()</code>","text":"<p>Get the addition to the system prompt for this toolkit.</p> Source code in <code>src/goose/toolkit/base.py</code> <pre><code>def system(self) -&gt; str:\n    \"\"\"Get the addition to the system prompt for this toolkit.\"\"\"\n    return \"\"\n</code></pre>"},{"location":"reference/goose/toolkit/base.html#goose.toolkit.base.Toolkit.tools","title":"<code>tools()</code>","text":"<p>Get the tools for this toolkit</p> <p>This default method looks for functions on the toolkit annotated with @tool.</p> Source code in <code>src/goose/toolkit/base.py</code> <pre><code>def tools(self) -&gt; Tuple[Tool, ...]:\n    \"\"\"Get the tools for this toolkit\n\n    This default method looks for functions on the toolkit annotated\n    with @tool.\n    \"\"\"\n    candidates = inspect.getmembers(self, predicate=inspect.ismethod)\n    return (Tool.from_function(candidate) for _, candidate in candidates if getattr(candidate, \"_is_tool\", None))\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html","title":"Developer","text":""},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer","title":"<code>Developer</code>","text":"<p>               Bases: <code>Toolkit</code></p> <p>Provides a set of general purpose development capabilities</p> <p>The tools include plan management, a general purpose shell execution tool, and file operations. We also include some default shell strategies in the prompt, such as using ripgrep</p> Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>class Developer(Toolkit):\n    \"\"\"Provides a set of general purpose development capabilities\n\n    The tools include plan management, a general purpose shell execution tool, and file operations.\n    We also include some default shell strategies in the prompt, such as using ripgrep\n    \"\"\"\n\n    def __init__(self, *args: object, **kwargs: Dict[str, object]) -&gt; None:\n        super().__init__(*args, **kwargs)\n        self.timestamps: Dict[str, float] = {}\n\n    def system(self) -&gt; str:\n        \"\"\"Retrieve system configuration details for developer\"\"\"\n        hints_path = Path(\".goosehints\")\n        system_prompt = Message.load(\"prompts/developer.jinja\").text\n        if hints_path.is_file():\n            goosehints = render_template(hints_path)\n            system_prompt = f\"{system_prompt}\\n\\nHints:\\n{goosehints}\"\n        return system_prompt\n\n    @tool\n    def update_plan(self, tasks: List[dict]) -&gt; List[dict]:\n        \"\"\"\n        Update the plan by overwriting all current tasks\n\n        This can be used to update the status of a task. This update will be\n        shown to the user directly, you do not need to reiterate it\n\n        Args:\n            tasks (List(dict)): The list of tasks, where each task is a dictionary\n                with a key for the task \"description\" and the task \"status\". The status\n                MUST be one of \"planned\", \"complete\", \"failed\", \"in-progress\".\n\n        \"\"\"\n        # Validate the status of each task to ensure it is one of the accepted values.\n        for task in tasks:\n            if task[\"status\"] not in {\"planned\", \"complete\", \"failed\", \"in-progress\"}:\n                raise ValueError(f\"Invalid task status: {task['status']}\")\n\n        # Create a table with columns for the index, description, and status of each task.\n        table = Table(expand=True)\n        table.add_column(\"#\", justify=\"right\", style=\"magenta\")\n        table.add_column(\"Task\", justify=\"left\")\n        table.add_column(\"Status\", justify=\"left\")\n\n        # Mapping of statuses to emojis for better visual representation in the table.\n        emoji = {\"planned\": \"\u23f3\", \"complete\": \"\u2705\", \"failed\": \"\u274c\", \"in-progress\": \"\ud83d\udd51\"}\n        for i, entry in enumerate(tasks):\n            table.add_row(str(i), entry[\"description\"], emoji[entry[\"status\"]])\n\n        # Log the table to display it directly to the user\n        # `.log` method is used here to log the command execution in the application's UX\n        self.notifier.log(table)\n\n        # Return the tasks unchanged as the function's primary purpose is to update and display the task status.\n        return tasks\n\n    @tool\n    def patch_file(self, path: str, before: str, after: str) -&gt; str:\n        \"\"\"Patch the file at the specified by replacing before with after\n\n        Before **must** be present exactly once in the file, so that it can safely\n        be replaced with after.\n\n        Args:\n            path (str): The path to the file, in the format \"path/to/file.txt\"\n            before (str): The content that will be replaced\n            after (str): The content it will be replaced with\n        \"\"\"\n        self.notifier.status(f\"editing {path}\")\n        _path = Path(path)\n        language = get_language(path)\n\n        content = _path.read_text()\n\n        if content.count(before) &gt; 1:\n            raise ValueError(\"The before content is present multiple times in the file, be more specific.\")\n        if content.count(before) &lt; 1:\n            raise ValueError(\"The before content was not found in file, be careful that you recreate it exactly.\")\n\n        content = content.replace(before, after)\n        _path.write_text(content)\n\n        output = f\"\"\"\n```{language}\n{before}\n```\n-&gt;\n```{language}\n{after}\n```\n\"\"\"\n        self.notifier.log(Panel.fit(Markdown(output), title=path))\n        return \"Succesfully replaced before with after.\"\n\n    @tool\n    def read_file(self, path: str) -&gt; str:\n        \"\"\"Read the content of the file at path\n\n        Args:\n            path (str): The destination file path, in the format \"path/to/file.txt\"\n        \"\"\"\n        language = get_language(path)\n        content = Path(path).expanduser().read_text()\n        self.notifier.log(Panel.fit(Markdown(f\"```\\ncat {path}\\n```\"), box=box.MINIMAL))\n        # Record the last read timestamp\n        self.timestamps[path] = os.path.getmtime(path)\n        return f\"```{language}\\n{content}\\n```\"\n\n    @tool\n    def shell(self, command: str) -&gt; str:\n        \"\"\"\n        Execute a command on the shell\n\n        This will return the output and error concatenated into a single string, as\n        you would see from running on the command line. There will also be an indication\n        of if the command succeeded or failed.\n\n        Args:\n            command (str): The shell command to run. It can support multiline statements\n                if you need to run more than one at a time\n        \"\"\"\n        # Log the command being executed in a visually structured format (Markdown).\n        self.notifier.log(Panel.fit(Markdown(f\"```bash\\n{command}\\n```\"), title=\"shell\"))\n\n        if is_dangerous_command(command):\n            # Stop the notifications so we can prompt\n            self.notifier.stop()\n            if not keep_unsafe_command_prompt(command):\n                raise RuntimeError(\n                    f\"The command {command} was rejected as dangerous by the user.\"\n                    \" Do not proceed further, instead ask for instructions.\"\n                )\n            self.notifier.start()\n        self.notifier.status(\"running shell command\")\n\n        # Define patterns that might indicate the process is waiting for input\n        interaction_patterns = [\n            r\"Do you want to\",  # Common prompt phrase\n            r\"Enter password\",  # Password prompt\n            r\"Are you sure\",  # Confirmation prompt\n            r\"\\(y/N\\)\",  # Yes/No prompt\n            r\"Press any key to continue\",  # Awaiting keypress\n            r\"Waiting for input\",  # General waiting message\n            r\"\\?\\s\",  # Prompts starting with '? '\n        ]\n        compiled_patterns = [re.compile(pattern, re.IGNORECASE) for pattern in interaction_patterns]\n\n        proc = subprocess.Popen(\n            command,\n            shell=True,\n            stdin=subprocess.DEVNULL,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            text=True,\n        )\n        # this enables us to read lines without blocking\n        os.set_blocking(proc.stdout.fileno(), False)\n\n        # Accumulate the output logs while checking if it might be blocked\n        output_lines = []\n        last_output_time = time.time()\n        cutoff = 10\n        while proc.poll() is None:\n            self.notifier.status(\"running shell command\")\n            line = proc.stdout.readline()\n            if line:\n                output_lines.append(line)\n                last_output_time = time.time()\n\n            # If we see a clear pattern match, we plan to abort\n            exit_criteria = any(pattern.search(line) for pattern in compiled_patterns)\n\n            # and if we haven't seen a new line in 10+s, check with AI to see if it may be stuck\n            if not exit_criteria and time.time() - last_output_time &gt; cutoff:\n                self.notifier.status(\"checking on shell status\")\n                response = ask_an_ai(\n                    input=\"\\n\".join([command] + output_lines),\n                    prompt=(\n                        \"You will evaluate the output of shell commands to see if they may be stuck.\"\n                        \" Look for commands that appear to be awaiting user input, or otherwise running indefinitely (such as a web service).\"  # noqa\n                        \" A command that will take a while, such as downloading resources is okay.\"  # noqa\n                        \" return [Yes] if stuck, [No] otherwise.\"\n                    ),\n                    exchange=self.exchange_view.processor,\n                    with_tools=False,\n                )\n                exit_criteria = \"[yes]\" in response.content[0].text.lower()\n                # We add exponential backoff for how often we check for the command being stuck\n                cutoff *= 10\n\n            if exit_criteria:\n                proc.terminate()\n                raise ValueError(\n                    f\"The command `{command}` looks like it will run indefinitely or is otherwise stuck.\"\n                    f\"You may be able to specify inputs if it applies to this command.\"\n                    f\"Otherwise to enable continued iteration, you'll need to ask the user to run this command in another terminal.\"  # noqa\n                )\n\n        # read any remaining lines\n        while line := proc.stdout.readline():\n            output_lines.append(line)\n        output = \"\".join(output_lines)\n\n        # Determine the result based on the return code\n        if proc.returncode == 0:\n            result = \"Command succeeded\"\n        else:\n            result = f\"Command failed with returncode {proc.returncode}\"\n\n        # Return the combined result and outputs if we made it this far\n        return \"\\n\".join([result, output])\n\n    @tool\n    def write_file(self, path: str, content: str) -&gt; str:\n        \"\"\"\n        Write a file at the specified path with the provided content. This will create any directories if they do not exist.\n        The content will fully overwrite the existing file.\n\n        Args:\n            path (str): The destination file path, in the format \"path/to/file.txt\"\n            content (str): The raw file content.\n        \"\"\"  # noqa: E501\n        self.notifier.status(\"writing file\")\n        # Get the programming language for syntax highlighting in logs\n        language = get_language(path)\n        md = f\"```{language}\\n{content}\\n```\"\n\n        # Log the content that will be written to the file\n        # .log` method is used here to log the command execution in the application's UX\n        # this method is dynamically attached to functions in the Goose framework\n        self.notifier.log(Panel.fit(Markdown(md), title=path))\n\n        _path = Path(path)\n        if path in self.timestamps:\n            last_read_timestamp = self.timestamps.get(path, 0.0)\n            current_timestamp = os.path.getmtime(path)\n            if current_timestamp &gt; last_read_timestamp:\n                raise RuntimeError(\n                    f\"File '{path}' has been modified since it was last read.\"\n                    + \" Read the file to incorporate changes or update your plan.\"\n                )\n\n        # Prepare the path and create any necessary parent directories\n        _path.parent.mkdir(parents=True, exist_ok=True)\n\n        # Write the content to the file\n        _path.write_text(content)\n\n        # Update the last read timestamp after writing to the file\n        self.timestamps[path] = os.path.getmtime(path)\n\n        # Return a success message\n        return f\"Successfully wrote to {path}\"\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer.patch_file","title":"<code>patch_file(path, before, after)</code>","text":"<p>Patch the file at the specified by replacing before with after</p> <p>Before must be present exactly once in the file, so that it can safely be replaced with after.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file, in the format \"path/to/file.txt\"</p> required <code>before</code> <code>str</code> <p>The content that will be replaced</p> required <code>after</code> <code>str</code> <p>The content it will be replaced with</p> required Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>    @tool\n    def patch_file(self, path: str, before: str, after: str) -&gt; str:\n        \"\"\"Patch the file at the specified by replacing before with after\n\n        Before **must** be present exactly once in the file, so that it can safely\n        be replaced with after.\n\n        Args:\n            path (str): The path to the file, in the format \"path/to/file.txt\"\n            before (str): The content that will be replaced\n            after (str): The content it will be replaced with\n        \"\"\"\n        self.notifier.status(f\"editing {path}\")\n        _path = Path(path)\n        language = get_language(path)\n\n        content = _path.read_text()\n\n        if content.count(before) &gt; 1:\n            raise ValueError(\"The before content is present multiple times in the file, be more specific.\")\n        if content.count(before) &lt; 1:\n            raise ValueError(\"The before content was not found in file, be careful that you recreate it exactly.\")\n\n        content = content.replace(before, after)\n        _path.write_text(content)\n\n        output = f\"\"\"\n```{language}\n{before}\n```\n-&gt;\n```{language}\n{after}\n```\n\"\"\"\n        self.notifier.log(Panel.fit(Markdown(output), title=path))\n        return \"Succesfully replaced before with after.\"\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer.read_file","title":"<code>read_file(path)</code>","text":"<p>Read the content of the file at path</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The destination file path, in the format \"path/to/file.txt\"</p> required Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>@tool\ndef read_file(self, path: str) -&gt; str:\n    \"\"\"Read the content of the file at path\n\n    Args:\n        path (str): The destination file path, in the format \"path/to/file.txt\"\n    \"\"\"\n    language = get_language(path)\n    content = Path(path).expanduser().read_text()\n    self.notifier.log(Panel.fit(Markdown(f\"```\\ncat {path}\\n```\"), box=box.MINIMAL))\n    # Record the last read timestamp\n    self.timestamps[path] = os.path.getmtime(path)\n    return f\"```{language}\\n{content}\\n```\"\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer.shell","title":"<code>shell(command)</code>","text":"<p>Execute a command on the shell</p> <p>This will return the output and error concatenated into a single string, as you would see from running on the command line. There will also be an indication of if the command succeeded or failed.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The shell command to run. It can support multiline statements if you need to run more than one at a time</p> required Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>@tool\ndef shell(self, command: str) -&gt; str:\n    \"\"\"\n    Execute a command on the shell\n\n    This will return the output and error concatenated into a single string, as\n    you would see from running on the command line. There will also be an indication\n    of if the command succeeded or failed.\n\n    Args:\n        command (str): The shell command to run. It can support multiline statements\n            if you need to run more than one at a time\n    \"\"\"\n    # Log the command being executed in a visually structured format (Markdown).\n    self.notifier.log(Panel.fit(Markdown(f\"```bash\\n{command}\\n```\"), title=\"shell\"))\n\n    if is_dangerous_command(command):\n        # Stop the notifications so we can prompt\n        self.notifier.stop()\n        if not keep_unsafe_command_prompt(command):\n            raise RuntimeError(\n                f\"The command {command} was rejected as dangerous by the user.\"\n                \" Do not proceed further, instead ask for instructions.\"\n            )\n        self.notifier.start()\n    self.notifier.status(\"running shell command\")\n\n    # Define patterns that might indicate the process is waiting for input\n    interaction_patterns = [\n        r\"Do you want to\",  # Common prompt phrase\n        r\"Enter password\",  # Password prompt\n        r\"Are you sure\",  # Confirmation prompt\n        r\"\\(y/N\\)\",  # Yes/No prompt\n        r\"Press any key to continue\",  # Awaiting keypress\n        r\"Waiting for input\",  # General waiting message\n        r\"\\?\\s\",  # Prompts starting with '? '\n    ]\n    compiled_patterns = [re.compile(pattern, re.IGNORECASE) for pattern in interaction_patterns]\n\n    proc = subprocess.Popen(\n        command,\n        shell=True,\n        stdin=subprocess.DEVNULL,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT,\n        text=True,\n    )\n    # this enables us to read lines without blocking\n    os.set_blocking(proc.stdout.fileno(), False)\n\n    # Accumulate the output logs while checking if it might be blocked\n    output_lines = []\n    last_output_time = time.time()\n    cutoff = 10\n    while proc.poll() is None:\n        self.notifier.status(\"running shell command\")\n        line = proc.stdout.readline()\n        if line:\n            output_lines.append(line)\n            last_output_time = time.time()\n\n        # If we see a clear pattern match, we plan to abort\n        exit_criteria = any(pattern.search(line) for pattern in compiled_patterns)\n\n        # and if we haven't seen a new line in 10+s, check with AI to see if it may be stuck\n        if not exit_criteria and time.time() - last_output_time &gt; cutoff:\n            self.notifier.status(\"checking on shell status\")\n            response = ask_an_ai(\n                input=\"\\n\".join([command] + output_lines),\n                prompt=(\n                    \"You will evaluate the output of shell commands to see if they may be stuck.\"\n                    \" Look for commands that appear to be awaiting user input, or otherwise running indefinitely (such as a web service).\"  # noqa\n                    \" A command that will take a while, such as downloading resources is okay.\"  # noqa\n                    \" return [Yes] if stuck, [No] otherwise.\"\n                ),\n                exchange=self.exchange_view.processor,\n                with_tools=False,\n            )\n            exit_criteria = \"[yes]\" in response.content[0].text.lower()\n            # We add exponential backoff for how often we check for the command being stuck\n            cutoff *= 10\n\n        if exit_criteria:\n            proc.terminate()\n            raise ValueError(\n                f\"The command `{command}` looks like it will run indefinitely or is otherwise stuck.\"\n                f\"You may be able to specify inputs if it applies to this command.\"\n                f\"Otherwise to enable continued iteration, you'll need to ask the user to run this command in another terminal.\"  # noqa\n            )\n\n    # read any remaining lines\n    while line := proc.stdout.readline():\n        output_lines.append(line)\n    output = \"\".join(output_lines)\n\n    # Determine the result based on the return code\n    if proc.returncode == 0:\n        result = \"Command succeeded\"\n    else:\n        result = f\"Command failed with returncode {proc.returncode}\"\n\n    # Return the combined result and outputs if we made it this far\n    return \"\\n\".join([result, output])\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer.system","title":"<code>system()</code>","text":"<p>Retrieve system configuration details for developer</p> Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>def system(self) -&gt; str:\n    \"\"\"Retrieve system configuration details for developer\"\"\"\n    hints_path = Path(\".goosehints\")\n    system_prompt = Message.load(\"prompts/developer.jinja\").text\n    if hints_path.is_file():\n        goosehints = render_template(hints_path)\n        system_prompt = f\"{system_prompt}\\n\\nHints:\\n{goosehints}\"\n    return system_prompt\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer.update_plan","title":"<code>update_plan(tasks)</code>","text":"<p>Update the plan by overwriting all current tasks</p> <p>This can be used to update the status of a task. This update will be shown to the user directly, you do not need to reiterate it</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>List(dict</code> <p>The list of tasks, where each task is a dictionary with a key for the task \"description\" and the task \"status\". The status MUST be one of \"planned\", \"complete\", \"failed\", \"in-progress\".</p> required Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>@tool\ndef update_plan(self, tasks: List[dict]) -&gt; List[dict]:\n    \"\"\"\n    Update the plan by overwriting all current tasks\n\n    This can be used to update the status of a task. This update will be\n    shown to the user directly, you do not need to reiterate it\n\n    Args:\n        tasks (List(dict)): The list of tasks, where each task is a dictionary\n            with a key for the task \"description\" and the task \"status\". The status\n            MUST be one of \"planned\", \"complete\", \"failed\", \"in-progress\".\n\n    \"\"\"\n    # Validate the status of each task to ensure it is one of the accepted values.\n    for task in tasks:\n        if task[\"status\"] not in {\"planned\", \"complete\", \"failed\", \"in-progress\"}:\n            raise ValueError(f\"Invalid task status: {task['status']}\")\n\n    # Create a table with columns for the index, description, and status of each task.\n    table = Table(expand=True)\n    table.add_column(\"#\", justify=\"right\", style=\"magenta\")\n    table.add_column(\"Task\", justify=\"left\")\n    table.add_column(\"Status\", justify=\"left\")\n\n    # Mapping of statuses to emojis for better visual representation in the table.\n    emoji = {\"planned\": \"\u23f3\", \"complete\": \"\u2705\", \"failed\": \"\u274c\", \"in-progress\": \"\ud83d\udd51\"}\n    for i, entry in enumerate(tasks):\n        table.add_row(str(i), entry[\"description\"], emoji[entry[\"status\"]])\n\n    # Log the table to display it directly to the user\n    # `.log` method is used here to log the command execution in the application's UX\n    self.notifier.log(table)\n\n    # Return the tasks unchanged as the function's primary purpose is to update and display the task status.\n    return tasks\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer.write_file","title":"<code>write_file(path, content)</code>","text":"<p>Write a file at the specified path with the provided content. This will create any directories if they do not exist. The content will fully overwrite the existing file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The destination file path, in the format \"path/to/file.txt\"</p> required <code>content</code> <code>str</code> <p>The raw file content.</p> required Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>@tool\ndef write_file(self, path: str, content: str) -&gt; str:\n    \"\"\"\n    Write a file at the specified path with the provided content. This will create any directories if they do not exist.\n    The content will fully overwrite the existing file.\n\n    Args:\n        path (str): The destination file path, in the format \"path/to/file.txt\"\n        content (str): The raw file content.\n    \"\"\"  # noqa: E501\n    self.notifier.status(\"writing file\")\n    # Get the programming language for syntax highlighting in logs\n    language = get_language(path)\n    md = f\"```{language}\\n{content}\\n```\"\n\n    # Log the content that will be written to the file\n    # .log` method is used here to log the command execution in the application's UX\n    # this method is dynamically attached to functions in the Goose framework\n    self.notifier.log(Panel.fit(Markdown(md), title=path))\n\n    _path = Path(path)\n    if path in self.timestamps:\n        last_read_timestamp = self.timestamps.get(path, 0.0)\n        current_timestamp = os.path.getmtime(path)\n        if current_timestamp &gt; last_read_timestamp:\n            raise RuntimeError(\n                f\"File '{path}' has been modified since it was last read.\"\n                + \" Read the file to incorporate changes or update your plan.\"\n            )\n\n    # Prepare the path and create any necessary parent directories\n    _path.parent.mkdir(parents=True, exist_ok=True)\n\n    # Write the content to the file\n    _path.write_text(content)\n\n    # Update the last read timestamp after writing to the file\n    self.timestamps[path] = os.path.getmtime(path)\n\n    # Return a success message\n    return f\"Successfully wrote to {path}\"\n</code></pre>"},{"location":"reference/goose/toolkit/github.html","title":"Github","text":""},{"location":"reference/goose/toolkit/github.html#goose.toolkit.github.Github","title":"<code>Github</code>","text":"<p>               Bases: <code>Toolkit</code></p> <p>Provides an additional prompt on how to interact with Github</p> Source code in <code>src/goose/toolkit/github.py</code> <pre><code>class Github(Toolkit):\n    \"\"\"Provides an additional prompt on how to interact with Github\"\"\"\n\n    def system(self) -&gt; str:\n        \"\"\"Retrieve detailed configuration and procedural guidelines for GitHub operations\"\"\"\n        return Message.load(\"prompts/github.jinja\").text\n</code></pre>"},{"location":"reference/goose/toolkit/github.html#goose.toolkit.github.Github.system","title":"<code>system()</code>","text":"<p>Retrieve detailed configuration and procedural guidelines for GitHub operations</p> Source code in <code>src/goose/toolkit/github.py</code> <pre><code>def system(self) -&gt; str:\n    \"\"\"Retrieve detailed configuration and procedural guidelines for GitHub operations\"\"\"\n    return Message.load(\"prompts/github.jinja\").text\n</code></pre>"},{"location":"reference/goose/toolkit/lint.html","title":"Lint","text":""},{"location":"reference/goose/toolkit/screen.html","title":"Screen","text":""},{"location":"reference/goose/toolkit/screen.html#goose.toolkit.screen.Screen","title":"<code>Screen</code>","text":"<p>               Bases: <code>Toolkit</code></p> <p>Provides an instructions on when and how to work with screenshots</p> Source code in <code>src/goose/toolkit/screen.py</code> <pre><code>class Screen(Toolkit):\n    \"\"\"Provides an instructions on when and how to work with screenshots\"\"\"\n\n    @tool\n    def take_screenshot(self, display: int = 1) -&gt; str:\n        \"\"\"\n        Take a screenshot to assist the user in debugging or designing an app. They may need\n        help with moving a screen element, or interacting in some way where you could do with\n        seeing the screen.\n\n        Args:\n            display (int): Display to take the screen shot in. Default is the main display (1). Must be a value greater than 1.\n        \"\"\"  # noqa: E501\n        # Generate a random tmp filename for screenshot\n        filename = f\"/tmp/goose_screenshot_{uuid.uuid4().hex}.jpg\"\n        screen_capture_command = [\"screencapture\", \"-x\", \"-D\", str(display), filename, \"-f\", \"jpg\"]\n\n        subprocess.run(screen_capture_command, check=True, capture_output=True)\n\n        resize_command = [\"sips\", \"--resampleWidth\", \"768\", filename, \"-s\", \"format\", \"jpeg\"]\n        subprocess.run(resize_command, check=True, capture_output=True)\n\n        self.notifier.log(\n            Panel.fit(\n                Markdown(f\"```bash\\n{' '.join(screen_capture_command)}\"),\n                title=\"screen\",\n            )\n        )\n\n        return f\"image:{filename}\"\n\n    # Provide any system instructions for the model\n    # This can be generated dynamically, and is run at startup time\n    def system(self) -&gt; str:\n        return \"\"\"**When the user wants you to help debug, or work on a visual design by looking at their screen, IDE or browser, call the take_screenshot and send the output from the user.**\"\"\"  # noqa: E501\n</code></pre>"},{"location":"reference/goose/toolkit/screen.html#goose.toolkit.screen.Screen.take_screenshot","title":"<code>take_screenshot(display=1)</code>","text":"<p>Take a screenshot to assist the user in debugging or designing an app. They may need help with moving a screen element, or interacting in some way where you could do with seeing the screen.</p> <p>Parameters:</p> Name Type Description Default <code>display</code> <code>int</code> <p>Display to take the screen shot in. Default is the main display (1). Must be a value greater than 1.</p> <code>1</code> Source code in <code>src/goose/toolkit/screen.py</code> <pre><code>@tool\ndef take_screenshot(self, display: int = 1) -&gt; str:\n    \"\"\"\n    Take a screenshot to assist the user in debugging or designing an app. They may need\n    help with moving a screen element, or interacting in some way where you could do with\n    seeing the screen.\n\n    Args:\n        display (int): Display to take the screen shot in. Default is the main display (1). Must be a value greater than 1.\n    \"\"\"  # noqa: E501\n    # Generate a random tmp filename for screenshot\n    filename = f\"/tmp/goose_screenshot_{uuid.uuid4().hex}.jpg\"\n    screen_capture_command = [\"screencapture\", \"-x\", \"-D\", str(display), filename, \"-f\", \"jpg\"]\n\n    subprocess.run(screen_capture_command, check=True, capture_output=True)\n\n    resize_command = [\"sips\", \"--resampleWidth\", \"768\", filename, \"-s\", \"format\", \"jpeg\"]\n    subprocess.run(resize_command, check=True, capture_output=True)\n\n    self.notifier.log(\n        Panel.fit(\n            Markdown(f\"```bash\\n{' '.join(screen_capture_command)}\"),\n            title=\"screen\",\n        )\n    )\n\n    return f\"image:{filename}\"\n</code></pre>"},{"location":"reference/goose/toolkit/utils.html","title":"Utils","text":""},{"location":"reference/goose/toolkit/utils.html#goose.toolkit.utils.get_language","title":"<code>get_language(filename)</code>","text":"<p>Determine the programming language of a file based on its filename extension.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file for which to determine the programming language.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the programming language if recognized, otherwise an empty string.</p> Source code in <code>src/goose/toolkit/utils.py</code> <pre><code>def get_language(filename: Path) -&gt; str:\n    \"\"\"\n    Determine the programming language of a file based on its filename extension.\n\n    Args:\n        filename (str): The name of the file for which to determine the programming language.\n\n    Returns:\n        str: The name of the programming language if recognized, otherwise an empty string.\n    \"\"\"\n    try:\n        lexer = get_lexer_for_filename(filename)\n        return lexer.name\n    except ClassNotFound:\n        return \"\"\n</code></pre>"},{"location":"reference/goose/toolkit/utils.html#goose.toolkit.utils.render_template","title":"<code>render_template(template_path, context=None)</code>","text":"<p>Renders a Jinja2 template given a Pathlib path, with no context needed.</p> <p>:param template_path: Path to the Jinja2 template file. :param context: Optional dictionary containing the context for rendering the template. :return: Rendered template as a string.</p> Source code in <code>src/goose/toolkit/utils.py</code> <pre><code>def render_template(template_path: Path, context: Optional[dict] = None) -&gt; str:\n    \"\"\"\n    Renders a Jinja2 template given a Pathlib path, with no context needed.\n\n    :param template_path: Path to the Jinja2 template file.\n    :param context: Optional dictionary containing the context for rendering the template.\n    :return: Rendered template as a string.\n    \"\"\"\n    # Ensure the path is absolute and exists\n    if not template_path.is_absolute():\n        template_path = template_path.resolve()\n\n    if not template_path.exists():\n        raise FileNotFoundError(f\"Template file {template_path} does not exist.\")\n\n    env = Environment(loader=FileSystemLoader(template_path.parent))\n    template = env.get_template(template_path.name)\n    return template.render(context or {})\n</code></pre>"},{"location":"reference/goose/toolkit/repo_context/index.html","title":"Index","text":""},{"location":"reference/goose/toolkit/repo_context/repo_context.html","title":"Repo context","text":""},{"location":"reference/goose/toolkit/repo_context/repo_context.html#goose.toolkit.repo_context.repo_context.RepoContext","title":"<code>RepoContext</code>","text":"<p>               Bases: <code>Toolkit</code></p> <p>Provides context about the current repository</p> Source code in <code>src/goose/toolkit/repo_context/repo_context.py</code> <pre><code>class RepoContext(Toolkit):\n    \"\"\"Provides context about the current repository\"\"\"\n\n    def __init__(self, notifier: Notifier, requires: Requirements) -&gt; None:\n        super().__init__(notifier=notifier, requires=requires)\n\n        self.repo_project_root, self.is_git_repo, self.goose_session_root = self.determine_git_proj()\n\n    def determine_git_proj(self) -&gt; Tuple[str, bool, str]:\n        \"\"\"Determines the root as well as where Goose is currently running\n\n        If the project is not part of a Github repo, the root of the project will be defined as the current working\n        directory\n\n        Returns:\n            str: path to the root of the project (if part of a local repository) or the CWD if not\n            boolean: if Goose is operating within local repository or not\n            str: path to where the Goose session is running (the CWD)\n        \"\"\"\n        # FIXME: monorepos\n        cwd = os.getcwd()\n        command = \"git rev-parse --show-toplevel\"\n        result: CompletedProcess = run(command, shell=True, text=True, capture_output=True, check=False)\n        if result.returncode == 0:\n            project_root = result.stdout.strip()\n            return project_root, True, cwd\n        else:\n            self.notifier.log(\"Not part of a Git repository. Returning current working directory\")\n            return cwd, False, cwd\n\n    @property\n    @cache\n    def repo_size(self) -&gt; float:\n        \"\"\"Returns the size of the repo in MB (if Goose detects its running in a local repository\n\n        This measurement can be used to guess if the local repository is a monorepo\n\n        Returns:\n            float: size of project in MB\n        \"\"\"\n        # in MB\n        if self.is_git_repo:\n            return get_repo_size(self.repo_project_root)\n        else:\n            self.notifier.log(\"Not a git repo. Returning 0.\")\n            return 0.0\n\n    @property\n    def is_mono_repo(self) -&gt; bool:\n        \"\"\"An boolean indicator of whether the local repository is part of a monorepo\n\n        Returns:\n            boolean: True if above 2000 MB; False otherwise\n        \"\"\"\n        # java: 6394.367112159729\n        # go: 3729.93 MB\n        return self.repo_size &gt; 2000\n\n    @tool\n    def summarize_current_project(self) -&gt; Dict[str, str]:\n        \"\"\"Summarizes the current project based on repo root (if git repo) or current project_directory (if not)\n\n        Returns:\n            summary (Dict[str, str]): Keys are file paths and values are the summaries\n        \"\"\"\n\n        self.notifier.log(\"Summarizing the most relevant files in the current project. This may take a while...\")\n\n        if self.is_mono_repo:\n            self.notifier.log(\"This might be a monorepo. Goose performs better on smaller projects. Using CWD.\")\n            # TODO: prompt user to specify a subdirectory\n            project_directory = self.goose_session_root\n        else:\n            project_directory = self.repo_project_root\n\n        # before selecting files and summarizing look for summarization file\n        project_name = project_directory.split(\"/\")[-1]\n        summary = load_summary_file_if_exists(project_name=project_name)\n        if summary:\n            self.notifier.log(\"Summary file for project exists already -- loading into the context\")\n            return summary\n\n        # clear exchange and replace the system prompt with instructions on why and how to select files to summarize\n        file_select_exchange = clear_exchange(self.exchange_view.accelerator, clear_tools=True)\n        system = Message.load(\"prompts/repo_context.jinja\").text\n        file_select_exchange = replace_prompt(exchange=file_select_exchange, prompt=system)\n        files = goose_picks_files(root=project_directory, exchange=file_select_exchange)\n\n        summary = summarize_files_concurrent(\n            exchange=self.exchange_view.accelerator, file_list=files, project_name=project_directory.split(\"/\")[-1]\n        )\n\n        return summary\n</code></pre>"},{"location":"reference/goose/toolkit/repo_context/repo_context.html#goose.toolkit.repo_context.repo_context.RepoContext.is_mono_repo","title":"<code>is_mono_repo: bool</code>  <code>property</code>","text":"<p>An boolean indicator of whether the local repository is part of a monorepo</p> <p>Returns:</p> Name Type Description <code>boolean</code> <code>bool</code> <p>True if above 2000 MB; False otherwise</p>"},{"location":"reference/goose/toolkit/repo_context/repo_context.html#goose.toolkit.repo_context.repo_context.RepoContext.repo_size","title":"<code>repo_size: float</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the size of the repo in MB (if Goose detects its running in a local repository</p> <p>This measurement can be used to guess if the local repository is a monorepo</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>size of project in MB</p>"},{"location":"reference/goose/toolkit/repo_context/repo_context.html#goose.toolkit.repo_context.repo_context.RepoContext.determine_git_proj","title":"<code>determine_git_proj()</code>","text":"<p>Determines the root as well as where Goose is currently running</p> <p>If the project is not part of a Github repo, the root of the project will be defined as the current working directory</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>path to the root of the project (if part of a local repository) or the CWD if not</p> <code>boolean</code> <code>bool</code> <p>if Goose is operating within local repository or not</p> <code>str</code> <code>str</code> <p>path to where the Goose session is running (the CWD)</p> Source code in <code>src/goose/toolkit/repo_context/repo_context.py</code> <pre><code>def determine_git_proj(self) -&gt; Tuple[str, bool, str]:\n    \"\"\"Determines the root as well as where Goose is currently running\n\n    If the project is not part of a Github repo, the root of the project will be defined as the current working\n    directory\n\n    Returns:\n        str: path to the root of the project (if part of a local repository) or the CWD if not\n        boolean: if Goose is operating within local repository or not\n        str: path to where the Goose session is running (the CWD)\n    \"\"\"\n    # FIXME: monorepos\n    cwd = os.getcwd()\n    command = \"git rev-parse --show-toplevel\"\n    result: CompletedProcess = run(command, shell=True, text=True, capture_output=True, check=False)\n    if result.returncode == 0:\n        project_root = result.stdout.strip()\n        return project_root, True, cwd\n    else:\n        self.notifier.log(\"Not part of a Git repository. Returning current working directory\")\n        return cwd, False, cwd\n</code></pre>"},{"location":"reference/goose/toolkit/repo_context/repo_context.html#goose.toolkit.repo_context.repo_context.RepoContext.summarize_current_project","title":"<code>summarize_current_project()</code>","text":"<p>Summarizes the current project based on repo root (if git repo) or current project_directory (if not)</p> <p>Returns:</p> Name Type Description <code>summary</code> <code>Dict[str, str]</code> <p>Keys are file paths and values are the summaries</p> Source code in <code>src/goose/toolkit/repo_context/repo_context.py</code> <pre><code>@tool\ndef summarize_current_project(self) -&gt; Dict[str, str]:\n    \"\"\"Summarizes the current project based on repo root (if git repo) or current project_directory (if not)\n\n    Returns:\n        summary (Dict[str, str]): Keys are file paths and values are the summaries\n    \"\"\"\n\n    self.notifier.log(\"Summarizing the most relevant files in the current project. This may take a while...\")\n\n    if self.is_mono_repo:\n        self.notifier.log(\"This might be a monorepo. Goose performs better on smaller projects. Using CWD.\")\n        # TODO: prompt user to specify a subdirectory\n        project_directory = self.goose_session_root\n    else:\n        project_directory = self.repo_project_root\n\n    # before selecting files and summarizing look for summarization file\n    project_name = project_directory.split(\"/\")[-1]\n    summary = load_summary_file_if_exists(project_name=project_name)\n    if summary:\n        self.notifier.log(\"Summary file for project exists already -- loading into the context\")\n        return summary\n\n    # clear exchange and replace the system prompt with instructions on why and how to select files to summarize\n    file_select_exchange = clear_exchange(self.exchange_view.accelerator, clear_tools=True)\n    system = Message.load(\"prompts/repo_context.jinja\").text\n    file_select_exchange = replace_prompt(exchange=file_select_exchange, prompt=system)\n    files = goose_picks_files(root=project_directory, exchange=file_select_exchange)\n\n    summary = summarize_files_concurrent(\n        exchange=self.exchange_view.accelerator, file_list=files, project_name=project_directory.split(\"/\")[-1]\n    )\n\n    return summary\n</code></pre>"},{"location":"reference/goose/toolkit/repo_context/utils.html","title":"Utils","text":""},{"location":"reference/goose/toolkit/repo_context/utils.html#goose.toolkit.repo_context.utils.get_files_and_directories","title":"<code>get_files_and_directories(root_dir)</code>","text":"<p>Gets file names and directory names. Checks that goose has correctly typed the file and directory names and that the files actually exist (to avoid downstream file read errors).</p> <p>Parameters:</p> Name Type Description Default <code>root_dir</code> <code>str</code> <p>Path to the directory to examine for files and sub-directories</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, list]</code> <p>A list of files and directories in the form {'files': [], 'directories: []}. Paths are all relative (i.e. ['src'] not ['goose/src'])</p> Source code in <code>src/goose/toolkit/repo_context/utils.py</code> <pre><code>def get_files_and_directories(root_dir: str) -&gt; Dict[str, list]:\n    \"\"\"Gets file names and directory names. Checks that goose has correctly typed the file and directory names and that\n    the files actually exist (to avoid downstream file read errors).\n\n    Args:\n        root_dir (str): Path to the directory to examine for files and sub-directories\n\n    Returns:\n        dict: A list of files and directories in the form {'files': [], 'directories: []}. Paths\n            are all relative (i.e. ['src'] not ['goose/src'])\n    \"\"\"\n    files = []\n    dirs = []\n\n    # check dir exists\n    try:\n        os.listdir(root_dir)\n    except FileNotFoundError:\n        # FIXME: fuzzy match might work here to recover directories 'lost' to goose mistyping\n        # hallucination: Goose mistyped the path (e.g. `metrichandler` vs `metricshandler`)\n        return {\"files\": files, \"directories\": dirs}\n\n    for entry in os.listdir(root_dir):\n        if entry.startswith(\".\") or entry.startswith(\"~\"):\n            continue  # Skip hidden files and directories\n\n        full_path = os.path.join(root_dir, entry)\n        if os.path.isdir(full_path):\n            dirs.append(entry)\n        elif os.path.isfile(full_path):\n            files.append(entry)\n\n    return {\"files\": files, \"directories\": dirs}\n</code></pre>"},{"location":"reference/goose/toolkit/repo_context/utils.html#goose.toolkit.repo_context.utils.get_repo_size","title":"<code>get_repo_size(repo_path)</code>","text":"<p>Returns repo size in MB</p> Source code in <code>src/goose/toolkit/repo_context/utils.py</code> <pre><code>def get_repo_size(repo_path: str) -&gt; int:\n    \"\"\"Returns repo size in MB\"\"\"\n    git_dir = os.path.join(repo_path, \".git\")\n    return get_directory_size(git_dir) / (1024**2)\n</code></pre>"},{"location":"reference/goose/toolkit/repo_context/utils.html#goose.toolkit.repo_context.utils.goose_picks_files","title":"<code>goose_picks_files(root, exchange, max_workers=4)</code>","text":"<p>Lets goose pick files in a BFS manner</p> Source code in <code>src/goose/toolkit/repo_context/utils.py</code> <pre><code>def goose_picks_files(root: str, exchange: Exchange, max_workers: int = 4) -&gt; List[str]:\n    \"\"\"Lets goose pick files in a BFS manner\"\"\"\n    queue = deque([root])\n\n    all_files = []\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:\n        while queue:\n            current_batch = [queue.popleft() for _ in range(min(max_workers, len(queue)))]\n            futures = {executor.submit(process_directory, dir, exchange): dir for dir in current_batch}\n\n            for future in concurrent.futures.as_completed(futures):\n                files, next_dirs = future.result()\n                all_files.extend(files)\n                queue.extend(next_dirs)\n\n    return all_files\n</code></pre>"},{"location":"reference/goose/toolkit/repo_context/utils.html#goose.toolkit.repo_context.utils.process_directory","title":"<code>process_directory(current_dir, exchange)</code>","text":"<p>Allows goose to pick files and subdirectories contained in a given directory (current_dir). Get the list of file and directory names in the current folder, then ask Goose to pick which ones to keep.</p> Source code in <code>src/goose/toolkit/repo_context/utils.py</code> <pre><code>def process_directory(current_dir: str, exchange: Exchange) -&gt; Tuple[List[str], List[str]]:\n    \"\"\"Allows goose to pick files and subdirectories contained in a given directory (current_dir). Get the list of file\n    and directory names in the current folder, then ask Goose to pick which ones to keep.\n\n    \"\"\"\n    files_and_dirs = get_files_and_directories(current_dir)\n    ai_response = ask_an_ai(str(files_and_dirs), exchange)\n\n    # FIXME: goose response validation\n    try:\n        as_dict = ast.literal_eval(ai_response.text)\n    except Exception:\n        # can happen if goose returns anything but {result: dict} (e.g. ```json\\n {results: dict} \\n```)\n        return [], []\n    if not isinstance(as_dict, dict):\n        # can happen if goose returns something like `{'files': ['x.py'] 'directories': ['dir1']}` (missing comma)\n        return [], []\n\n    files = [f\"{current_dir}/{file}\" for file in as_dict.get(\"files\", [])]\n    next_dirs = [f\"{current_dir}/{next_dir}\" for next_dir in as_dict.get(\"directories\", [])]\n\n    return files, next_dirs\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/index.html","title":"Index","text":""},{"location":"reference/goose/toolkit/summarization/summarize_file.html","title":"Summarize file","text":""},{"location":"reference/goose/toolkit/summarization/summarize_file.html#goose.toolkit.summarization.summarize_file.SummarizeFile","title":"<code>SummarizeFile</code>","text":"<p>               Bases: <code>Toolkit</code></p> Source code in <code>src/goose/toolkit/summarization/summarize_file.py</code> <pre><code>class SummarizeFile(Toolkit):\n    @tool\n    def summarize_file(self, filepath: str, prompt: Optional[str] = None) -&gt; str:\n        \"\"\"\n        Tool to summarize a specific file\n\n        Args:\n            filepath (str): Path to the file to summarize\n            prompt (str): Optional prompt giving the model instructions on how to summarize the file.\n                Under the hood this defaults to \"Please summarize this file\"\n\n        Returns:\n            summary (Optional[str]): Summary of the file contents\n\n        \"\"\"\n\n        exchange = self.exchange_view.accelerator\n\n        _, summary = summarize_file(filepath=filepath, exchange=exchange, prompt=prompt)\n\n        return summary\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/summarize_file.html#goose.toolkit.summarization.summarize_file.SummarizeFile.summarize_file","title":"<code>summarize_file(filepath, prompt=None)</code>","text":"<p>Tool to summarize a specific file</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the file to summarize</p> required <code>prompt</code> <code>str</code> <p>Optional prompt giving the model instructions on how to summarize the file. Under the hood this defaults to \"Please summarize this file\"</p> <code>None</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>Optional[str]</code> <p>Summary of the file contents</p> Source code in <code>src/goose/toolkit/summarization/summarize_file.py</code> <pre><code>@tool\ndef summarize_file(self, filepath: str, prompt: Optional[str] = None) -&gt; str:\n    \"\"\"\n    Tool to summarize a specific file\n\n    Args:\n        filepath (str): Path to the file to summarize\n        prompt (str): Optional prompt giving the model instructions on how to summarize the file.\n            Under the hood this defaults to \"Please summarize this file\"\n\n    Returns:\n        summary (Optional[str]): Summary of the file contents\n\n    \"\"\"\n\n    exchange = self.exchange_view.accelerator\n\n    _, summary = summarize_file(filepath=filepath, exchange=exchange, prompt=prompt)\n\n    return summary\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/summarize_project.html","title":"Summarize project","text":""},{"location":"reference/goose/toolkit/summarization/summarize_project.html#goose.toolkit.summarization.summarize_project.SummarizeProject","title":"<code>SummarizeProject</code>","text":"<p>               Bases: <code>Toolkit</code></p> Source code in <code>src/goose/toolkit/summarization/summarize_project.py</code> <pre><code>class SummarizeProject(Toolkit):\n    @tool\n    def get_project_summary(\n        self,\n        project_dir_path: Optional[str] = os.getcwd(),\n        extensions: Optional[List[str]] = None,\n        summary_instructions_prompt: Optional[str] = None,\n    ) -&gt; dict:\n        \"\"\"Generates or retrieves a project summary based on specified file extensions.\n\n        Args:\n            project_dir_path (Optional[Path]): Path to the project directory. Defaults to the current working directory\n                if None\n            extensions (Optional[List[str]]): Specific file extensions to summarize.\n            summary_instructions_prompt (Optional[str]): Instructions to give to the LLM about how to summarize each file. E.g.\n                \"Summarize the file in two sentences.\". The default instruction is \"Please summarize this file.\"\n\n        Returns:\n            summary (dict): Project summary.\n        \"\"\"  # noqa: E501\n\n        summary = summarize_directory(\n            project_dir_path,\n            exchange=self.exchange_view.accelerator,\n            extensions=extensions,\n            summary_instructions_prompt=summary_instructions_prompt,\n        )\n\n        return summary\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/summarize_project.html#goose.toolkit.summarization.summarize_project.SummarizeProject.get_project_summary","title":"<code>get_project_summary(project_dir_path=os.getcwd(), extensions=None, summary_instructions_prompt=None)</code>","text":"<p>Generates or retrieves a project summary based on specified file extensions.</p> <p>Parameters:</p> Name Type Description Default <code>project_dir_path</code> <code>Optional[Path]</code> <p>Path to the project directory. Defaults to the current working directory if None</p> <code>getcwd()</code> <code>extensions</code> <code>Optional[List[str]]</code> <p>Specific file extensions to summarize.</p> <code>None</code> <code>summary_instructions_prompt</code> <code>Optional[str]</code> <p>Instructions to give to the LLM about how to summarize each file. E.g. \"Summarize the file in two sentences.\". The default instruction is \"Please summarize this file.\"</p> <code>None</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>dict</code> <p>Project summary.</p> Source code in <code>src/goose/toolkit/summarization/summarize_project.py</code> <pre><code>@tool\ndef get_project_summary(\n    self,\n    project_dir_path: Optional[str] = os.getcwd(),\n    extensions: Optional[List[str]] = None,\n    summary_instructions_prompt: Optional[str] = None,\n) -&gt; dict:\n    \"\"\"Generates or retrieves a project summary based on specified file extensions.\n\n    Args:\n        project_dir_path (Optional[Path]): Path to the project directory. Defaults to the current working directory\n            if None\n        extensions (Optional[List[str]]): Specific file extensions to summarize.\n        summary_instructions_prompt (Optional[str]): Instructions to give to the LLM about how to summarize each file. E.g.\n            \"Summarize the file in two sentences.\". The default instruction is \"Please summarize this file.\"\n\n    Returns:\n        summary (dict): Project summary.\n    \"\"\"  # noqa: E501\n\n    summary = summarize_directory(\n        project_dir_path,\n        exchange=self.exchange_view.accelerator,\n        extensions=extensions,\n        summary_instructions_prompt=summary_instructions_prompt,\n    )\n\n    return summary\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/summarize_repo.html","title":"Summarize repo","text":""},{"location":"reference/goose/toolkit/summarization/summarize_repo.html#goose.toolkit.summarization.summarize_repo.SummarizeRepo","title":"<code>SummarizeRepo</code>","text":"<p>               Bases: <code>Toolkit</code></p> Source code in <code>src/goose/toolkit/summarization/summarize_repo.py</code> <pre><code>class SummarizeRepo(Toolkit):\n    @tool\n    def summarize_repo(\n        self,\n        repo_url: str,\n        specified_extensions: Optional[List[str]] = None,\n        summary_instructions_prompt: Optional[str] = None,\n    ) -&gt; dict:\n        \"\"\"\n        Retrieves a summary of a repository. Clones the repository if not already cloned and summarizes based on the\n        specified file extensions. If no extensions are specified, it summarizes the top `max_extensions` extensions.\n\n        Args:\n            repo_url (str): The URL of the repository to summarize.\n            specified_extensions (Optional[List[str]]): List of file extensions to summarize, e.g., [\"tf\", \"md\"]. If\n                this list is empty, then all files in the repo are summarized\n            summary_instructions_prompt (Optional[str]): Instructions to give to the LLM about how to summarize each file. E.g.\n                \"Summarize the file in two sentences.\". The default instruction is \"Please summarize this file.\"\n\n        Returns:\n            summary (dict): A summary of the repository where keys are the file extensions and values are their\n                summaries.\n        \"\"\"  # noqa: E501\n\n        return summarize_repo(\n            repo_url=repo_url,\n            exchange=self.exchange_view.accelerator,\n            extensions=specified_extensions,\n            summary_instructions_prompt=summary_instructions_prompt,\n        )\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/summarize_repo.html#goose.toolkit.summarization.summarize_repo.SummarizeRepo.summarize_repo","title":"<code>summarize_repo(repo_url, specified_extensions=None, summary_instructions_prompt=None)</code>","text":"<p>Retrieves a summary of a repository. Clones the repository if not already cloned and summarizes based on the specified file extensions. If no extensions are specified, it summarizes the top <code>max_extensions</code> extensions.</p> <p>Parameters:</p> Name Type Description Default <code>repo_url</code> <code>str</code> <p>The URL of the repository to summarize.</p> required <code>specified_extensions</code> <code>Optional[List[str]]</code> <p>List of file extensions to summarize, e.g., [\"tf\", \"md\"]. If this list is empty, then all files in the repo are summarized</p> <code>None</code> <code>summary_instructions_prompt</code> <code>Optional[str]</code> <p>Instructions to give to the LLM about how to summarize each file. E.g. \"Summarize the file in two sentences.\". The default instruction is \"Please summarize this file.\"</p> <code>None</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>dict</code> <p>A summary of the repository where keys are the file extensions and values are their summaries.</p> Source code in <code>src/goose/toolkit/summarization/summarize_repo.py</code> <pre><code>@tool\ndef summarize_repo(\n    self,\n    repo_url: str,\n    specified_extensions: Optional[List[str]] = None,\n    summary_instructions_prompt: Optional[str] = None,\n) -&gt; dict:\n    \"\"\"\n    Retrieves a summary of a repository. Clones the repository if not already cloned and summarizes based on the\n    specified file extensions. If no extensions are specified, it summarizes the top `max_extensions` extensions.\n\n    Args:\n        repo_url (str): The URL of the repository to summarize.\n        specified_extensions (Optional[List[str]]): List of file extensions to summarize, e.g., [\"tf\", \"md\"]. If\n            this list is empty, then all files in the repo are summarized\n        summary_instructions_prompt (Optional[str]): Instructions to give to the LLM about how to summarize each file. E.g.\n            \"Summarize the file in two sentences.\". The default instruction is \"Please summarize this file.\"\n\n    Returns:\n        summary (dict): A summary of the repository where keys are the file extensions and values are their\n            summaries.\n    \"\"\"  # noqa: E501\n\n    return summarize_repo(\n        repo_url=repo_url,\n        exchange=self.exchange_view.accelerator,\n        extensions=specified_extensions,\n        summary_instructions_prompt=summary_instructions_prompt,\n    )\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/utils.html","title":"Utils","text":""},{"location":"reference/goose/toolkit/summarization/utils.html#goose.toolkit.summarization.utils.load_summary_file_if_exists","title":"<code>load_summary_file_if_exists(project_name)</code>","text":"<p>Checks if a summary file exists at '.goose/summaries/projectname-summary.json. Returns contents of the file if it exists, otherwise returns None</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>name of the project or repo</p> required <p>Returns:</p> Type Description <code>Optional[Dict]</code> <p>Optional[Dict]: File contents, else None</p> Source code in <code>src/goose/toolkit/summarization/utils.py</code> <pre><code>def load_summary_file_if_exists(project_name: str) -&gt; Optional[Dict]:\n    \"\"\"Checks if a summary file exists at '.goose/summaries/projectname-summary.json. Returns contents of the file if\n    it exists, otherwise returns None\n\n    Args:\n        project_name (str): name of the project or repo\n\n    Returns:\n        Optional[Dict]: File contents, else None\n    \"\"\"\n    summary_file_path = f\"{SUMMARIES_FOLDER}/{project_name}-summary.json\"\n    if Path(summary_file_path).exists():\n        with open(summary_file_path, \"r\") as f:\n            return json.load(f)\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/utils.html#goose.toolkit.summarization.utils.summarize_directory","title":"<code>summarize_directory(directory, exchange, extensions, summary_instructions_prompt=None)</code>","text":"<p>Summarize files in a given directory based on extensions. Will also recursively find files in subdirectories and summarize them.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>path to the top-level directory to summarize</p> required <code>exchange</code> <code>Exchange</code> <p>Exchange to use to summarize</p> required <code>extensions</code> <code>List[str]</code> <p>List of file-type extensions to summarize (and ignore all other extensions).</p> required <code>summary_instructions_prompt</code> <code>Optional[str]</code> <p>Optional instructions to give to the exchange regarding summarization.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>file_summaries</code> <code>dict</code> <p>Keys are file names and values are summaries.</p> Source code in <code>src/goose/toolkit/summarization/utils.py</code> <pre><code>def summarize_directory(\n    directory: str, exchange: Exchange, extensions: List[str], summary_instructions_prompt: Optional[str] = None\n) -&gt; Dict[str, str]:\n    \"\"\"Summarize files in a given directory based on extensions. Will also recursively find files in subdirectories and\n    summarize them.\n\n    Args:\n        directory (str): path to the top-level directory to summarize\n        exchange (Exchange): Exchange to use to summarize\n        extensions (List[str]): List of file-type extensions to summarize (and ignore all other extensions).\n        summary_instructions_prompt (Optional[str]): Optional instructions to give to the exchange regarding summarization.\n\n    Returns:\n        file_summaries (dict): Keys are file names and values are summaries.\n\n    \"\"\"  # noqa: E501\n\n    # TODO: make sure that '.goose/summaries' is\n    # in the root of the current not relative to current dir or in cloned repo root\n    project_name = directory.split(\"/\")[-1]\n    summary_file = load_summary_file_if_exists(project_name)\n    if summary_file:\n        return summary_file\n\n    summary_file_path = f\"{SUMMARIES_FOLDER}/{project_name}-summary.json\"\n\n    # create the .goose/summaries folder if not already created\n    Path(SUMMARIES_FOLDER).mkdir(exist_ok=True, parents=True)\n\n    # select a subset of files to summarize based on file extension\n    files_to_summarize = create_file_list(directory, extensions=extensions)\n\n    file_summaries = summarize_files_concurrent(\n        exchange=exchange,\n        file_list=files_to_summarize,\n        project_name=project_name,\n        summary_instructions_prompt=summary_instructions_prompt,\n    )\n\n    summary_file_contents = {\"extensions\": extensions, \"summaries\": file_summaries}\n\n    # Write the summaries into a json\n    with open(summary_file_path, \"w\") as f:\n        json.dump(summary_file_contents, f, indent=2)\n\n    return file_summaries\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/utils.html#goose.toolkit.summarization.utils.summarize_file","title":"<code>summarize_file(filepath, exchange, prompt=None)</code>","text":"<p>Summarizes a single file</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the file to summarize.</p> required <code>exchange</code> <code>Exchange</code> <p>Exchange object to use for summarization.</p> required <code>prompt</code> <code>Optional[str]</code> <p>Defaults to \"Please summarize this file.\"</p> <code>None</code> Source code in <code>src/goose/toolkit/summarization/utils.py</code> <pre><code>def summarize_file(filepath: str, exchange: Exchange, prompt: Optional[str] = None) -&gt; Tuple[str, str]:\n    \"\"\"Summarizes a single file\n\n    Args:\n        filepath (str): Path to the file to summarize.\n        exchange (Exchange): Exchange object to use for summarization.\n        prompt (Optional[str]): Defaults to \"Please summarize this file.\"\n    \"\"\"\n    try:\n        with open(filepath, \"r\") as f:\n            file_text = f.read()\n    except Exception as e:\n        return filepath, f\"Error reading file {filepath}: {str(e)}\"\n\n    if not file_text:\n        return filepath, \"Empty file\"\n\n    try:\n        reply = ask_an_ai(\n            input=file_text, exchange=exchange, prompt=prompt if prompt else \"Please summarize this file.\"\n        )\n    except InitialMessageTooLargeError:\n        return filepath, \"File too large\"\n\n    return filepath, reply.text\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/utils.html#goose.toolkit.summarization.utils.summarize_files_concurrent","title":"<code>summarize_files_concurrent(exchange, file_list, project_name, summary_instructions_prompt=None)</code>","text":"<p>Takes in a list of files and summarizes them. Exchange does not keep history of the summarized files.</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>Exchange</code> <p>Underlying exchange</p> required <code>file_list</code> <code>List[str]</code> <p>List of paths to files to summarize</p> required <code>project_name</code> <code>str</code> <p>Used to save the summary of the files to .goose/summaries/-summary.json required <code>summary_instructions_prompt</code> <code>Optional[str]</code> <p>Summary instructions for the LLM. Defaults to \"Please summarize this file.\"</p> <code>None</code> <p>Returns:</p> Name Type Description <code>file_summaries</code> <code>Dict[str, str]</code> <p>Keys are file paths and values are the summaries returned by the Exchange</p> Source code in <code>src/goose/toolkit/summarization/utils.py</code> <pre><code>def summarize_files_concurrent(\n    exchange: Exchange, file_list: List[str], project_name: str, summary_instructions_prompt: Optional[str] = None\n) -&gt; Dict[str, str]:\n    \"\"\"Takes in a list of files and summarizes them. Exchange does not keep history of the summarized files.\n\n    Args:\n        exchange (Exchange): Underlying exchange\n        file_list (List[str]): List of paths to files to summarize\n        project_name (str): Used to save the summary of the files to .goose/summaries/&lt;project_name&gt;-summary.json\n        summary_instructions_prompt (Optional[str]): Summary instructions for the LLM. Defaults to \"Please summarize\n            this file.\"\n\n    Returns:\n        file_summaries (Dict[str, str]): Keys are file paths and values are the summaries returned by the Exchange\n    \"\"\"\n    summary_file = load_summary_file_if_exists(project_name)\n    if summary_file:\n        return summary_file\n\n    file_summaries = {}\n    # compile the individual file summaries into a single summary dict\n    # TODO: add progress bar as this step can take quite some time and it's nice to see something is happening\n    with ThreadPoolExecutor() as executor:\n        future_to_file = {\n            executor.submit(summarize_file, file, exchange, summary_instructions_prompt): file for file in file_list\n        }\n\n        for future in as_completed(future_to_file):\n            file_name, file_summary = future.result()\n            file_summaries[file_name] = file_summary\n\n    # create summaries folder if it doesn't exist\n    Path(SUMMARIES_FOLDER).mkdir(exist_ok=True, parents=True)\n    summary_file_path = f\"{SUMMARIES_FOLDER}/{project_name}-summary.json\"\n\n    # Write the summaries into a json\n    with open(summary_file_path, \"w\") as f:\n        json.dump(file_summaries, f, indent=2)\n\n    return file_summaries\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/utils.html#goose.toolkit.summarization.utils.summarize_repo","title":"<code>summarize_repo(repo_url, exchange, extensions, summary_instructions_prompt=None)</code>","text":"<p>Clones (if needed) and summarizes a repo</p> <p>Parameters:</p> Name Type Description Default <code>repo_url</code> <code>str</code> <p>Repository url</p> required <code>exchange</code> <code>Exchange</code> <p>Exchange for summarizing the repo.</p> required <code>extensions</code> <code>List[str]</code> <p>List of file-types to summarize.</p> required <code>summary_instructions_prompt</code> <code>Optional[str]</code> <p>Optional parameter to customize summarization results. Defaults to \"Please summarize this file\"</p> <code>None</code> Source code in <code>src/goose/toolkit/summarization/utils.py</code> <pre><code>def summarize_repo(\n    repo_url: str,\n    exchange: Exchange,\n    extensions: List[str],\n    summary_instructions_prompt: Optional[str] = None,\n) -&gt; Dict[str, str]:\n    \"\"\"Clones (if needed) and summarizes a repo\n\n    Args:\n        repo_url (str): Repository url\n        exchange (Exchange): Exchange for summarizing the repo.\n        extensions (List[str]): List of file-types to summarize.\n        summary_instructions_prompt (Optional[str]): Optional parameter to customize summarization results. Defaults to\n            \"Please summarize this file\"\n    \"\"\"\n    # set up the paths for the repository and the summary file\n    repo_name = repo_url.split(\"/\")[-1]\n    repo_dir = f\"{CLONED_REPOS_FOLDER}/{repo_name}\"  # e.g. '.goose/cloned_repos/&lt;project-name&gt;'\n\n    if Path(repo_dir).exists():\n        # TODO: re-add ability to log\n        return summarize_directory(\n            directory=repo_dir,\n            exchange=exchange,\n            extensions=extensions,\n            summary_instructions_prompt=summary_instructions_prompt,\n        )\n\n    clone_repo(repo_url, target_directory=repo_dir)\n\n    return summarize_directory(\n        directory=repo_dir,\n        exchange=exchange,\n        extensions=extensions,\n        summary_instructions_prompt=summary_instructions_prompt,\n    )\n</code></pre>"},{"location":"reference/goose/utils/index.html","title":"Index","text":""},{"location":"reference/goose/utils/index.html#goose.utils.ensure","title":"<code>ensure(cls)</code>","text":"<p>Convert dictionary to a class instance</p> Source code in <code>src/goose/utils/__init__.py</code> <pre><code>def ensure(cls: Type[T]) -&gt; Callable[[Any], T]:\n    \"\"\"Convert dictionary to a class instance\"\"\"\n\n    def converter(val: Any) -&gt; T:  # noqa: ANN401\n        if isinstance(val, cls):\n            return val\n        elif isinstance(val, dict):\n            return cls(**val)\n        elif isinstance(val, list):\n            return cls(*val)\n        else:\n            return cls(val)\n\n    return converter\n</code></pre>"},{"location":"reference/goose/utils/index.html#goose.utils.ensure_list","title":"<code>ensure_list(cls)</code>","text":"<p>Convert a list of dictionaries to class instances</p> Source code in <code>src/goose/utils/__init__.py</code> <pre><code>def ensure_list(cls: Type[T]) -&gt; Callable[[List[Dict[str, Any]]], Type[T]]:\n    \"\"\"Convert a list of dictionaries to class instances\"\"\"\n\n    def converter(val: List[Dict[str, Any]]) -&gt; List[T]:\n        output = []\n        for entry in val:\n            output.append(ensure(cls)(entry))\n        return output\n\n    return converter\n</code></pre>"},{"location":"reference/goose/utils/index.html#goose.utils.load_plugins","title":"<code>load_plugins(group)</code>","text":"<p>Load plugins based on a specified entry point group.</p> <p>This function iterates through all entry points registered under a specified group</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>The entry point group to load plugins from. This should match the group specified          in the package setup where plugins are defined.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary where each key is the entry point name, and the value is the loaded plugin object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Propagates exceptions raised by entry point loading, which might occur if a plugin        is not found or if there are issues with the plugin's code.</p> Source code in <code>src/goose/utils/__init__.py</code> <pre><code>def load_plugins(group: str) -&gt; dict:\n    \"\"\"\n    Load plugins based on a specified entry point group.\n\n    This function iterates through all entry points registered under a specified group\n\n    Args:\n        group (str): The entry point group to load plugins from. This should match the group specified\n                     in the package setup where plugins are defined.\n\n    Returns:\n        dict: A dictionary where each key is the entry point name, and the value is the loaded plugin object.\n\n    Raises:\n        Exception: Propagates exceptions raised by entry point loading, which might occur if a plugin\n                   is not found or if there are issues with the plugin's code.\n    \"\"\"\n    plugins = {}\n    # Access all entry points for the specified group and load each.\n    for entrypoint in entry_points(group=group):\n        plugin = entrypoint.load()  # Load the plugin.\n        plugins[entrypoint.name] = plugin  # Store the loaded plugin in the dictionary.\n    return plugins\n</code></pre>"},{"location":"reference/goose/utils/ask.html","title":"Ask","text":""},{"location":"reference/goose/utils/ask.html#goose.utils.ask.ask_an_ai","title":"<code>ask_an_ai(input, exchange, prompt='', no_history=True, with_tools=True)</code>","text":"<p>Sends a separate message to an LLM using a separate Exchange than the one underlying the Goose session.</p> <p>Can be used to summarize a file, or submit any other request that you'd like to an AI. The Exchange can have a history/prior context, or be wiped clean (by setting no_history to True).</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str</code> <p>The user's input string to be processed by the AI. Must be a non-empty string. Example: text from a file.</p> required <code>exchange</code> <code>Exchange</code> <p>An object representing the AI exchange system which manages the state and flow of the conversation.</p> required <code>prompt</code> <code>str</code> <p>An optional new prompt to replace the current one in the exchange system. Defaults to None. Example: \"Please summarize this file.\"</p> <code>''</code> <code>no_history</code> <code>bool</code> <p>A flag to determine if the conversation history should be cleared before processing the new input. True clears the context, False retains it. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>reply</code> <code>str</code> <p>The AI's reply as a string.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the <code>input</code> is not a non-empty string.</p> <code>Exception</code> <p>If there is an issue within the exchange system, including errors from the provider or model.</p> Example Source code in <code>src/goose/utils/ask.py</code> <pre><code>def ask_an_ai(\n    input: str,\n    exchange: Exchange,\n    prompt: str = \"\",\n    no_history: bool = True,\n    with_tools: bool = True,\n) -&gt; Message:\n    \"\"\"Sends a separate message to an LLM using a separate Exchange than the one underlying the Goose session.\n\n    Can be used to summarize a file, or submit any other request that you'd like to an AI. The Exchange can have a\n    history/prior context, or be wiped clean (by setting no_history to True).\n\n    Parameters:\n        input (str): The user's input string to be processed by the AI. Must be a non-empty string. Example: text from\n            a file.\n        exchange (Exchange): An object representing the AI exchange system which manages the state and flow of the\n            conversation.\n        prompt (str, optional): An optional new prompt to replace the current one in the exchange system. Defaults to\n            None. Example: \"Please summarize this file.\"\n        no_history (bool, optional): A flag to determine if the conversation history should be cleared before\n            processing the new input. True clears the context, False retains it. Defaults to True.\n\n    Returns:\n        reply (str): The AI's reply as a string.\n\n    Raises:\n        TypeError: If the `input` is not a non-empty string.\n        Exception: If there is an issue within the exchange system, including errors from the provider or model.\n\n    Example:\n        # Create an instance of an Exchange system\n        exchange_system = Exchange(provider=OpenAIProvider.from_env(), model=\"gpt-4\")\n\n        # Simulate asking the AI a question\n        response = ask_an_ai(\"What is the weather today?\", exchange_system)\n\n        print(response)  # Outputs the AI's response to the question.\n    \"\"\"\n    if no_history:\n        exchange = clear_exchange(exchange)\n\n    if not with_tools:\n        exchange = exchange.replace(tools=())\n\n    if prompt:\n        exchange = replace_prompt(exchange, prompt)\n\n    if not input:\n        raise TypeError(\"`input` must be a string of finite length\")\n\n    msg = Message.user(input)\n    exchange.add(msg)\n    reply = exchange.reply()\n\n    return reply\n</code></pre>"},{"location":"reference/goose/utils/ask.html#goose.utils.ask.ask_an_ai--create-an-instance-of-an-exchange-system","title":"Create an instance of an Exchange system","text":"<p>exchange_system = Exchange(provider=OpenAIProvider.from_env(), model=\"gpt-4\")</p>"},{"location":"reference/goose/utils/ask.html#goose.utils.ask.ask_an_ai--simulate-asking-the-ai-a-question","title":"Simulate asking the AI a question","text":"<p>response = ask_an_ai(\"What is the weather today?\", exchange_system)</p> <p>print(response)  # Outputs the AI's response to the question.</p>"},{"location":"reference/goose/utils/ask.html#goose.utils.ask.clear_exchange","title":"<code>clear_exchange(exchange, clear_tools=False)</code>","text":"<p>Clears the exchange object</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>Exchange</code> <p>Exchange object to be overwritten. Messages and checkpoints are replaced with empty lists.</p> required <code>clear_tools</code> <code>bool</code> <p>Boolean to indicate whether tools should be dropped from the exchange.</p> <code>False</code> <p>Returns:</p> Type Description <code>Exchange</code> <p>new_exchange (Exchange)</p> Source code in <code>src/goose/utils/ask.py</code> <pre><code>def clear_exchange(exchange: Exchange, clear_tools: bool = False) -&gt; Exchange:\n    \"\"\"Clears the exchange object\n\n    Args:\n        exchange (Exchange): Exchange object to be overwritten. Messages and checkpoints are replaced with empty lists.\n        clear_tools (bool): Boolean to indicate whether tools should be dropped from the exchange.\n\n    Returns:\n        new_exchange (Exchange)\n\n    \"\"\"\n    if clear_tools:\n        new_exchange = exchange.replace(messages=[], checkpoint_data=CheckpointData(), tools=())\n    else:\n        new_exchange = exchange.replace(messages=[], checkpoint_data=CheckpointData())\n    return new_exchange\n</code></pre>"},{"location":"reference/goose/utils/ask.html#goose.utils.ask.replace_prompt","title":"<code>replace_prompt(exchange, prompt)</code>","text":"<p>Replaces the system prompt</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>Exchange</code> <p>Exchange object to be overwritten. Messages and checkpoints are replaced with empty lists.</p> required <code>prompt</code> <code>str</code> <p>The system prompt.</p> required <p>Returns:</p> Type Description <code>Exchange</code> <p>new_exchange (Exchange)</p> Source code in <code>src/goose/utils/ask.py</code> <pre><code>def replace_prompt(exchange: Exchange, prompt: str) -&gt; Exchange:\n    \"\"\"Replaces the system prompt\n\n    Args:\n        exchange (Exchange): Exchange object to be overwritten. Messages and checkpoints are replaced with empty lists.\n        prompt (str): The system prompt.\n\n    Returns:\n        new_exchange (Exchange)\n    \"\"\"\n\n    new_exchange = exchange.replace(system=prompt)\n    return new_exchange\n</code></pre>"},{"location":"reference/goose/utils/check_shell_command.html","title":"Check shell command","text":""},{"location":"reference/goose/utils/check_shell_command.html#goose.utils.check_shell_command.is_dangerous_command","title":"<code>is_dangerous_command(command)</code>","text":"<p>Check if the command matches any dangerous patterns.</p> <p>Dangerous patterns in this function are defined as commands that may present risk to system stability.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The shell command to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the command is dangerous, False otherwise.</p> Source code in <code>src/goose/utils/check_shell_command.py</code> <pre><code>def is_dangerous_command(command: str) -&gt; bool:\n    \"\"\"\n    Check if the command matches any dangerous patterns.\n\n    Dangerous patterns in this function are defined as commands that may present risk to system stability.\n\n    Args:\n        command (str): The shell command to check.\n\n    Returns:\n        bool: True if the command is dangerous, False otherwise.\n    \"\"\"\n    dangerous_patterns = [\n        # Commands that are generally unsafe\n        r\"\\brm\\b\",  # rm command\n        r\"\\bgit\\s+push\\b\",  # git push command\n        r\"\\bsudo\\b\",  # sudo command\n        r\"\\bmv\\b\",  # mv command\n        r\"\\bchmod\\b\",  # chmod command\n        r\"\\bchown\\b\",  # chown command\n        r\"\\bmkfs\\b\",  # mkfs command\n        r\"\\bsystemctl\\b\",  # systemctl command\n        r\"\\breboot\\b\",  # reboot command\n        r\"\\bshutdown\\b\",  # shutdown command\n        # Target files that are unsafe\n        r\"\\b~\\/\\.|\\/\\.\\w+\",  # commands that point to files or dirs in home that start with a dot (dotfiles)\n    ]\n    for pattern in dangerous_patterns:\n        if re.search(pattern, command):\n            return True\n    return False\n</code></pre>"},{"location":"reference/goose/utils/diff.html","title":"Diff","text":""},{"location":"reference/goose/utils/diff.html#goose.utils.diff.diff","title":"<code>diff(a, b)</code>","text":"<p>Returns a string containing the unified diff of two strings.</p> Source code in <code>src/goose/utils/diff.py</code> <pre><code>def diff(a: str, b: str) -&gt; List[str]:\n    \"\"\"Returns a string containing the unified diff of two strings.\"\"\"\n\n    import difflib\n\n    a_lines = a.splitlines()\n    b_lines = b.splitlines()\n\n    # Create a Differ object\n    d = difflib.Differ()\n\n    # Generate the diff\n    diff = list(d.compare(a_lines, b_lines))\n\n    return diff\n</code></pre>"},{"location":"reference/goose/utils/diff.html#goose.utils.diff.pretty_diff","title":"<code>pretty_diff(a, b)</code>","text":"<p>Returns a pretty-printed diff of two strings.</p> Source code in <code>src/goose/utils/diff.py</code> <pre><code>def pretty_diff(a: str, b: str) -&gt; Text:\n    \"\"\"Returns a pretty-printed diff of two strings.\"\"\"\n\n    diff_lines = diff(a, b)\n    result = Text()\n    for line in diff_lines:\n        if line.startswith(\"+\"):\n            result.append(line, style=\"green\")\n        elif line.startswith(\"-\"):\n            result.append(line, style=\"red\")\n        elif line.startswith(\"?\"):\n            result.append(line, style=\"yellow\")\n        else:\n            result.append(line, style=\"dim grey\")\n        result.append(\"\\n\")\n\n    return result\n</code></pre>"},{"location":"reference/goose/utils/file_utils.html","title":"File utils","text":""},{"location":"reference/goose/utils/file_utils.html#goose.utils.file_utils.create_extensions_list","title":"<code>create_extensions_list(project_root, max_n)</code>","text":"<p>Get the top N file extensions in the current project Args:     project_root (str): Root of the project to analyze     max_n (int): The number of file extensions to return Returns:     extensions (List[str]): A list of the top N file extensions</p> Source code in <code>src/goose/utils/file_utils.py</code> <pre><code>def create_extensions_list(project_root: str, max_n: int) -&gt; list:\n    \"\"\"Get the top N file extensions in the current project\n    Args:\n        project_root (str): Root of the project to analyze\n        max_n (int): The number of file extensions to return\n    Returns:\n        extensions (List[str]): A list of the top N file extensions\n    \"\"\"\n    if max_n == 0:\n        raise (ValueError(\"Number of file extensions must be greater than 0\"))\n\n    files = create_file_list(project_root, [])\n\n    counter = Counter()\n\n    for file in files:\n        file_path = Path(file)\n        if file_path.suffix:  # omit ''\n            counter[file_path.suffix] += 1\n\n    top_n = counter.most_common(max_n)\n    extensions = [ext for ext, _ in top_n]\n\n    return extensions\n</code></pre>"},{"location":"reference/goose/utils/file_utils.html#goose.utils.file_utils.create_file_list","title":"<code>create_file_list(dir_path, extensions)</code>","text":"<p>Creates a list of files with certain extensions</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>str</code> <p>Directory to list files of. Will include files recursively in sub-directories.</p> required <code>extensions</code> <code>List[str]</code> <p>List of file extensions to select for. If empty list, return all files</p> required <p>Returns:</p> Name Type Description <code>final_file_list</code> <code>List[str]</code> <p>List of file paths with specified extensions.</p> Source code in <code>src/goose/utils/file_utils.py</code> <pre><code>def create_file_list(dir_path: str, extensions: List[str]) -&gt; List[str]:\n    \"\"\"Creates a list of files with certain extensions\n\n    Args:\n        dir_path (str): Directory to list files of. Will include files recursively in sub-directories.\n        extensions (List[str]): List of file extensions to select for. If empty list, return all files\n\n    Returns:\n        final_file_list (List[str]): List of file paths with specified extensions.\n    \"\"\"\n    # if extensions is empty list, return all files\n    if not extensions:\n        return glob.glob(f\"{dir_path}/**/*\", recursive=True)\n\n    # prune out files that do not end with any of the extensions in extensions\n    final_file_list = []\n    for ext in extensions:\n        if ext and not ext.startswith(\".\"):\n            ext = f\".{ext}\"\n\n        files = glob.glob(f\"{dir_path}/**/*{ext}\", recursive=True)\n        final_file_list += files\n\n    return final_file_list\n</code></pre>"},{"location":"reference/goose/utils/file_utils.html#goose.utils.file_utils.create_language_weighting","title":"<code>create_language_weighting(files_in_directory)</code>","text":"<p>Calculate language weighting by file size to match GitHub's methodology.</p> <p>Parameters:</p> Name Type Description Default <code>files_in_directory</code> <code>List[str]</code> <p>Paths to files in the project directory</p> required <p>Returns:</p> Type Description <code>Dict[str, float]</code> <p>Dict[str, float]: A dictionary with languages as keys and their percentage of the total codebase as values</p> Source code in <code>src/goose/utils/file_utils.py</code> <pre><code>def create_language_weighting(files_in_directory: List[str]) -&gt; Dict[str, float]:\n    \"\"\"Calculate language weighting by file size to match GitHub's methodology.\n\n    Args:\n        files_in_directory (List[str]): Paths to files in the project directory\n\n    Returns:\n        Dict[str, float]: A dictionary with languages as keys and their percentage of the total codebase as values\n    \"\"\"\n\n    # Initialize counters for sizes\n    size_by_language = Counter()\n\n    # Calculate size for files by language\n    for file_path in files_in_directory:\n        path = Path(file_path)\n        if path.suffix:\n            size_by_language[path.suffix] += os.path.getsize(file_path)\n\n    # Calculate total size and language percentages\n    total_size = sum(size_by_language.values())\n    language_percentages = {\n        lang: (size / total_size * 100) if total_size else 0 for lang, size in size_by_language.items()\n    }\n\n    return dict(sorted(language_percentages.items(), key=lambda item: item[1], reverse=True))\n</code></pre>"},{"location":"reference/goose/utils/file_utils.html#goose.utils.file_utils.list_files_with_extension","title":"<code>list_files_with_extension(dir_path, extension='')</code>","text":"<p>List all files in a directory with a given extension. Set extension to '' to return all files.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>str</code> <p>The path to the directory</p> required <code>extension</code> <code>Optional[str]</code> <p>extension to lookup. Defaults to '' which will return all files.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>files</code> <code>List[str]</code> <p>List of file paths</p> Source code in <code>src/goose/utils/file_utils.py</code> <pre><code>def list_files_with_extension(dir_path: str, extension: Optional[str] = \"\") -&gt; List[str]:\n    \"\"\"List all files in a directory with a given extension. Set extension to '' to return all files.\n\n    Args:\n        dir_path (str): The path to the directory\n        extension (Optional[str]): extension to lookup. Defaults to '' which will return all files.\n\n    Returns:\n        files (List[str]): List of file paths\n    \"\"\"\n    # add a leading '.' to extension if needed\n    if extension and not extension.startswith(\".\"):\n        extension = f\".{extension}\"\n\n    files = glob.glob(f\"{dir_path}/**/*{extension}\", recursive=True)\n    return files\n</code></pre>"},{"location":"reference/goose/utils/session_file.html","title":"Session file","text":""}]}