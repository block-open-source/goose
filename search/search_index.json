{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"Goose is your on-machine developer agent, automating engineering tasks seamlessly within your IDE or terminal  <p>   Generated by Goose from its VincentVanCode toolkit. </p> <p> </p> <p> Unique features \ud83e\udd16 \u2022  Block Employees on Goose  \u2022 Quick start guide \ud83d\ude80 \u2022 Getting involved! \ud83d\udc4b </p> <p>Tip</p> <p>Quick install: <pre><code>pipx install goose-ai\n</code></pre></p> <p>Goose is a developer agent that supercharges your software development by automating an array of coding tasks directly within your terminal or IDE. Guided by you, it can intelligently assess your project's needs, generate the required code or modifications, and implement these changes on its own. Goose can interact with a multitude of tools via external APIs such as Jira, GitHub, Slack, infrastructure and data pipelines, and more -- if your task uses a shell command or can be carried out by a Python script, Goose can do it for you too! Like semi-autonomous driving, Goose handles the heavy lifting, allowing you to focus on other priorities. Simply set it on a task and return later to find it completed, boosting your productivity with less manual effort.</p>"},{"location":"index.html#unique-features-of-goose-compared-to-other-ai-assistants","title":"Unique features of Goose compared to other AI assistants","text":"<ul> <li> <p>Autonomy: A copilot should be able to also fly the plane at times, which in the development world means running code, debugging tests, installing dependencies, not just providing text output and autocomplete or search. Goose moves beyond just generating code snippets by (1) using the shell and (2) by seeing what happens with the code it writes and starting a feedback loop to solve harder problems, refining solutions iteratively like a human developer. Your code's best wingman.</p> </li> <li> <p>Extensibility: Open-source and fully customizable, Goose integrates with your workflow and allows you to extend it for even more control. Toolkits let you add new capabilities to Goose. They are anything you can implement as a Python function (e.g. API requests, deployments, search, etc). We have a growing library of toolkits to use, but more importantly you can create your own. This gives Goose the ability to run these commands and decide if and when a tool is needed to complete your request! Creating your own toolkits give you a way to bring your own private context into Goose's capabilities.  And you can use any LLM you want under the hood, as long as it supports tool use.</p> </li> </ul>"},{"location":"index.html#what-block-employees-have-to-say-about-goose","title":"What Block employees have to say about Goose","text":"<p>With Goose, I feel like I am Maverick.</p> <p>Thanks a ton for creating this. \ud83d\ude4f I have been having way too much fun with it today.</p> <p>-- P, Machine Learning Engineer</p> <p>I wanted to construct some fake data for an API with a large request body and business rules I haven't memorized. So I told Goose which object to update and a test to run that calls the vendor. Got it to use the errors descriptions from the vendor response to keep correcting the request until it was successful. So good!</p> <p>-- J, Software Engineer</p> <p>I asked Goose to write up a few Google Scripts that mimic Clockwise's functionality (particularly, creating blocks on my work calendar based on events in my personal calendar, as well as color-coding calendar entries based on type and importance). Took me under an hour. If you haven't tried Goose yet, I highly encourage you to do so!</p> <p>-- M, Software Engineer</p> <p>If anyone was looking for another reason to check it out: I just asked Goose to break a string-array into individual string resources across eleven localizations, and it performed amazingly well and saved me a bunch of time doing it manually or figuring out some way to semi-automate it. </p> <p>-- A, Android Engineer</p> <p>Hi team, thank you for much for making Goose, it's so amazing. Our team is working on migrating Dashboard components to React components. I am working with Goose to help the migration.</p> <p>-- K, Software Engineer</p> <p>Got Goose to update a dependency, run tests, make a branch and a commit... it was \ud83e\udd0c. Not that complicated but I was impressed it figured out how to run tests from the README.</p> <p>--  J, Software Engineer</p> <p>Wanted to document what I had Goose do -- took about 30 minutes end to end! I created a custom CLI command in the <code>gh CLI</code> library to download in-line comments on PRs about code changes (currently they aren't directly viewable). I don't know Go that well and I definitely didn't know where to start looking in the code base or how to even test the new command was working and Goose did it all for me \ud83d\ude01</p> <p>-- L, Software Engineer</p> <p>Hi Team, just wanted to share my experience of using Goose as a non-engineer! ... I just asked Goose to ensure that my environment is up to date and copied over a guide into my prompt. Goose managed everything flawlessly, keeping me informed at every step... I was truly impressed with how well it works and how easy it was to get started! \ud83d\ude0d</p> <p>-- M, Product Manager</p> <p>See more of our use-cases in our docs!</p>"},{"location":"index.html#quick-start-guide","title":"Quick start guide","text":""},{"location":"index.html#installation","title":"Installation","text":"<p>To install Goose, use <code>pipx</code>. First ensure pipx is installed:</p> <p><pre><code>brew install pipx\npipx ensurepath\n</code></pre> You can also place <code>.goosehints</code> in <code>~/.config/goose/.goosehints</code> if you like for always loaded hints personal to you. </p> <p>Then install Goose:</p> <pre><code>pipx install goose-ai\n</code></pre>"},{"location":"index.html#running-goose","title":"Running Goose","text":""},{"location":"index.html#start-a-session","title":"Start a session","text":"<p>From your terminal, navigate to the directory you'd like to start from and run:</p> <pre><code>goose session start\n</code></pre> <p>You will see the Goose prompt <code>G\u276f</code>:</p> <pre><code>G\u276f type your instructions here exactly as you would tell a developer.\n</code></pre> <p>Now you are interacting with Goose in conversational sessions - something like a natural language driven code interpreter. The default toolkit allows Goose to take actions through shell commands and file edits. You can interrupt Goose with <code>CTRL+D</code> or <code>ESC+Enter</code> at any time to help redirect its efforts.</p>"},{"location":"index.html#exit-the-session","title":"Exit the session","text":"<p>If you are looking to exit, use <code>CTRL+D</code>, although Goose should help you figure that out if you forget. </p>"},{"location":"index.html#resume-a-session","title":"Resume a session","text":"<p>When you exit a session, it will save the history in <code>~/.config/goose/sessions</code> directory and you can resume it later on:</p> <pre><code>goose session resume\n</code></pre> <p>To see more documentation on the CLI commands currently available to Goose check out the documentation here. If you\u2019d like to develop your own CLI commands for Goose, check out the Contributing document.</p>"},{"location":"index.html#next-steps","title":"Next steps","text":"<p>Learn how to modify your Goose profiles.yaml file to add and remove functionality (toolkits) and providing context to get the most out of Goose in our Getting Started Guide.</p> <p>Want to move out of the terminal and into an IDE? </p> <p>We have some experimental IDE integrations for VSCode and JetBrains IDEs:  * https://github.com/square/goose-vscode  * https://github.com/Kvadratni/goose-intellij</p>"},{"location":"index.html#getting-involved","title":"Getting involved!","text":"<p>There is a lot to do! If you're interested in contributing, a great place to start is picking a <code>good-first-issue</code>-labelled ticket from our issues list. More details on how to develop Goose can be found in our Contributing Guide. We are a friendly, collaborative group and look forward to working together!<sup>1</sup></p> <p>Check out and contribute to more experimental features in Goose Plugins!</p> <p>Let us know what you think in our Discussions or the <code>#goose</code> channel on Discord.</p> <ol> <li> <p>Yes, Goose is open source and always will be. Goose is released under the ASL2.0 license meaning you are free to use it however you like.  See LICENSE.md for more details.\u00a0\u21a9</p> </li> </ol>"},{"location":"configuration.html","title":"Configuring Goose","text":""},{"location":"configuration.html#profiles","title":"Profiles","text":"<p>If you need to customize goose, one way is via editing: <code>~/.config/goose/profiles.yaml</code>.</p> <p>It will look by default something like (and when you run <code>goose session start</code> without the <code>--profile</code> flag it will use the <code>default</code> profile):</p> <pre><code>default:\n  provider: open-ai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: passive\n  toolkits:\n    - name: developer\n      requires: {}\n</code></pre>"},{"location":"configuration.html#fields","title":"Fields","text":""},{"location":"configuration.html#provider","title":"provider","text":"<p>Provider of LLM. LLM providers that currently are supported by Goose:</p> Provider Required environment variable(s) to access provider openai <code>OPENAI_API_KEY</code> anthropic <code>ANTHROPIC_API_KEY</code> databricks <code>DATABRICKS_HOST</code> and <code>DATABRICKS_TOKEN</code>"},{"location":"configuration.html#processor","title":"processor","text":"<p>This is the model used for the main Goose loop and main tools -- it should be be capable of complex, multi-step tasks such as writing code and executing commands. Example: <code>gpt-4o</code>. You should choose the model based the provider you configured.</p>"},{"location":"configuration.html#accelerator","title":"accelerator","text":"<p>Small model for fast, lightweight tasks. Example: <code>gpt-4o-mini</code>. You should choose the model based the provider you configured.</p>"},{"location":"configuration.html#moderator","title":"moderator","text":"<p>Rules designed to control or manage the output of the model. Moderators that currently are supported by Goose:</p> <ul> <li><code>passive</code>: does not actively intervene in every response</li> <li><code>truncate</code>: truncates the first contexts when the contexts exceed the max token size</li> </ul>"},{"location":"configuration.html#example-profilesyaml-files","title":"Example <code>profiles.yaml</code> files","text":""},{"location":"configuration.html#provider-as-anthropic","title":"provider as <code>anthropic</code>","text":"<pre><code>default:\n  provider: anthropic\n  processor: claude-3-5-sonnet-20240620\n  accelerator: claude-3-5-sonnet-20240620\n</code></pre>"},{"location":"configuration.html#provider-as-databricks","title":"provider as <code>databricks</code>","text":"<pre><code>default:\n  provider: databricks\n  processor: databricks-meta-llama-3-1-70b-instruct\n  accelerator: databricks-meta-llama-3-1-70b-instruct\n  moderator: passive\n  toolkits:\n    - name: developer\n      requires: {}\n</code></pre> <p>You can tell it to use another provider for example for Anthropic:</p> <pre><code>default:\n  provider: anthropic\n  processor: claude-3-5-sonnet-20240620\n  accelerator: claude-3-5-sonnet-20240620\n  moderator: passive\n  toolkits:\n    - name: developer\n      requires: {}\n</code></pre> <p>this will then use the claude-sonnet model, you will need to set the <code>ANTHROPIC_API_KEY</code> to your anthropic API key.</p> <p>You can also customize Goose's behavior through toolkits. These are set up automatically for you in the same <code>~/.config/goose/profiles.yaml</code> file, but you can include or remove toolkits as you see fit.</p> <p>For example, Goose's <code>unit-test-gen</code> command sets up a new profile in this file for you:</p> <pre><code>unit-test-gen:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: passive\n  toolkits:\n    - name: developer\n      requires: {}\n    - name: unit-test-gen\n      requires: {}\n    - name: java\n      requires: {}\n</code></pre>"},{"location":"configuration.html#adding-a-toolkit","title":"Adding a toolkit","text":"<p>To make a toolkit available to Goose, add it to your project's pyproject.toml. For example in the Goose pyproject.toml file: <pre><code>[project.entry-points.\"goose.toolkit\"]\ndeveloper = \"goose.toolkit.developer:Developer\"\ngithub = \"goose.toolkit.github:Github\"\n# Add a line like this - the key becomes the name used in profiles\nmy-new-toolkit = \"goose.toolkit.my_toolkits:MyNewToolkit\"  # this is the path to the class that implements the toolkit\n</code></pre></p> <p>Then to set up a profile that uses it, add something to <code>~/.config/goose/profiles.yaml</code>: <pre><code>my-profile:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: passive\n  toolkits:  # new toolkit gets added here\n    - developer\n    - my-new-toolkit\n</code></pre></p> <p>And now you can run Goose with this new profile to use the new toolkit!</p> <pre><code>goose session start --profile my-profile\n</code></pre> <p>Or, if you're developing a new toolkit and want to test it: <pre><code>uv run goose session start --profile my-profile\n</code></pre></p>"},{"location":"configuration.html#tuning-goose-to-your-repo","title":"Tuning Goose to your repo","text":"<p>Goose ships with the ability to read in the contents of a file named <code>.goosehints</code> from your repo. If you find yourself repeating the same information across sessions to Goose, this file is the right place to add this information.</p> <p>This file will be read into the Goose system prompt if it is present in the current working directory.</p> <p>Note</p> <p><code>.goosehints</code> follows jinja templating rules in case you want to leverage templating to insert file contents or variables.</p>"},{"location":"contributing.html","title":"Contributing","text":"<p>We welcome Pull Requests for general contributions. If you have a larger new feature or any questions on how to develop a fix, we recommend you open an issue before starting.</p>"},{"location":"contributing.html#prerequisites","title":"Prerequisites","text":"<p>Goose uses uv for dependency management, and formats with ruff. Clone goose and make sure you have installed <code>uv</code> to get started. When you use <code>uv</code> below in your local goose directly, it will automatically setup the virtualenv and install dependencies.</p> <p>We provide a shortcut to standard commands using just in our <code>justfile</code>.</p>"},{"location":"contributing.html#development","title":"Development","text":"<p>Now that you have a local environment, you can make edits and run our tests!</p>"},{"location":"contributing.html#run-goose","title":"Run Goose","text":"<p>If you've made edits and want to try them out, use</p> <pre><code>uv run goose session start\n</code></pre> <p>or other <code>goose</code> commands.</p> <p>If you want to run your local changes but in another directory, you can use the path in the virtualenv created by uv:</p> <pre><code>alias goosedev=`uv run which goose`\n</code></pre> <p>You can then run <code>goosedev</code> from another dir and it will use your current changes.</p>"},{"location":"contributing.html#run-tests","title":"Run Tests","text":"<p>To run the test suite against your edges, use <code>pytest</code>:</p> <pre><code>uv run pytest tests -m \"not integration\"\n</code></pre> <p>or, as a shortcut,</p> <pre><code>just test\n</code></pre>"},{"location":"contributing.html#enable-traces-in-goose-with-locally-hosted-langfuse","title":"Enable traces in Goose with locally hosted Langfuse","text":"<p>Note</p> <p>This integration is experimental and we don't currently have integration tests for it.</p> <p>Developers can use locally hosted Langfuse tracing by applying the custom <code>observe_wrapper</code> decorator defined in <code>packages/exchange/src/langfuse_wrapper.py</code> to functions for automatic integration with Langfuse. </p> <ul> <li>Run <code>just langfuse-server</code> to start your local Langfuse server. It requires Docker.</li> <li>Go to http://localhost:3000 and log in with the default email/password output by the shell script (values can also be found in the <code>.env.langfuse.local</code> file).</li> <li>Run Goose with the --tracing flag enabled i.e., <code>goose session start --tracing</code></li> <li>View your traces at http://localhost:3000</li> </ul> <p>To extend tracing to additional functions, import <code>from exchange.langfuse_wrapper import observe_wrapper</code> and use the <code>observe_wrapper()</code> decorator on functions you wish to enable tracing for. <code>observe_wrapper</code> functions the same way as Langfuse's observe decorator. </p> <p>Read more about Langfuse's decorator-based tracing here.</p>"},{"location":"contributing.html#exchange","title":"Exchange","text":"<p>The lower level generation behind goose is powered by the <code>exchange</code> package, also in this repo.</p> <p>Thanks to <code>uv</code> workspaces, any changes you make to <code>exchange</code> will be reflected in using your local goose. To run tests for exchange, head to <code>packages/exchange</code> and run tests just like above</p> <pre><code>uv run pytest tests -m \"not integration\"\n</code></pre>"},{"location":"contributing.html#evaluations","title":"Evaluations","text":"<p>Given that so much of Goose involves interactions with LLMs, our unit tests only go so far to confirming things work as intended.</p> <p>We're currently developing a suite of evaluations, to make it easier to make improvements to Goose more confidently.</p> <p>In the meantime, we typically incubate any new additions that change the behavior of the Goose through opt-in plugins - <code>Toolkit</code>s, <code>Moderator</code>s, and <code>Provider</code>s. We welcome contributions of plugins that add new capabilities to goose. We recommend sending in several examples of the new capabilities in action with your pull request.</p> <p>Additions to the developer toolkit change the core performance, and so will need to be measured carefully.</p>"},{"location":"contributing.html#conventional-commits","title":"Conventional Commits","text":"<p>This project follows the Conventional Commits specification for PR titles. Conventional Commits make it easier to understand the history of a project and facilitate automation around versioning and changelog generation.</p>"},{"location":"contributing.html#release","title":"Release","text":"<p>In order to release a new version of goose, you need to do the following: 1. Update CHANGELOG.md. To get the commit messages since last release, run: <code>just release-notes</code> 2. Update version in <code>pyproject.toml</code> for <code>goose</code> and package dependencies such as <code>exchange</code> 3. Create a PR and merge it into main branch 4. Tag the HEAD commit in main branch. To do this, switch to main branch and run: <code>just tag-push</code> 5. Publish a new release from the Github Release UI</p>"},{"location":"installation.html","title":"Installation","text":"<p>To install Goose, use <code>pipx</code>.First ensure pipx is installed:</p> <pre><code>brew install pipx\npipx ensurepath\n</code></pre> <p>Then install Goose:</p> <pre><code>pipx install goose-ai\n</code></pre> <p>You can then run <code>goose</code> from the command line with <code>goose session start</code>.</p>"},{"location":"guidance/applications.html","title":"Applications of Goose","text":""},{"location":"guidance/applications.html#uses-of-goose-so-far","title":"Uses of Goose so Far","text":"<p>We've been using Goose to help us with a variety of tasks. Here are some examples:</p> <ul> <li>Conduct code migrations like:<ul> <li>Ember to React</li> <li>Ruby to Kotlin</li> <li>Prefect-1 to Prefect-2</li> </ul> </li> <li>Dive into a new project in an unfamiliar coding language</li> <li>Transition a code-base from field-based injection to constructor-based injection in a dependency injection framework</li> <li>Conduct performance benchmarks for a build command using a build automation tool</li> <li>Increasing code coverage above a specific threshold</li> <li>Scaffolding an API for data retention</li> <li>Creating Datadog monitors</li> <li>Removing or adding feature flags</li> </ul>"},{"location":"guidance/getting-started.html","title":"Your first run with Goose","text":"<p>This page contains two sections that will help you get started with Goose:</p> <ol> <li>Configuring Goose with the <code>profiles.yaml</code> file: how to set up Goose with the right LLMs and toolkits.</li> <li>Working with Goose: how to guide Goose through a task, and how to provide context for Goose to work with.</li> </ol>"},{"location":"guidance/getting-started.html#configuring-goose-with-the-profilesyaml-file","title":"Configuring Goose with the <code>profiles.yaml</code> file","text":"<p>On the first run, Goose will detect what LLMs are available from your environment, and generate a configuration file at <code>~/.config/goose/profiles.yaml</code>. You can edit those profiles to further configure goose.</p> <p>Here\u2019s what the default <code>profiles.yaml</code> could look like if Goose detects an OpenAI API key:</p> <pre><code>default:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: truncate\n  toolkits:\n    - name: developer\n      requires: {}\n</code></pre> <p>You can edit this configuration file to use different LLMs and toolkits in Goose. Check out the configuration docs to better understand the different fields of the <code>profiles.yaml</code> file! You can add new profiles with different settings to change how goose works from one section to the next - use <code>goose session start --profile {profile}</code> to select which to use.</p>"},{"location":"guidance/getting-started.html#llm-provider-access-setup","title":"LLM provider access setup","text":"<p>Goose works on top of LLMs.  You'll need to configure one before using it. By default, Goose uses <code>openai</code> as the LLM provider but you can customize it as needed. You need to set OPENAI_API_KEY as an environment variable if you would like to use <code>openai</code>.</p> <p>To learn more about providers and modes of access, check out the provider docs. <pre><code>export OPENAI_API_KEY=your_open_api_key\n</code></pre></p>"},{"location":"guidance/getting-started.html#working-with-goose","title":"Working with Goose","text":"<p>Goose works best with some amount of context or instructions for a given task. You can guide goose through gathering the context it needs by giving it instructions or asking it to explore with its tools. But to make this easier, context in Goose can be extended a few additional ways:</p> <ol> <li>User-directed input</li> <li>A <code>.goosehints</code> file</li> <li>Toolkits</li> <li>Plans</li> </ol>"},{"location":"guidance/getting-started.html#user-directed-input","title":"User-directed input","text":"<p>Directing Goose to read a specific file before requesting changes ensures that the file's contents are loaded into its operational context. Similarly, asking Goose to summarize the current project before initiating changes across multiple files provides a detailed overview of the project structure, including the locations of specific classes, functions, and other components.</p>"},{"location":"guidance/getting-started.html#goosehints","title":"<code>.goosehints</code>","text":"<p>If you are using the <code>developer</code> toolkit, <code>goose</code> adds the content from <code>.goosehints</code> file in the working directory to the system prompt. The hints file is meant to provide additional context about your project. The context can be user-specific or at the project level in which case, you can commit it to git. <code>.goosehints</code> file is Jinja templated so you could have something like this:</p> <pre><code>Here is an overview of how to contribute:\n&amp;#123;% include 'CONTRIBUTING.md' %&amp;#125;\n\nThe following justfile shows our common commands:\n&amp;#123;% include 'justfile' %&amp;#125;\n\nWrite all code comments in French\n</code></pre>"},{"location":"guidance/getting-started.html#toolkits","title":"Toolkits","text":"<p>Toolkits expand Goose\u2019s capabilities and tailor its functionality to specific development tasks. Toolkits provide Goose with additional contextual information and interactive abilities, allowing for a more comprehensive and efficient workflow.</p> <p>Here are some out-of-the-box examples:</p> <ul> <li><code>developer</code>: for general-purpose development capabilities, including plan management, shell execution, and file operations, with default shell strategies like using ripgrep.</li> <li><code>screen</code>: for letting goose take a look at your screen to help debug or work on designs (gives goose eyes)</li> <li><code>github</code>: for suggestions on how to use Github</li> <li><code>repo_context</code>: for summarizing and understanding a repository you are working in.</li> <li><code>jira</code>: for working with JIRA (issues, backlogs, tasks, bugs etc.)</li> </ul> <p>You can see the current toolkits available to Goose here. There's also a public plugins repository where toolkits are defined for Goose that has toolkits you can try out.</p>"},{"location":"guidance/getting-started.html#plans","title":"Plans","text":"<p>Goose creates plans for itself to execute to achieve its goals. In some cases, you may already have a plan in mind for Goose \u2014 this is where you can define your own <code>plan.md</code> file, and it will set the first message and also hard code Goose's initial plan.</p> <p>The plan.md file can be text in any format and uses <code>jinja</code> templating, and the last group of lines that start with \u201c-\u201d will be considered the plan.</p> <p>Here are some examples:</p>"},{"location":"guidance/getting-started.html#basic-example-plan","title":"Basic example plan","text":"<pre><code>Your goal is to refactor this fastapi application to use a sqlite database. Use `pytest -s -v -x` to run the tests when needed.\n\n- Use ripgrep to find the fastapi app and its tests in this directory\n- read the files you found\n- Add sqlalchemy and alembic as dependencies with poetry\n- Run alembic init to set up the basic configuration\n- Add sqlite dependency with Poetry\n- Create new module for database code and include sqlalchemy and alembic setup\n- Define an accounts table with SQLAlchemy\n- Implement CRUD operations for accounts table\n- Update main.py to integrate with SQLite database and use CRUD operation\n- Use alembic to create the table\n- Use conftest to set up a test database with a new DB URL\n- Run existing test suite and ensure all tests pass. Do not edit the test case behavior, instead use tests to find issues.\n</code></pre> <p>The starting plan is specified with the tasks. Each list entry is a different step in the plan. This is a pretty detailed set of tasks, but is really just a break-down of the conversation we had in the previous section.</p> <p>The kickoff message is what gets set as the first user message when goose starts running (with the plan). This message should contain the overall goal of the tasks and could also contain extra context you want to include for this problem. In our case, we are just mentioning the test command we want to use to run the tests.</p> <p>To run Goose with this plan:</p> <pre><code>goose session start --plan plan.md\n</code></pre>"},{"location":"guidance/getting-started.html#injecting-arguments-into-a-plan","title":"Injecting arguments into a plan","text":"<p>You can also inject arguments into your plan. <code>plan.md</code> files can be templated with <code>jinja</code> and can include variables that are passed in when you start the session.</p> <p>The kickoff message gives Goose directions to use poetry and a dependency, and then a plan is to open a file, run a test, and set up a repo:</p> <pre><code>Here is the python repo\n\n- use {{ dep }}\n- use poetry\n\nHere is the plan:\n\n- Open a file\n- Run a test\n- Set up {{ repo }}\n</code></pre> <p>To run Goose with this plan with the arguments <code>dep=pytest,repo=github</code>, you would run the following command:</p> <pre><code>goose session start --plan plan.md --args dep=pytest,repo=github\n</code></pre>"},{"location":"guidance/goose-in-action.html","title":"Goose in action","text":"<p>This page is frequently updated with the latest use-cases and applications of Goose!</p>"},{"location":"guidance/goose-in-action.html#goose-as-a-github-action","title":"Goose as a Github Action","text":"<p>What it does: </p> <p>An early version of a GitHub action that uses Goose to automatically address issues in your repository. It operates in the background to attempt fixes or enhancements based on issue descriptions.</p> <p>The action attempts to fix issues described in GitHub. It takes the issue's title and body as input and tries to resolve the issue programmatically.</p> <p>If the action successfully fixes the issue, it will automatically create a pull request with the fix. If it cannot confidently fix the issue, no pull request is created.</p> <p>Where you can find it: https://github.com/marketplace/actions/goose-ai-developer-agent</p> <p>How you can do something similar:</p> <ol> <li>Decide what specific task you want Goose to automate. This could be anything from auto-linting code, updating dependencies, auto-merging approved pull requests, or even automating responses to issue comments.</li> <li>In the <code>action.yml</code>, specify any inputs your action needs (like GitHub tokens, configuration files, specific command inputs) and outputs it may produce.</li> <li>Write the script (e.g., Python or JavaScript) that Goose will use to perform the tasks. This involves setting up the Goose environment, handling GitHub API requests, and processing the task-specific logic.</li> </ol>"},{"location":"guidance/tips.html","title":"Quick Tips","text":""},{"location":"guidance/tips.html#tips-for-working-with-goose","title":"Tips for working with Goose:","text":"<p>Here are some collected tips we have for working efficiently with Goose</p> <ul> <li>Goose can and will edit files. Use a git strategy to avoid losing anything - such as staging your personal edits and leaving Goose edits unstaged until reviewed. Or consider using individual commits which can be reverted.</li> <li>Goose can and will run commands. You can ask it to check with you first if you are concerned. It will check commands for safety as well.</li> <li>You can interrupt Goose with <code>CTRL+C</code> to correct it or give it more info.</li> <li>Goose works best when solving concrete problems - experiment with how far you need to break that problem down to get Goose to solve it. Be specific! E.g. it will likely fail to <code>\"create a banking app\"</code>, but probably does a good job if prompted with <code>\"create a Fastapi app with an endpoint for deposit and withdrawal and with account balances stored in mysql keyed by id\"</code></li> <li>If Goose doesn't have enough context to start with, it might go down the wrong direction. Tell it to read files that you are referring to or search for objects in code. Even better, ask it to summarize them for you, which will help it set up its own next steps.</li> <li>Refer to any objects in files with something that is easy to search for, such as `\"the MyExample class\"</li> <li>Goose loves to know how to run tests to get a feedback loop going, just like you do. If you tell it how you test things locally and quickly, it can make use of that when working on your project</li> <li>You can use Goose for tasks that would require scripting at times, even looking at your screen and correcting designs/helping you fix bugs, try asking it to help you in a way you would ask a person.</li> <li>Goose will make mistakes, and go in the wrong direction from times, feel free to correct it, or start again.</li> <li>You can tell Goose to run things for you continuously (and it will iterate, try, retry) but you can also tell it to check with you before doing things (and then later on tell it to go off on its own and do its best to solve).</li> <li>Goose can run anywhere, doesn't have to be in a repo, just ask it!</li> </ul>"},{"location":"plugins/available-toolkits.html","title":"Available Toolkits in Goose","text":"<p>Goose provides a variety of toolkits designed to help developers with different tasks. Here's an overview of each available toolkit and its functionalities:</p>"},{"location":"plugins/available-toolkits.html#1-developer-toolkit","title":"1. Developer Toolkit","text":"<p>The Developer toolkit offers general-purpose development capabilities, including:</p> <ul> <li>System Configuration Details: Retrieves system configuration details.</li> <li>Task Management: Update the plan by overwriting all current tasks.</li> <li>File Operations:</li> <li><code>patch_file</code>: Patch a file by replacing specific content.</li> <li><code>read_file</code>: Read the content of a specified file.</li> <li><code>write_file</code>: Write content to a specified file.</li> <li>Shell Command Execution: Execute shell commands with safety checks.</li> </ul>"},{"location":"plugins/available-toolkits.html#2-github-toolkit","title":"2. GitHub Toolkit","text":"<p>The GitHub toolkit provides detailed configuration and procedural guidelines for GitHub operations.</p>"},{"location":"plugins/available-toolkits.html#3-lint-toolkit","title":"3. Lint Toolkit","text":"<p>The Lint toolkit ensures that all toolkits have proper documentation. It performs the following checks:</p> <ul> <li>Toolkit must have a docstring.</li> <li>The first line of the docstring should contain more than 5 words and fewer than 12 words.</li> <li>The first letter of the docstring should be capitalized.</li> </ul>"},{"location":"plugins/available-toolkits.html#4-repocontext-toolkit","title":"4. RepoContext Toolkit","text":"<p>The RepoContext toolkit provides context about the current repository. It includes:</p> <ul> <li>Repository Size: Get the size of the repository.</li> <li>Monorepo Check: Determine if the repository is a monorepo.</li> <li>Project Summarization: Summarize the current project based on the repository or the current project directory.</li> </ul>"},{"location":"plugins/available-toolkits.html#5-screen-toolkit","title":"5. Screen Toolkit","text":"<p>The Screen toolkit assists users in taking screenshots for debugging or designing purposes. It provides:</p> <ul> <li>Take Screenshot: Capture a screenshot and provide the path to the screenshot file.</li> <li>System Instructions: Instructions on how to work with screenshots.</li> </ul>"},{"location":"plugins/available-toolkits.html#6-summarizerepo-toolkit","title":"6. SummarizeRepo Toolkit","text":"<p>The SummarizeRepo toolkit helps in summarizing a repository. It includes:</p> <ul> <li>Summarize Repository: Clone the repository (if not already cloned) and summarize the files based on specified extensions.</li> </ul>"},{"location":"plugins/available-toolkits.html#7-summarizeproject-toolkit","title":"7. SummarizeProject Toolkit","text":"<p>The SummarizeProject toolkit generates or retrieves a summary of a project directory based on specified file extensions. It includes:</p> <ul> <li>Get Project Summary: Generate or retrieve a summary of the project in the specified directory.</li> </ul>"},{"location":"plugins/available-toolkits.html#8-summarizefile-toolkit","title":"8. SummarizeFile Toolkit","text":"<p>The SummarizeFile toolkit helps in summarizing a specific file. It includes:</p> <ul> <li>Summarize File: Summarize the contents of a specified file with optional instructions.</li> </ul>"},{"location":"plugins/cli.html","title":"Goose CLI Commands","text":"<p>Goose provides a command-line interface (CLI) with various commands to manage sessions, toolkits, and more. Below is a list of the available commands and their descriptions:</p>"},{"location":"plugins/cli.html#goose-cli","title":"Goose CLI","text":""},{"location":"plugins/cli.html#version","title":"<code>version</code>","text":"<p>Usage: <pre><code>  goose version\n</code></pre></p> <p>Lists the version of Goose and any associated plugins.</p>"},{"location":"plugins/cli.html#session","title":"<code>session</code>","text":""},{"location":"plugins/cli.html#start","title":"<code>start</code>","text":"<p>Usage: <pre><code>  goose session start [--profile PROFILE] [--plan PLAN] [--log-level [DEBUG|INFO|WARNING|ERROR|CRITICAL]] [--tracing]\n</code></pre></p> <p>Starts a new Goose session.</p> <p>If you want to enable locally hosted Langfuse tracing, pass the --tracing flag after starting your local Langfuse server as outlined in the Contributing Guide's Development guidelines.</p>"},{"location":"plugins/cli.html#resume","title":"<code>resume</code>","text":"<p>Usage: <pre><code>  goose session resume [NAME] [--profile PROFILE]\n</code></pre></p> <p>Resumes an existing Goose session.</p>"},{"location":"plugins/cli.html#list","title":"<code>list</code>","text":"<p>Usage: <pre><code>  goose session list\n</code></pre></p> <p>Lists all Goose sessions.</p>"},{"location":"plugins/cli.html#clear","title":"<code>clear</code>","text":"<p>Usage: <pre><code>  goose session clear [--keep KEEP]\n</code></pre></p> <p>Deletes old Goose sessions, keeping the most recent ones as specified by the <code>--keep</code> option.</p>"},{"location":"plugins/cli.html#toolkit","title":"<code>toolkit</code>","text":""},{"location":"plugins/cli.html#list_1","title":"<code>list</code>","text":"<p>Usage: <pre><code>  goose toolkit list\n</code></pre></p> <p>Lists all available toolkits with their descriptions.</p>"},{"location":"plugins/creating-a-new-toolkit.html","title":"Creating a New Toolkit","text":"<p>To add a toolkit, in your code (which doesn't necessarily need to be in the Goose package thanks to plugin metadata!), create a class that derives from the <code>Toolkit</code> class.</p>"},{"location":"plugins/creating-a-new-toolkit.html#example-toolkit-class","title":"Example toolkit class","text":"<p>Below is an example of a simple toolkit called <code>Demo</code> that derives from the <code>Toolkit</code> class. This toolkit provides an <code>authenticate</code> tool that outputs an authentication code for a user. It also provides system instructions for the model.  <pre><code>import os\nimport platform\n\nfrom goose.toolkit.base import Toolkit, tool\n\n\nclass Demo(Toolkit):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    # Provide any additional tools as needed!\n    # The docstring of the tool provides instructions to the LLM, so they are important to tune\n    # you do not have to provide any tools, but any function decorated with @tool will be available\n    @tool\n    def authenticate(self, user: str):\n        \"\"\"Output an authentication code for this user\n\n        Args:\n            user (str): The username to authenticate for\n        \"\"\"\n        # notifier supports any rich renderable https://rich.readthedocs.io/en/stable/introduction.html#quick-start\n        self.notifier.log(f\"[bold red]auth: {str(hash(user))}[/]\")\n\n    # Provide any system instructions for the model\n    # This can be generated dynamically, and is run at startup time\n    def system(self) -&gt; str:\n        print(\"new\")\n        return f\"\"\"**You must preceed your first message by using the authenticate tool for the current user**\n\n        ```\n        platform: {platform.system()}\n        cwd: {os.getcwd()}\n        user: {os.environ.get('USER')}\n        ```\n        \"\"\"\n</code></pre></p>"},{"location":"plugins/creating-a-new-toolkit.html#exposing-the-new-toolkit-to-goose","title":"Exposing the New Toolkit to Goose","text":"<p>To make the toolkit available, add it to the <code>pyproject.toml</code> file and then update your <code>profiles.yaml</code> file.</p>"},{"location":"plugins/creating-a-new-toolkit.html#update-the-pyprojecttoml-file","title":"Update the <code>pyproject.toml</code> file","text":"<p>If you're adding the new toolkit to Goose or the Goose Plugins repo, simply find the <code>[project.entry-points.\"goose.toolkit\"]</code> section in <code>pyproject.toml</code> and add a line like this: <pre><code>[project.entry-points.\"goose.toolkit\"]\ndeveloper = \"goose.toolkit.developer:Developer\"\ngithub = \"goose.toolkit.github:Github\"\n# Add a line like this - the key becomes the name used in profiles\ndemo = \"goose.toolkit.demo:Demo\"\n</code></pre></p> <p>If you are adding the toolkit to a different package, see the docs for <code>goose-plugins</code> for more information on how to create a plugins repository that can be used by Goose.</p>"},{"location":"plugins/creating-a-new-toolkit.html#update-the-profilesyaml-file","title":"Update the <code>profiles.yaml</code> file","text":"<p>And then to set up a profile that uses it, add something to ~/.config/goose/profiles.yaml <pre><code>default:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: passive\n  toolkits:\n    - name: developer\n      requires: {}\ndemo-profile:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: passive\n  toolkits:\n    - developer\n    - demo\n</code></pre></p> <p>And now you can run goose with this new profile to use the new toolkit!</p> <pre><code>goose session start --profile demo-profile\n</code></pre> <p>Note</p> <p>If you're using a plugin from <code>goose-plugins</code>, make sure <code>goose-plugins</code> is installed in your environment. You can install it via pip: </p> <p><code>pipx install goose-ai --preinstall goose-plugins</code></p>"},{"location":"plugins/plugins.html","title":"Plugins in Goose","text":"<p>Goose's functionality is extended via plugins. These plugins fall into three main categories:</p> <ol> <li>Toolkits: <ul> <li>Provides Goose with tools (functions) it can call and optionally will load additional context into the system prompt (such as 'The Github CLI is called via <code>gh</code> and you should use it to run git commands'). </li> <li>Toolkits can do basically anything, from calling external APIs, to taking a screenshot of your screen, to summarizing your current project.</li> </ul> </li> <li>CLI commands: <ul> <li>Provides additional commands to the Goose CLI. </li> <li>These commands can be used to interact with the Goose system, such as listing available toolkits or summarizing a session.</li> </ul> </li> <li>Providers: <ul> <li>Provides Goose with access to external LLMs. </li> <li>For example, the OpenAI provider allows Goose to interact with the OpenAI API. </li> <li>Most providers for Goose are defined in the Exchange library.</li> </ul> </li> </ol>"},{"location":"plugins/providers.html","title":"Providers","text":"<p>Providers in Goose mean \"LLM providers\" that Goose can interact with. Providers are defined in the Exchange library for the most part, but you can define your own. </p> <p>Currently available providers:</p> <ul> <li>Anthropic</li> <li>Azure</li> <li>Bedrock</li> <li>Databricks</li> <li>Google</li> <li>Ollama</li> <li>OpenAI</li> </ul>"},{"location":"plugins/using-toolkits.html","title":"Using Toolkits","text":"<p>Use <code>goose toolkit list</code> to list the available toolkits.</p>"},{"location":"plugins/using-toolkits.html#toolkits-defined-in-goose","title":"Toolkits defined in Goose","text":"<p>Using Goose with toolkits is simple. You can add toolkits to your profile in the <code>profiles.yaml</code> file. Here's an example of how to add <code>my-toolkit</code> toolkit to your profile:</p> <pre><code>my-profile:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: passive\n  toolkits:\n    - my-toolkit\n</code></pre> <p>Then run Goose with the specified profile:</p> <pre><code>goose session start --profile my-profile\n</code></pre>"},{"location":"plugins/using-toolkits.html#toolkits-defined-in-goose-plugins","title":"Toolkits defined in Goose Plugins","text":"<ol> <li>First make sure that <code>goose-plugins</code> is intalled with Goose: <pre><code>pipx install goose-ai --preinstall goose-plugins\n</code></pre></li> <li>Update the <code>profiles.yaml</code> file to include the desired toolkit: <pre><code>my-profile:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: passive\n  toolkits:\n    - my-goose-plugins-toolkit\n</code></pre></li> </ol>"},{"location":"reference/index.html","title":"Reference Documentation","text":""},{"location":"reference/index.html#goose","title":"Goose","text":"<ul> <li>goose.build</li> <li>goose.notifier</li> <li>goose.profile</li> <li>goose.view</li> </ul>"},{"location":"reference/index.html#command","title":"Command","text":"<ul> <li>goose.command.base</li> <li>goose.command.file</li> </ul>"},{"location":"reference/index.html#cli","title":"CLI","text":"<ul> <li>goose.cli.config</li> <li>goose.cli.main</li> <li>goose.cli.prompt.create</li> <li>goose.cli.prompt.goose_prompt_session</li> <li>goose.cli.session</li> </ul>"},{"location":"reference/index.html#toolkits","title":"Toolkits","text":"<p>goose.toolkit.base - goose.toolkit.developer - goose.toolkit.github - goose.toolkit.repo_context.repo_context - goose.toolkit.repo_context.utils - goose.toolkit.screen - goose.toolkit.summarization.summarize_file - goose.toolkit.summarization.summarize_project - goose.toolkit.summarization.summarize_repo - goose.toolkit.summarization.utils - goose.toolkit.utils</p>"},{"location":"reference/index.html#utils","title":"Utils","text":"<ul> <li>goose.utils</li> <li>goose.utils.ask</li> <li>goose.utils.check_shell_command</li> <li>goose.utils.file_utils</li> <li>goose.utils.session_file</li> </ul>"},{"location":"reference/goose/index.html","title":"Index","text":""},{"location":"reference/goose/build.html","title":"Build","text":""},{"location":"reference/goose/build.html#goose.build.build_exchange","title":"<code>build_exchange(profile, notifier)</code>","text":"<p>Build an exchange configured through the profile</p> <p>This will setup any toolkits and use that to build the exchange's collection of tools.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Profile</code> <p>The profile specifying how to setup this exchange</p> required <code>notifier</code> <code>Notifier</code> <p>A notifier instance used by tools to send info</p> required Source code in <code>src/goose/build.py</code> <pre><code>def build_exchange(profile: Profile, notifier: Notifier) -&gt; Exchange:\n    \"\"\"Build an exchange configured through the profile\n\n    This will setup any toolkits and use that to build the exchange's collection\n    of tools.\n\n    Args:\n        profile (Profile): The profile specifying how to setup this exchange\n        notifier (Notifier): A notifier instance used by tools to send info\n    \"\"\"\n\n    provider = get_provider(profile.provider).from_env()\n\n    # Support instantating toolkits in *two* passes for now, no further nesting\n    concrete_toolkits = {}\n\n    # First instantiate all toolkits that are sub dependencies\n    for spec in profile.toolkits:\n        for required in spec.requires.values():\n            concrete_toolkits[required] = get_toolkit(required)(notifier=notifier, requires=Requirements(required))\n\n    # Now that we have the dependencies available, we can instantiate everything else\n    toolkits = []\n    for spec in profile.toolkits:\n        if spec.name in concrete_toolkits:\n            toolkits.append(concrete_toolkits[spec.name])\n            continue\n\n        requires = Requirements(\n            spec.name,\n            {key: concrete_toolkits[val] for key, val in spec.requires.items()},\n        )\n        toolkit = get_toolkit(spec.name)(notifier=notifier, requires=requires)\n        toolkits.append(toolkit)\n\n    # From the toolkits, we derive the exchange prompt and tools\n    system = \"\\n\\n\".join([Message.load(\"system.jinja\").text] + [toolkit.system() for toolkit in toolkits])\n    tools = tuple(chain(*(toolkit.tools() for toolkit in toolkits)))\n    exchange = Exchange(\n        provider=provider,\n        system=system,\n        tools=tools,\n        moderator=get_moderator(profile.moderator)(),\n        model=profile.processor,\n    )\n\n    # This is a bit awkward, but we have to set this after the fact because building\n    # the exchange requires having the toolkits\n    for toolkit in toolkits:\n        toolkit.exchange_view = ExchangeView(profile.processor, profile.accelerator, exchange)\n\n    return exchange\n</code></pre>"},{"location":"reference/goose/notifier.html","title":"Notifier","text":""},{"location":"reference/goose/notifier.html#goose.notifier.Notifier","title":"<code>Notifier</code>","text":"<p>               Bases: <code>ABC</code></p> <p>The interface for a notifier</p> <p>This is expected to be implemented concretely by the each UX</p> Source code in <code>src/goose/notifier.py</code> <pre><code>class Notifier(ABC):\n    \"\"\"The interface for a notifier\n\n    This is expected to be implemented concretely by the each UX\n    \"\"\"\n\n    @abstractmethod\n    def log(self, content: RenderableType) -&gt; None:\n        \"\"\"Append content to the main display\n\n        Args:\n            content (str): The content to render\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def status(self, status: Optional[str]) -&gt; None:\n        \"\"\"Log a status to ephemeral display\n\n        Args:\n            status (str): The status to display\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def start(self) -&gt; None:\n        \"\"\"Start the display for the notifier\"\"\"\n        pass\n\n    @abstractmethod\n    def stop(self) -&gt; None:\n        \"\"\"Stop the display for the notifier\"\"\"\n        pass\n</code></pre>"},{"location":"reference/goose/notifier.html#goose.notifier.Notifier.log","title":"<code>log(content)</code>  <code>abstractmethod</code>","text":"<p>Append content to the main display</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The content to render</p> required Source code in <code>src/goose/notifier.py</code> <pre><code>@abstractmethod\ndef log(self, content: RenderableType) -&gt; None:\n    \"\"\"Append content to the main display\n\n    Args:\n        content (str): The content to render\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/goose/notifier.html#goose.notifier.Notifier.start","title":"<code>start()</code>  <code>abstractmethod</code>","text":"<p>Start the display for the notifier</p> Source code in <code>src/goose/notifier.py</code> <pre><code>@abstractmethod\ndef start(self) -&gt; None:\n    \"\"\"Start the display for the notifier\"\"\"\n    pass\n</code></pre>"},{"location":"reference/goose/notifier.html#goose.notifier.Notifier.status","title":"<code>status(status)</code>  <code>abstractmethod</code>","text":"<p>Log a status to ephemeral display</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str</code> <p>The status to display</p> required Source code in <code>src/goose/notifier.py</code> <pre><code>@abstractmethod\ndef status(self, status: Optional[str]) -&gt; None:\n    \"\"\"Log a status to ephemeral display\n\n    Args:\n        status (str): The status to display\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/goose/notifier.html#goose.notifier.Notifier.stop","title":"<code>stop()</code>  <code>abstractmethod</code>","text":"<p>Stop the display for the notifier</p> Source code in <code>src/goose/notifier.py</code> <pre><code>@abstractmethod\ndef stop(self) -&gt; None:\n    \"\"\"Stop the display for the notifier\"\"\"\n    pass\n</code></pre>"},{"location":"reference/goose/profile.html","title":"Profile","text":""},{"location":"reference/goose/profile.html#goose.profile.Profile","title":"<code>Profile</code>","text":"<p>The configuration for a run of goose</p> Source code in <code>src/goose/profile.py</code> <pre><code>@define\nclass Profile:\n    \"\"\"The configuration for a run of goose\"\"\"\n\n    provider: str\n    processor: str\n    accelerator: str\n    moderator: str\n    toolkits: list[ToolkitSpec] = field(factory=list, converter=ensure_list(ToolkitSpec))\n\n    @toolkits.validator\n    def check_toolkit_requirements(self, _: type[\"ToolkitSpec\"], toolkits: list[ToolkitSpec]) -&gt; None:\n        # checks that the list of toolkits in the profile have their requirements\n        installed_toolkits = set([toolkit.name for toolkit in toolkits])\n\n        for toolkit in toolkits:\n            toolkit_name = toolkit.name\n            toolkit_requirements = toolkit.requires\n            for _, req in toolkit_requirements.items():\n                if req not in installed_toolkits:\n                    msg = f\"Toolkit {toolkit_name} requires {req} but it is not present\"\n                    raise ValueError(msg)\n\n    def to_dict(self) -&gt; dict[str, any]:\n        return asdict(self)\n\n    def profile_info(self) -&gt; str:\n        tookit_names = [toolkit.name for toolkit in self.toolkits]\n        return f\"provider:{self.provider}, processor:{self.processor} toolkits: {', '.join(tookit_names)}\"\n</code></pre>"},{"location":"reference/goose/profile.html#goose.profile.ToolkitSpec","title":"<code>ToolkitSpec</code>","text":"<p>Configuration for a Toolkit</p> Source code in <code>src/goose/profile.py</code> <pre><code>@define\nclass ToolkitSpec:\n    \"\"\"Configuration for a Toolkit\"\"\"\n\n    name: str\n    requires: Mapping[str, str] = field(factory=dict)\n</code></pre>"},{"location":"reference/goose/profile.html#goose.profile.default_profile","title":"<code>default_profile(provider, processor, accelerator, **kwargs)</code>","text":"<p>Get the default profile</p> Source code in <code>src/goose/profile.py</code> <pre><code>def default_profile(provider: str, processor: str, accelerator: str, **kwargs: dict[str, any]) -&gt; Profile:\n    \"\"\"Get the default profile\"\"\"\n\n    # TODO consider if the providers should have recommended models\n\n    return Profile(\n        provider=provider,\n        processor=processor,\n        accelerator=accelerator,\n        moderator=\"truncate\",\n        toolkits=[ToolkitSpec(\"developer\")],\n    )\n</code></pre>"},{"location":"reference/goose/view.html","title":"View","text":""},{"location":"reference/goose/view.html#goose.view.ExchangeView","title":"<code>ExchangeView</code>","text":"<p>A read-only view of the underlying Exchange</p> <p>Attributes:</p> Name Type Description <code>processor</code> <code>Exchange</code> <p>A copy of the exchange configured for high capabilities</p> <code>accelerator</code> <code>Exchange</code> <p>A copy of the exchange configured for high speed</p> Source code in <code>src/goose/view.py</code> <pre><code>@define\nclass ExchangeView:\n    \"\"\"A read-only view of the underlying Exchange\n\n\n    Attributes:\n        processor: A copy of the exchange configured for high capabilities\n        accelerator: A copy of the exchange configured for high speed\n\n    \"\"\"\n\n    _processor: str\n    _accelerator: str\n    _exchange: Exchange\n\n    @property\n    def processor(self) -&gt; Exchange:\n        return self._exchange.replace(model=self._processor)\n\n    @property\n    def accelerator(self) -&gt; Exchange:\n        return self._exchange.replace(model=self._accelerator)\n</code></pre>"},{"location":"reference/goose/cli/index.html","title":"Index","text":""},{"location":"reference/goose/cli/config.html","title":"Config","text":""},{"location":"reference/goose/cli/config.html#goose.cli.config.ensure_config","title":"<code>ensure_config(name)</code>","text":"<p>Ensure that the config exists and has the default section</p> Source code in <code>src/goose/cli/config.py</code> <pre><code>def ensure_config(name: Optional[str]) -&gt; tuple[str, Profile]:\n    \"\"\"Ensure that the config exists and has the default section\"\"\"\n    # TODO we should copy a templated default config in to better document\n    # but this is complicated a bit by autodetecting the provider\n    default_profile_name = \"default\"\n    name = name or default_profile_name\n    default_profiles_dict = default_profiles()\n    provider, processor, accelerator = default_model_configuration()\n    default_profile = default_profiles_dict.get(name, default_profiles_dict[default_profile_name])(\n        provider, processor, accelerator\n    )\n\n    if not PROFILES_CONFIG_PATH.exists():\n        print(\n            Panel(\n                f\"[yellow]No configuration present, we will create a profile '{name}'\"\n                + f\" at: [/]{str(PROFILES_CONFIG_PATH)}\\n\"\n                + \"You can add your own profile in this file to further configure goose!\"\n            )\n        )\n        write_config({name: default_profile})\n        return (name, default_profile)\n\n    profiles = read_config()\n    if name in profiles:\n        return (name, profiles[name])\n    print(Panel(f\"[yellow]Your configuration doesn't have a profile named '{name}', adding one now[/yellow]\"))\n    profiles.update({name: default_profile})\n    write_config(profiles)\n    return (name, default_profile)\n</code></pre>"},{"location":"reference/goose/cli/config.html#goose.cli.config.read_config","title":"<code>read_config()</code>","text":"<p>Return config from the configuration file and validates its contents</p> Source code in <code>src/goose/cli/config.py</code> <pre><code>def read_config() -&gt; dict[str, Profile]:\n    \"\"\"Return config from the configuration file and validates its contents\"\"\"\n\n    yaml = YAML()\n    with PROFILES_CONFIG_PATH.open(\"r\") as f:\n        data = yaml.load(f)\n\n    return {name: Profile(**profile) for name, profile in data.items()}\n</code></pre>"},{"location":"reference/goose/cli/config.html#goose.cli.config.write_config","title":"<code>write_config(profiles)</code>","text":"<p>Overwrite the config with the passed profiles</p> Source code in <code>src/goose/cli/config.py</code> <pre><code>def write_config(profiles: dict[str, Profile]) -&gt; None:\n    \"\"\"Overwrite the config with the passed profiles\"\"\"\n    PROFILES_CONFIG_PATH.parent.mkdir(parents=True, exist_ok=True)\n    converted = {name: profile.to_dict() for name, profile in profiles.items()}\n    yaml = YAML()\n    with PROFILES_CONFIG_PATH.open(\"w\") as f:\n        yaml.dump(converted, f)\n</code></pre>"},{"location":"reference/goose/cli/main.html","title":"Main","text":""},{"location":"reference/goose/cli/main.html#goose.cli.main.get_version","title":"<code>get_version()</code>","text":"<p>Lists the version of goose and any plugins</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@goose_cli.command(name=\"version\")\ndef get_version() -&gt; None:\n    \"\"\"Lists the version of goose and any plugins\"\"\"\n    from importlib.metadata import entry_points, version\n\n    print(f\"[green]Goose-ai[/green]: [bold][cyan]{version('goose-ai')}[/cyan][/bold]\")\n    print(\"[green]Plugins[/green]:\")\n    entry_points = entry_points(group=\"metadata.plugins\")\n    modules = set()\n\n    for ep in entry_points:\n        module_name = ep.name\n        modules.add(module_name)\n    modules.remove(\"goose-ai\")\n    for module in sorted(list(modules)):\n        # TODO: figure out how to get this to work for goose plugins block\n        # as the module name is set to block.goose.cli\n        # module_name = 'goose-plugins-block'\n        try:\n            module_version = version(module)\n            print(f\"  Module: [green]{module}[/green], Version: [bold][cyan]{module_version}[/cyan][/bold]\")\n        except Exception as e:\n            print(f\"  [red]Could not retrieve version for {module}: {e}[/red]\")\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.providers","title":"<code>providers()</code>","text":"<p>Manage providers</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@goose_cli.group()\ndef providers() -&gt; None:\n    \"\"\"Manage providers\"\"\"\n    pass\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.run","title":"<code>run(message_file, profile, log_level)</code>","text":"<p>Run a single-pass session with a message from a markdown input file</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@goose_cli.command(name=\"run\")\n@click.argument(\"message_file\", required=False, type=click.Path(exists=True))\n@click.option(\"--profile\")\n@click.option(\"--log-level\", type=LOG_CHOICE, default=\"INFO\")\ndef run(message_file: Optional[str], profile: str, log_level: str) -&gt; None:\n    \"\"\"Run a single-pass session with a message from a markdown input file\"\"\"\n    if message_file:\n        with open(message_file, \"r\") as f:\n            initial_message = f.read()\n    else:\n        initial_message = click.get_text_stream(\"stdin\").read()\n\n    session = Session(profile=profile, log_level=log_level)\n    session.single_pass(initial_message=initial_message)\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.session","title":"<code>session()</code>","text":"<p>Start or manage sessions</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@goose_cli.group()\ndef session() -&gt; None:\n    \"\"\"Start or manage sessions\"\"\"\n    pass\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.session_clear","title":"<code>session_clear(keep)</code>","text":"<p>Delete old goose sessions, keeping the most recent sessions up to the specified number</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@session.command(name=\"clear\")\n@click.option(\"--keep\", default=3, help=\"Keep this many entries, default 3\")\ndef session_clear(keep: int) -&gt; None:\n    \"\"\"Delete old goose sessions, keeping the most recent sessions up to the specified number\"\"\"\n    for i, (_, session_file) in enumerate(get_session_files().items()):\n        if i &gt;= keep:\n            session_file.unlink()\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.session_list","title":"<code>session_list()</code>","text":"<p>List goose sessions</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@session.command(name=\"list\")\ndef session_list() -&gt; None:\n    \"\"\"List goose sessions\"\"\"\n    session_files = get_session_files().items()\n    for session_name, session_file in session_files:\n        print(f\"{datetime.fromtimestamp(session_file.stat().st_mtime).strftime('%Y-%m-%d %H:%M:%S')}    {session_name}\")\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.session_resume","title":"<code>session_resume(name, profile, log_level)</code>","text":"<p>Resume an existing goose session</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@session.command(name=\"resume\")\n@click.argument(\"name\", required=False, shell_complete=autocomplete_session_files)\n@click.option(\"--profile\")\n@click.option(\"--log-level\", type=LOG_CHOICE, default=\"INFO\")\ndef session_resume(name: Optional[str], profile: str, log_level: str) -&gt; None:\n    \"\"\"Resume an existing goose session\"\"\"\n    session_files = get_session_files()\n    if name is None:\n        if session_files:\n            name = list(session_files.keys())[0]\n            print(f\"Resuming most recent session: {name} from {session_files[name]}\")\n        else:\n            print(\"No sessions found.\")\n            return\n    else:\n        if name in session_files:\n            print(f\"Resuming session: {name}\")\n        else:\n            print(f\"Creating new session: {name}\")\n    session = Session(name=name, profile=profile, log_level=log_level)\n    session.run(new_session=False)\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.session_start","title":"<code>session_start(name, profile, log_level, plan=None, tracing=False)</code>","text":"<p>Start a new goose session</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@session.command(name=\"start\")\n@click.argument(\"name\", required=False, shell_complete=autocomplete_session_files)\n@click.option(\"--profile\")\n@click.option(\"--plan\", type=click.Path(exists=True))\n@click.option(\"--log-level\", type=click.Choice([\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]), default=\"INFO\")\n@click.option(\"--tracing\", is_flag=True, required=False)\ndef session_start(\n    name: Optional[str], profile: str, log_level: str, plan: Optional[str] = None, tracing: bool = False\n) -&gt; None:\n    \"\"\"Start a new goose session\"\"\"\n    if plan:\n        yaml = YAML()\n        with open(plan, \"r\") as f:\n            _plan = yaml.load(f)\n    else:\n        _plan = None\n\n    try:\n        session = Session(name=name, profile=profile, plan=_plan, log_level=log_level, tracing=tracing)\n        session.run()\n    except RuntimeError as e:\n        print(f\"[red]Error: {e}\")\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.shell_completions","title":"<code>shell_completions(ctx, install, generate, shell)</code>","text":"<p>Generate or install shell completions for goose</p> <p>Parameters:</p> Name Type Description Default <code>shell</code> <code>str</code> <p>shell to install completions for</p> required <code>install</code> <code>bool</code> <p>installs completions if true, otherwise generates             completions</p> required Source code in <code>src/goose/cli/main.py</code> <pre><code>@goose_cli.command(name=\"shell-completions\", help=\"Manage shell completions for goose\")\n@click.option(\"--install\", is_flag=True, help=\"Install shell completions\")\n@click.option(\"--generate\", is_flag=True, help=\"Generate shell completions\")\n@click.argument(\n    \"shell\",\n    type=click.Choice(SUPPORTED_SHELLS),\n    default=get_current_shell(),\n)\n@click.pass_context\ndef shell_completions(ctx: click.Context, install: bool, generate: bool, shell: str) -&gt; None:\n    \"\"\"Generate or install shell completions for goose\n\n    Args:\n        shell (str): shell to install completions for\n        install (bool): installs completions if true, otherwise generates\n                        completions\n    \"\"\"\n    if not any([install, generate]):\n        print(\"[red]One of --install or --generate must be specified[/red]\\n\")\n        raise click.UsageError(ctx.get_help())\n\n    if sum([install, generate]) &gt; 1:\n        print(\"[red]Only one of --install or --generate can be specified[/red]\\n\")\n        raise click.UsageError(ctx.get_help())\n\n    setup_autocomplete(shell, install=install)\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.toolkit","title":"<code>toolkit()</code>","text":"<p>Manage toolkits</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@goose_cli.group()\ndef toolkit() -&gt; None:\n    \"\"\"Manage toolkits\"\"\"\n    pass\n</code></pre>"},{"location":"reference/goose/cli/session.html","title":"Session","text":""},{"location":"reference/goose/cli/session.html#goose.cli.session.Session","title":"<code>Session</code>","text":"<p>A session handler for managing interactions between a user and the Goose exchange</p> <p>This class encapsulates the entire user interaction cycle, from input prompt to response handling, including interruptions and error management.</p> Source code in <code>src/goose/cli/session.py</code> <pre><code>class Session:\n    \"\"\"A session handler for managing interactions between a user and the Goose exchange\n\n    This class encapsulates the entire user interaction cycle, from input prompt to response handling,\n    including interruptions and error management.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: Optional[str] = None,\n        profile: Optional[str] = None,\n        plan: Optional[dict] = None,\n        log_level: Optional[str] = \"INFO\",\n        tracing: bool = False,\n        **kwargs: dict[str, any],\n    ) -&gt; None:\n        if name is None:\n            self.name = droid()\n        else:\n            self.name = name\n        self.profile_name = profile\n        self.prompt_session = GoosePromptSession()\n        self.status_indicator = Status(\"\", spinner=\"dots\")\n        self.notifier = SessionNotifier(self.status_indicator)\n        if not tracing:\n            logging.getLogger(\"langfuse\").setLevel(logging.ERROR)\n        else:\n            langfuse_auth = auth_check()\n            if langfuse_auth:\n                print(\"Local Langfuse initialized. View your traces at http://localhost:3000\")\n            else:\n                raise RuntimeError(\n                    \"You passed --tracing, but a Langfuse object was not found in the current context. \"\n                    \"Please initialize the local Langfuse server and restart Goose.\"\n                )\n        langfuse_context.configure(enabled=tracing)\n\n        self.exchange = create_exchange(profile=load_profile(profile), notifier=self.notifier)\n        setup_logging(log_file_directory=LOG_PATH, log_level=log_level)\n\n        self.exchange.messages.extend(self._get_initial_messages())\n\n        if len(self.exchange.messages) == 0 and plan:\n            self.setup_plan(plan=plan)\n\n        self.prompt_session = GoosePromptSession()\n\n    def _get_initial_messages(self) -&gt; list[Message]:\n        messages = self.load_session()\n\n        if messages and messages[-1].role == \"user\":\n            if type(messages[-1].content[-1]) is Text:\n                # remove the last user message\n                messages.pop()\n            elif type(messages[-1].content[-1]) is ToolResult:\n                # if we remove this message, we would need to remove\n                # the previous assistant message as well. instead of doing\n                # that, we just add a new assistant message to prompt the user\n                messages.append(Message.assistant(RESUME_MESSAGE))\n        if messages and type(messages[-1].content[-1]) is ToolUse:\n            # remove the last request for a tool to be used\n            messages.pop()\n\n            # add a new assistant text message to prompt the user\n            messages.append(Message.assistant(RESUME_MESSAGE))\n        return messages\n\n    def setup_plan(self, plan: dict) -&gt; None:\n        if len(self.exchange.messages):\n            raise ValueError(\"The plan can only be set on an empty session.\")\n        self.exchange.messages.append(Message.user(plan[\"kickoff_message\"]))\n        tasks = []\n        if \"tasks\" in plan:\n            tasks = [dict(description=task, status=\"planned\") for task in plan[\"tasks\"]]\n\n        plan_tool_use = ToolUse(id=\"initialplan\", name=\"update_plan\", parameters=dict(tasks=tasks))\n        self.exchange.add_tool_use(plan_tool_use)\n\n    def process_first_message(self) -&gt; Optional[Message]:\n        # Get a first input unless it has been specified, such as by a plan\n        if len(self.exchange.messages) == 0 or self.exchange.messages[-1].role == \"assistant\":\n            user_input = self.prompt_session.get_user_input()\n            if user_input.to_exit():\n                return None\n            return Message.user(text=user_input.text)\n        return self.exchange.messages.pop()\n\n    def single_pass(self, initial_message: str) -&gt; None:\n        \"\"\"\n        Handles a single input message and processes a reply\n        without entering a loop for additional inputs.\n\n        Args:\n            initial_message (str): The initial user message to process.\n        \"\"\"\n        profile = self.profile_name or \"default\"\n        print(f\"[dim]starting session | name:[cyan]{self.name}[/]  profile:[cyan]{profile}[/]\")\n        print(f\"[dim]saving to {self.session_file_path}\")\n        print()\n\n        # Process initial message\n        message = Message.user(initial_message)\n\n        self.exchange.add(message)\n        self.reply()  # Process the user message\n\n        save_latest_session(self.session_file_path, self.exchange.messages)\n        print()  # Print a newline for separation.\n\n        print(f\"[dim]ended run | name:[cyan]{self.name}[/]  profile:[cyan]{profile}[/]\")\n        print(f\"[dim]to resume: [magenta]goose session resume {self.name} --profile {profile}[/][/]\")\n\n    def run(self, new_session: bool = True) -&gt; None:\n        \"\"\"\n        Runs the main loop to handle user inputs and responses.\n        Continues until an empty string is returned from the prompt.\n\n        Args:\n            new_session (bool): True when starting a new session, False when resuming.\n        \"\"\"\n        if is_existing_session(self.session_file_path) and new_session:\n            self._prompt_overwrite_session()\n\n        profile_name = self.profile_name or \"default\"\n        print(f\"[dim]starting session | name: [cyan]{self.name}[/cyan]  profile: [cyan]{profile_name}[/cyan][/dim]\")\n        print()\n        message = self.process_first_message()\n        while message:  # Loop until no input (empty string).\n            self.notifier.start()\n            try:\n                self.exchange.add(message)\n                self.reply()  # Process the user message.\n            except KeyboardInterrupt:\n                self.interrupt_reply()\n            except Exception:\n                # rewind to right before the last user message\n                self.exchange.rewind()\n                print(traceback.format_exc())\n                print(\n                    \"\\n[red]The error above was an exception we were not able to handle.\\n\\n[/]\"\n                    + \"These errors are often related to connection or authentication\\n\"\n                    + \"We've removed the conversation up to the most recent user message\"\n                    + \" - [yellow]depending on the error you may be able to continue[/]\"\n                )\n            self.notifier.stop()\n            save_latest_session(self.session_file_path, self.exchange.messages)\n            print()  # Print a newline for separation.\n            user_input = self.prompt_session.get_user_input()\n            message = Message.user(text=user_input.text) if user_input.to_continue() else None\n\n        self._remove_empty_session()\n        self._log_cost()\n\n    @observe_wrapper()\n    def reply(self) -&gt; None:\n        \"\"\"Reply to the last user message, calling tools as needed\"\"\"\n        self.status_indicator.update(\"responding\")\n        response = self.exchange.generate()\n\n        if response.text:\n            print(Markdown(response.text))\n\n        while response.tool_use:\n            content = []\n            for tool_use in response.tool_use:\n                tool_result = self.exchange.call_function(tool_use)\n                content.append(tool_result)\n            self.exchange.add(Message(role=\"user\", content=content))\n            self.status_indicator.update(\"responding\")\n            response = self.exchange.generate()\n\n            if response.text:\n                print(Markdown(response.text))\n\n    def interrupt_reply(self) -&gt; None:\n        \"\"\"Recover from an interruption at an arbitrary state\"\"\"\n        # Default recovery message if no user message is pending.\n        recovery = \"We interrupted before the next processing started.\"\n        if self.exchange.messages and self.exchange.messages[-1].role == \"user\":\n            # If the last message is from the user, remove it.\n            self.exchange.messages.pop()\n            recovery = \"We interrupted before the model replied and removed the last message.\"\n\n        if (\n            self.exchange.messages\n            and self.exchange.messages[-1].role == \"assistant\"\n            and self.exchange.messages[-1].tool_use\n        ):\n            content = []\n            # Append tool results as errors if interrupted.\n            for tool_use in self.exchange.messages[-1].tool_use:\n                content.append(\n                    ToolResult(\n                        tool_use_id=tool_use.id,\n                        output=\"Interrupted by the user to make a correction\",\n                        is_error=True,\n                    )\n                )\n            self.exchange.add(Message(role=\"user\", content=content))\n            recovery = f\"We interrupted the existing call to {tool_use.name}. How would you like to proceed?\"\n            self.exchange.add(Message.assistant(recovery))\n        # Print the recovery message with markup for visibility.\n        print(f\"[yellow]{recovery}[/]\")\n\n    @property\n    def session_file_path(self) -&gt; Path:\n        return session_path(self.name)\n\n    def load_session(self) -&gt; list[Message]:\n        return read_or_create_file(self.session_file_path)\n\n    def _log_cost(self) -&gt; None:\n        get_logger().info(get_total_cost_message(self.exchange.get_token_usage()))\n        print(f\"[dim]you can view the cost and token usage in the log directory {LOG_PATH}[/]\")\n\n    def _prompt_overwrite_session(self) -&gt; None:\n        print(f\"[yellow]Session already exists at {self.session_file_path}.[/]\")\n\n        choice = OverwriteSessionPrompt.ask(\"Enter your choice\", show_choices=False)\n        match choice:\n            case \"y\" | \"yes\":\n                print(\"Overwriting existing session\")\n\n            case \"n\" | \"no\":\n                while True:\n                    new_session_name = Prompt.ask(\"Enter a new session name\")\n                    if not is_existing_session(session_path(new_session_name)):\n                        self.name = new_session_name\n                        break\n                    print(f\"[yellow]Session '{new_session_name}' already exists[/]\")\n\n            case \"r\" | \"resume\":\n                self.exchange.messages.extend(self.load_session())\n\n    def _remove_empty_session(self) -&gt; bool:\n        \"\"\"\n        Removes the session file only when it's empty.\n\n        Note: This is because a session file is created at the start of the run\n        loop. When a user aborts before their first message empty session files\n        will be created, causing confusion when resuming sessions (which\n        depends on most recent mtime and is non-empty).\n\n        Returns:\n            bool: True if the session file was removed, False otherwise.\n        \"\"\"\n        logger = get_logger()\n        try:\n            if is_empty_session(self.session_file_path):\n                logger.debug(f\"deleting empty session file: {self.session_file_path}\")\n                self.session_file_path.unlink()\n                return True\n        except Exception as e:\n            logger.error(f\"error deleting empty session file: {e}\")\n        return False\n</code></pre>"},{"location":"reference/goose/cli/session.html#goose.cli.session.Session.interrupt_reply","title":"<code>interrupt_reply()</code>","text":"<p>Recover from an interruption at an arbitrary state</p> Source code in <code>src/goose/cli/session.py</code> <pre><code>def interrupt_reply(self) -&gt; None:\n    \"\"\"Recover from an interruption at an arbitrary state\"\"\"\n    # Default recovery message if no user message is pending.\n    recovery = \"We interrupted before the next processing started.\"\n    if self.exchange.messages and self.exchange.messages[-1].role == \"user\":\n        # If the last message is from the user, remove it.\n        self.exchange.messages.pop()\n        recovery = \"We interrupted before the model replied and removed the last message.\"\n\n    if (\n        self.exchange.messages\n        and self.exchange.messages[-1].role == \"assistant\"\n        and self.exchange.messages[-1].tool_use\n    ):\n        content = []\n        # Append tool results as errors if interrupted.\n        for tool_use in self.exchange.messages[-1].tool_use:\n            content.append(\n                ToolResult(\n                    tool_use_id=tool_use.id,\n                    output=\"Interrupted by the user to make a correction\",\n                    is_error=True,\n                )\n            )\n        self.exchange.add(Message(role=\"user\", content=content))\n        recovery = f\"We interrupted the existing call to {tool_use.name}. How would you like to proceed?\"\n        self.exchange.add(Message.assistant(recovery))\n    # Print the recovery message with markup for visibility.\n    print(f\"[yellow]{recovery}[/]\")\n</code></pre>"},{"location":"reference/goose/cli/session.html#goose.cli.session.Session.reply","title":"<code>reply()</code>","text":"<p>Reply to the last user message, calling tools as needed</p> Source code in <code>src/goose/cli/session.py</code> <pre><code>@observe_wrapper()\ndef reply(self) -&gt; None:\n    \"\"\"Reply to the last user message, calling tools as needed\"\"\"\n    self.status_indicator.update(\"responding\")\n    response = self.exchange.generate()\n\n    if response.text:\n        print(Markdown(response.text))\n\n    while response.tool_use:\n        content = []\n        for tool_use in response.tool_use:\n            tool_result = self.exchange.call_function(tool_use)\n            content.append(tool_result)\n        self.exchange.add(Message(role=\"user\", content=content))\n        self.status_indicator.update(\"responding\")\n        response = self.exchange.generate()\n\n        if response.text:\n            print(Markdown(response.text))\n</code></pre>"},{"location":"reference/goose/cli/session.html#goose.cli.session.Session.run","title":"<code>run(new_session=True)</code>","text":"<p>Runs the main loop to handle user inputs and responses. Continues until an empty string is returned from the prompt.</p> <p>Parameters:</p> Name Type Description Default <code>new_session</code> <code>bool</code> <p>True when starting a new session, False when resuming.</p> <code>True</code> Source code in <code>src/goose/cli/session.py</code> <pre><code>def run(self, new_session: bool = True) -&gt; None:\n    \"\"\"\n    Runs the main loop to handle user inputs and responses.\n    Continues until an empty string is returned from the prompt.\n\n    Args:\n        new_session (bool): True when starting a new session, False when resuming.\n    \"\"\"\n    if is_existing_session(self.session_file_path) and new_session:\n        self._prompt_overwrite_session()\n\n    profile_name = self.profile_name or \"default\"\n    print(f\"[dim]starting session | name: [cyan]{self.name}[/cyan]  profile: [cyan]{profile_name}[/cyan][/dim]\")\n    print()\n    message = self.process_first_message()\n    while message:  # Loop until no input (empty string).\n        self.notifier.start()\n        try:\n            self.exchange.add(message)\n            self.reply()  # Process the user message.\n        except KeyboardInterrupt:\n            self.interrupt_reply()\n        except Exception:\n            # rewind to right before the last user message\n            self.exchange.rewind()\n            print(traceback.format_exc())\n            print(\n                \"\\n[red]The error above was an exception we were not able to handle.\\n\\n[/]\"\n                + \"These errors are often related to connection or authentication\\n\"\n                + \"We've removed the conversation up to the most recent user message\"\n                + \" - [yellow]depending on the error you may be able to continue[/]\"\n            )\n        self.notifier.stop()\n        save_latest_session(self.session_file_path, self.exchange.messages)\n        print()  # Print a newline for separation.\n        user_input = self.prompt_session.get_user_input()\n        message = Message.user(text=user_input.text) if user_input.to_continue() else None\n\n    self._remove_empty_session()\n    self._log_cost()\n</code></pre>"},{"location":"reference/goose/cli/session.html#goose.cli.session.Session.single_pass","title":"<code>single_pass(initial_message)</code>","text":"<p>Handles a single input message and processes a reply without entering a loop for additional inputs.</p> <p>Parameters:</p> Name Type Description Default <code>initial_message</code> <code>str</code> <p>The initial user message to process.</p> required Source code in <code>src/goose/cli/session.py</code> <pre><code>def single_pass(self, initial_message: str) -&gt; None:\n    \"\"\"\n    Handles a single input message and processes a reply\n    without entering a loop for additional inputs.\n\n    Args:\n        initial_message (str): The initial user message to process.\n    \"\"\"\n    profile = self.profile_name or \"default\"\n    print(f\"[dim]starting session | name:[cyan]{self.name}[/]  profile:[cyan]{profile}[/]\")\n    print(f\"[dim]saving to {self.session_file_path}\")\n    print()\n\n    # Process initial message\n    message = Message.user(initial_message)\n\n    self.exchange.add(message)\n    self.reply()  # Process the user message\n\n    save_latest_session(self.session_file_path, self.exchange.messages)\n    print()  # Print a newline for separation.\n\n    print(f\"[dim]ended run | name:[cyan]{self.name}[/]  profile:[cyan]{profile}[/]\")\n    print(f\"[dim]to resume: [magenta]goose session resume {self.name} --profile {profile}[/][/]\")\n</code></pre>"},{"location":"reference/goose/cli/prompt/index.html","title":"Index","text":""},{"location":"reference/goose/cli/prompt/completer.html","title":"Completer","text":""},{"location":"reference/goose/cli/prompt/create.html","title":"Create","text":""},{"location":"reference/goose/cli/prompt/create.html#goose.cli.prompt.create.create_prompt","title":"<code>create_prompt(commands)</code>","text":"<p>Create a prompt session with the given commands.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>dict[str, Command]</code> <p>A dictionary of command names, and instances of Command classes.</p> required Source code in <code>src/goose/cli/prompt/create.py</code> <pre><code>def create_prompt(commands: dict[str, Command]) -&gt; PromptSession:\n    \"\"\"\n    Create a prompt session with the given commands.\n\n    Args:\n        commands (dict[str, Command]): A dictionary of command names, and instances of Command classes.\n    \"\"\"\n    # Define custom style\n    style = Style.from_dict(\n        {\n            \"parameter\": \"bold\",\n            \"command\": \"ansiblue bold\",\n            \"text\": \"default\",\n        }\n    )\n\n    bindings = KeyBindings()\n\n    # Bind the \"Option + Enter\" key to insert a newline\n    @bindings.add(Keys.Escape, Keys.ControlM)\n    def _(event: KeyPressEvent) -&gt; None:\n        buffer = event.app.current_buffer\n        buffer.insert_text(\"\\n\")\n\n    # Bind the \"Enter\" key to accept the completion if the completion menu is open\n    # otherwise just submit the input\n    @bindings.add(Keys.Enter)\n    def _(event: KeyPressEvent) -&gt; None:\n        buffer = event.current_buffer\n        app = get_app()\n\n        if app.layout.has_focus(buffer):\n            # Check if the completion menu is open\n            if buffer.complete_state:\n                # accept completion\n                buffer.complete_state = None\n            else:\n                buffer.validate_and_handle()\n\n    @bindings.add(Keys.ControlY)\n    def _(event: KeyPressEvent) -&gt; None:\n        buffer = event.app.current_buffer\n        app = get_app()\n        if app.layout.has_focus(buffer):\n            # Check if the completion menu is open\n            if buffer.complete_state:\n                # accept completion\n                buffer.complete_state = None\n\n    return PromptSession(\n        completer=GoosePromptCompleter(commands=commands),\n        lexer=PromptLexer(list(commands.keys())),\n        style=style,\n        key_bindings=bindings,\n    )\n</code></pre>"},{"location":"reference/goose/cli/prompt/goose_prompt_session.html","title":"Goose prompt session","text":""},{"location":"reference/goose/cli/prompt/lexer.html","title":"Lexer","text":""},{"location":"reference/goose/cli/prompt/prompt_validator.html","title":"Prompt validator","text":""},{"location":"reference/goose/cli/prompt/user_input.html","title":"User input","text":""},{"location":"reference/goose/command/index.html","title":"Index","text":""},{"location":"reference/goose/command/base.html","title":"Base","text":""},{"location":"reference/goose/command/base.html#goose.command.base.Command","title":"<code>Command</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A command that can be executed by the CLI.</p> Source code in <code>src/goose/command/base.py</code> <pre><code>class Command(ABC):\n    \"\"\"A command that can be executed by the CLI.\"\"\"\n\n    def get_completions(self, query: str) -&gt; list[Completion]:\n        \"\"\"\n        Get completions for the command.\n\n        Args:\n            query (str): The current query.\n        \"\"\"\n        return []\n\n    def execute(self, query: str) -&gt; Optional[str]:\n        \"\"\"\n        Execute's the command and replaces it with the output.\n\n        Args:\n            query (str): The query to execute.\n        \"\"\"\n        return \"\"\n</code></pre>"},{"location":"reference/goose/command/base.html#goose.command.base.Command.execute","title":"<code>execute(query)</code>","text":"<p>Execute's the command and replaces it with the output.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to execute.</p> required Source code in <code>src/goose/command/base.py</code> <pre><code>def execute(self, query: str) -&gt; Optional[str]:\n    \"\"\"\n    Execute's the command and replaces it with the output.\n\n    Args:\n        query (str): The query to execute.\n    \"\"\"\n    return \"\"\n</code></pre>"},{"location":"reference/goose/command/base.html#goose.command.base.Command.get_completions","title":"<code>get_completions(query)</code>","text":"<p>Get completions for the command.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The current query.</p> required Source code in <code>src/goose/command/base.py</code> <pre><code>def get_completions(self, query: str) -&gt; list[Completion]:\n    \"\"\"\n    Get completions for the command.\n\n    Args:\n        query (str): The current query.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/goose/command/file.html","title":"File","text":""},{"location":"reference/goose/toolkit/index.html","title":"Index","text":""},{"location":"reference/goose/toolkit/base.html","title":"Base","text":""},{"location":"reference/goose/toolkit/base.html#goose.toolkit.base.Requirements","title":"<code>Requirements</code>","text":"<p>A collection of requirements for advanced toolkits</p> <p>Requirements are an advanced use case, most toolkits will not need to use these. They allow one toolkit to interact with another's state.</p> Source code in <code>src/goose/toolkit/base.py</code> <pre><code>@define\nclass Requirements:\n    \"\"\"A collection of requirements for advanced toolkits\n\n    Requirements are an advanced use case, most toolkits will not need to\n    use these. They allow one toolkit to interact with another's state.\n    \"\"\"\n\n    _toolkit: str\n    _requirements: Mapping[str, \"Toolkit\"] = field(factory=dict)\n\n    def get(self, requirement: str) -&gt; \"Toolkit\":\n        \"\"\"Get a requirement by name.\"\"\"\n        if requirement not in self._requirements:\n            raise RuntimeError(\n                f\"The toolkit '{self._toolkit}' requested a requirement '{requirement}' but none was passed!\\n\"\n                + f\"  Make sure to include `requires: {{{requirement}: ...}}` in your profile config\\n\"\n                + f\"  See the documentation for {self._toolkit} for more details\"\n            )\n        return self._requirements[requirement]\n</code></pre>"},{"location":"reference/goose/toolkit/base.html#goose.toolkit.base.Requirements.get","title":"<code>get(requirement)</code>","text":"<p>Get a requirement by name.</p> Source code in <code>src/goose/toolkit/base.py</code> <pre><code>def get(self, requirement: str) -&gt; \"Toolkit\":\n    \"\"\"Get a requirement by name.\"\"\"\n    if requirement not in self._requirements:\n        raise RuntimeError(\n            f\"The toolkit '{self._toolkit}' requested a requirement '{requirement}' but none was passed!\\n\"\n            + f\"  Make sure to include `requires: {{{requirement}: ...}}` in your profile config\\n\"\n            + f\"  See the documentation for {self._toolkit} for more details\"\n        )\n    return self._requirements[requirement]\n</code></pre>"},{"location":"reference/goose/toolkit/base.html#goose.toolkit.base.Toolkit","title":"<code>Toolkit</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A collection of tools with corresponding prompting</p> <p>This class defines the interface that all toolkit implementations must follow, providing a system prompt and a collection of tools. Both are allowed to be empty if they are not required for the toolkit.</p> Source code in <code>src/goose/toolkit/base.py</code> <pre><code>class Toolkit(ABC):\n    \"\"\"A collection of tools with corresponding prompting\n\n    This class defines the interface that all toolkit implementations must follow,\n    providing a system prompt and a collection of tools. Both are allowed to be\n    empty if they are not required for the toolkit.\n    \"\"\"\n\n    def __init__(self, notifier: Notifier, requires: Optional[Requirements] = None) -&gt; None:\n        self.notifier = notifier\n        # This needs to be updated after the fact via build_exchange\n        self.exchange_view = None\n\n    def system(self) -&gt; str:\n        \"\"\"Get the addition to the system prompt for this toolkit.\"\"\"\n        return \"\"\n\n    def tools(self) -&gt; tuple[Tool, ...]:\n        \"\"\"Get the tools for this toolkit\n\n        This default method looks for functions on the toolkit annotated\n        with @tool.\n        \"\"\"\n        candidates = inspect.getmembers(self, predicate=inspect.ismethod)\n        return (Tool.from_function(candidate) for _, candidate in candidates if getattr(candidate, \"_is_tool\", None))\n</code></pre>"},{"location":"reference/goose/toolkit/base.html#goose.toolkit.base.Toolkit.system","title":"<code>system()</code>","text":"<p>Get the addition to the system prompt for this toolkit.</p> Source code in <code>src/goose/toolkit/base.py</code> <pre><code>def system(self) -&gt; str:\n    \"\"\"Get the addition to the system prompt for this toolkit.\"\"\"\n    return \"\"\n</code></pre>"},{"location":"reference/goose/toolkit/base.html#goose.toolkit.base.Toolkit.tools","title":"<code>tools()</code>","text":"<p>Get the tools for this toolkit</p> <p>This default method looks for functions on the toolkit annotated with @tool.</p> Source code in <code>src/goose/toolkit/base.py</code> <pre><code>def tools(self) -&gt; tuple[Tool, ...]:\n    \"\"\"Get the tools for this toolkit\n\n    This default method looks for functions on the toolkit annotated\n    with @tool.\n    \"\"\"\n    candidates = inspect.getmembers(self, predicate=inspect.ismethod)\n    return (Tool.from_function(candidate) for _, candidate in candidates if getattr(candidate, \"_is_tool\", None))\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html","title":"Developer","text":""},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer","title":"<code>Developer</code>","text":"<p>               Bases: <code>Toolkit</code></p> <p>Provides a set of general purpose development capabilities</p> <p>The tools include plan management, a general purpose shell execution tool, and file operations. We also include some default shell strategies in the prompt, such as using ripgrep</p> Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>class Developer(Toolkit):\n    \"\"\"Provides a set of general purpose development capabilities\n\n    The tools include plan management, a general purpose shell execution tool, and file operations.\n    We also include some default shell strategies in the prompt, such as using ripgrep\n    \"\"\"\n\n    def __init__(self, *args: object, **kwargs: dict[str, object]) -&gt; None:\n        super().__init__(*args, **kwargs)\n        self.timestamps: dict[str, float] = {}\n\n    def system(self) -&gt; str:\n        \"\"\"Retrieve system configuration details for developer\"\"\"\n        hints_path = Path(\".goosehints\")\n        system_prompt = Message.load(\"prompts/developer.jinja\").text\n        home_hints_path = Path.home() / \".config/goose/.goosehints\"\n        hints = []\n        if hints_path.is_file():\n            hints.append(render_template(hints_path))\n        if home_hints_path.is_file():\n            hints.append(render_template(home_hints_path))\n        if hints:\n            hints_text = \"\\n\".join(hints)\n            system_prompt = f\"{system_prompt}\\n\\nHints:\\n{hints_text}\"\n        return system_prompt\n\n    @tool\n    def update_plan(self, tasks: list[dict]) -&gt; list[dict]:\n        \"\"\"\n        Update the plan by overwriting all current tasks\n\n        This can be used to update the status of a task. This update will be\n        shown to the user directly, you do not need to reiterate it\n\n        Args:\n            tasks (list(dict)): The list of tasks, where each task is a dictionary\n                with a key for the task \"description\" and the task \"status\". The status\n                MUST be one of \"planned\", \"complete\", \"failed\", \"in-progress\".\n\n        \"\"\"\n        # Validate the status of each task to ensure it is one of the accepted values.\n        for task in tasks:\n            if task[\"status\"] not in {\"planned\", \"complete\", \"failed\", \"in-progress\"}:\n                raise ValueError(f\"Invalid task status: {task['status']}\")\n\n        # Create a table with columns for the index, description, and status of each task.\n        table = Table(expand=True)\n        table.add_column(\"#\", justify=\"right\", style=\"magenta\")\n        table.add_column(\"Task\", justify=\"left\")\n        table.add_column(\"Status\", justify=\"left\")\n\n        # Mapping of statuses to emojis for better visual representation in the table.\n        emoji = {\"planned\": \"\u23f3\", \"complete\": \"\u2705\", \"failed\": \"\u274c\", \"in-progress\": \"\ud83d\udd51\"}\n        for i, entry in enumerate(tasks):\n            table.add_row(str(i), entry[\"description\"], emoji[entry[\"status\"]])\n\n        # Log the table to display it directly to the user\n        # `.log` method is used here to log the command execution in the application's UX\n        self.notifier.log(table)\n\n        # Return the tasks unchanged as the function's primary purpose is to update and display the task status.\n        return tasks\n\n    @tool\n    def patch_file(self, path: str, before: str, after: str) -&gt; str:\n        \"\"\"Patch the file at the specified by replacing before with after\n\n        Before **must** be present exactly once in the file, so that it can safely\n        be replaced with after.\n\n        Args:\n            path (str): The path to the file, in the format \"path/to/file.txt\"\n            before (str): The content that will be replaced\n            after (str): The content it will be replaced with\n        \"\"\"\n        self.notifier.status(f\"editing {path}\")\n        _path = Path(path)\n        language = get_language(path)\n\n        content = _path.read_text()\n\n        if content.count(before) &gt; 1:\n            raise ValueError(\"The before content is present multiple times in the file, be more specific.\")\n        if content.count(before) &lt; 1:\n            raise ValueError(\"The before content was not found in file, be careful that you recreate it exactly.\")\n\n        content = content.replace(before, after)\n        _path.write_text(content)\n\n        output = f\"\"\"\n```{language}\n{before}\n```\n-&gt;\n```{language}\n{after}\n```\n\"\"\"\n        self.notifier.log(Rule(RULEPREFIX + path, style=RULESTYLE, align=\"left\"))\n        self.notifier.log(Markdown(output))\n        return \"Succesfully replaced before with after.\"\n\n    @tool\n    def read_file(self, path: str) -&gt; str:\n        \"\"\"Read the content of the file at path\n\n        Args:\n            path (str): The destination file path, in the format \"path/to/file.txt\"\n        \"\"\"\n        language = get_language(path)\n        content = Path(path).expanduser().read_text()\n        self.notifier.log(Markdown(f\"```\\ncat {path}\\n```\"))\n        # Record the last read timestamp\n        self.timestamps[path] = os.path.getmtime(path)\n        return f\"```{language}\\n{content}\\n```\"\n\n    @tool\n    def shell(self, command: str) -&gt; str:\n        \"\"\"\n        Execute a command on the shell\n\n        This will return the output and error concatenated into a single string, as\n        you would see from running on the command line. There will also be an indication\n        of if the command succeeded or failed.\n\n        Args:\n            command (str): The shell command to run. It can support multiline statements\n                if you need to run more than one at a time\n        \"\"\"\n        # Log the command being executed in a visually structured format (Markdown).\n        self.notifier.log(Rule(RULEPREFIX + \"shell\", style=RULESTYLE, align=\"left\"))\n        self.notifier.log(Markdown(f\"```bash\\n{command}\\n```\"))\n\n        if is_dangerous_command(command):\n            # Stop the notifications so we can prompt\n            self.notifier.stop()\n            if not keep_unsafe_command_prompt(command):\n                raise RuntimeError(\n                    f\"The command {command} was rejected as dangerous by the user.\"\n                    \" Do not proceed further, instead ask for instructions.\"\n                )\n            self.notifier.start()\n        self.notifier.status(\"running shell command\")\n\n        # Define patterns that might indicate the process is waiting for input\n        interaction_patterns = [\n            r\"Do you want to\",  # Common prompt phrase\n            r\"Enter password\",  # Password prompt\n            r\"Are you sure\",  # Confirmation prompt\n            r\"\\(y/N\\)\",  # Yes/No prompt\n            r\"Press any key to continue\",  # Awaiting keypress\n            r\"Waiting for input\",  # General waiting message\n        ]\n        compiled_patterns = [re.compile(pattern, re.IGNORECASE) for pattern in interaction_patterns]\n\n        proc = subprocess.Popen(\n            command,\n            shell=True,\n            stdin=subprocess.DEVNULL,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            text=True,\n        )\n        # this enables us to read lines without blocking\n        os.set_blocking(proc.stdout.fileno(), False)\n\n        # Accumulate the output logs while checking if it might be blocked\n        output_lines = []\n        last_output_time = time.time()\n        cutoff = 10\n        while proc.poll() is None:\n            self.notifier.status(\"running shell command\")\n            line = proc.stdout.readline()\n            if line:\n                output_lines.append(line)\n                last_output_time = time.time()\n\n            # If we see a clear pattern match, we plan to abort\n            exit_criteria = any(pattern.search(line) for pattern in compiled_patterns)\n\n            # and if we haven't seen a new line in 10+s, check with AI to see if it may be stuck\n            if not exit_criteria and time.time() - last_output_time &gt; cutoff:\n                self.notifier.status(\"checking on shell status\")\n                response = ask_an_ai(\n                    input=\"\\n\".join([command] + output_lines),\n                    prompt=(\n                        \"You will evaluate the output of shell commands to see if they may be stuck.\"\n                        \" Look for commands that appear to be awaiting user input, or otherwise running indefinitely (such as a web service).\"  # noqa\n                        \" A command that will take a while, such as downloading resources is okay.\"  # noqa\n                        \" return [Yes] if stuck, [No] otherwise.\"\n                    ),\n                    exchange=self.exchange_view.processor,\n                    with_tools=False,\n                )\n                exit_criteria = \"[yes]\" in response.content[0].text.lower()\n                # We add exponential backoff for how often we check for the command being stuck\n                cutoff *= 10\n\n            if exit_criteria:\n                proc.terminate()\n                raise ValueError(\n                    f\"The command `{command}` looks like it will run indefinitely or is otherwise stuck.\"\n                    f\"You may be able to specify inputs if it applies to this command.\"\n                    f\"Otherwise to enable continued iteration, you'll need to ask the user to run this command in another terminal.\"  # noqa\n                )\n\n        # read any remaining lines\n        while line := proc.stdout.readline():\n            output_lines.append(line)\n        output = \"\".join(output_lines)\n\n        # Determine the result based on the return code\n        if proc.returncode == 0:\n            result = \"Command succeeded\"\n        else:\n            result = f\"Command failed with returncode {proc.returncode}\"\n\n        # Return the combined result and outputs if we made it this far\n        return \"\\n\".join([result, output])\n\n    @tool\n    def write_file(self, path: str, content: str) -&gt; str:\n        \"\"\"\n        Write a file at the specified path with the provided content. This will create any directories if they do not exist.\n        The content will fully overwrite the existing file.\n\n        Args:\n            path (str): The destination file path, in the format \"path/to/file.txt\"\n            content (str): The raw file content.\n        \"\"\"  # noqa: E501\n        self.notifier.status(\"writing file\")\n        # Get the programming language for syntax highlighting in logs\n        language = get_language(path)\n        md = f\"```{language}\\n{content}\\n```\"\n\n        # Log the content that will be written to the file\n        # .log` method is used here to log the command execution in the application's UX\n        # this method is dynamically attached to functions in the Goose framework\n        self.notifier.log(Rule(RULEPREFIX + path, style=RULESTYLE, align=\"left\"))\n        self.notifier.log(Markdown(md))\n\n        _path = Path(path)\n        if path in self.timestamps:\n            last_read_timestamp = self.timestamps.get(path, 0.0)\n            current_timestamp = os.path.getmtime(path)\n            if current_timestamp &gt; last_read_timestamp:\n                raise RuntimeError(\n                    f\"File '{path}' has been modified since it was last read.\"\n                    + \" Read the file to incorporate changes or update your plan.\"\n                )\n\n        # Prepare the path and create any necessary parent directories\n        _path.parent.mkdir(parents=True, exist_ok=True)\n\n        # Write the content to the file\n        _path.write_text(content)\n\n        # Update the last read timestamp after writing to the file\n        self.timestamps[path] = os.path.getmtime(path)\n\n        # Return a success message\n        return f\"Successfully wrote to {path}\"\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer.patch_file","title":"<code>patch_file(path, before, after)</code>","text":"<p>Patch the file at the specified by replacing before with after</p> <p>Before must be present exactly once in the file, so that it can safely be replaced with after.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file, in the format \"path/to/file.txt\"</p> required <code>before</code> <code>str</code> <p>The content that will be replaced</p> required <code>after</code> <code>str</code> <p>The content it will be replaced with</p> required Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>    @tool\n    def patch_file(self, path: str, before: str, after: str) -&gt; str:\n        \"\"\"Patch the file at the specified by replacing before with after\n\n        Before **must** be present exactly once in the file, so that it can safely\n        be replaced with after.\n\n        Args:\n            path (str): The path to the file, in the format \"path/to/file.txt\"\n            before (str): The content that will be replaced\n            after (str): The content it will be replaced with\n        \"\"\"\n        self.notifier.status(f\"editing {path}\")\n        _path = Path(path)\n        language = get_language(path)\n\n        content = _path.read_text()\n\n        if content.count(before) &gt; 1:\n            raise ValueError(\"The before content is present multiple times in the file, be more specific.\")\n        if content.count(before) &lt; 1:\n            raise ValueError(\"The before content was not found in file, be careful that you recreate it exactly.\")\n\n        content = content.replace(before, after)\n        _path.write_text(content)\n\n        output = f\"\"\"\n```{language}\n{before}\n```\n-&gt;\n```{language}\n{after}\n```\n\"\"\"\n        self.notifier.log(Rule(RULEPREFIX + path, style=RULESTYLE, align=\"left\"))\n        self.notifier.log(Markdown(output))\n        return \"Succesfully replaced before with after.\"\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer.read_file","title":"<code>read_file(path)</code>","text":"<p>Read the content of the file at path</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The destination file path, in the format \"path/to/file.txt\"</p> required Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>@tool\ndef read_file(self, path: str) -&gt; str:\n    \"\"\"Read the content of the file at path\n\n    Args:\n        path (str): The destination file path, in the format \"path/to/file.txt\"\n    \"\"\"\n    language = get_language(path)\n    content = Path(path).expanduser().read_text()\n    self.notifier.log(Markdown(f\"```\\ncat {path}\\n```\"))\n    # Record the last read timestamp\n    self.timestamps[path] = os.path.getmtime(path)\n    return f\"```{language}\\n{content}\\n```\"\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer.shell","title":"<code>shell(command)</code>","text":"<p>Execute a command on the shell</p> <p>This will return the output and error concatenated into a single string, as you would see from running on the command line. There will also be an indication of if the command succeeded or failed.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The shell command to run. It can support multiline statements if you need to run more than one at a time</p> required Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>@tool\ndef shell(self, command: str) -&gt; str:\n    \"\"\"\n    Execute a command on the shell\n\n    This will return the output and error concatenated into a single string, as\n    you would see from running on the command line. There will also be an indication\n    of if the command succeeded or failed.\n\n    Args:\n        command (str): The shell command to run. It can support multiline statements\n            if you need to run more than one at a time\n    \"\"\"\n    # Log the command being executed in a visually structured format (Markdown).\n    self.notifier.log(Rule(RULEPREFIX + \"shell\", style=RULESTYLE, align=\"left\"))\n    self.notifier.log(Markdown(f\"```bash\\n{command}\\n```\"))\n\n    if is_dangerous_command(command):\n        # Stop the notifications so we can prompt\n        self.notifier.stop()\n        if not keep_unsafe_command_prompt(command):\n            raise RuntimeError(\n                f\"The command {command} was rejected as dangerous by the user.\"\n                \" Do not proceed further, instead ask for instructions.\"\n            )\n        self.notifier.start()\n    self.notifier.status(\"running shell command\")\n\n    # Define patterns that might indicate the process is waiting for input\n    interaction_patterns = [\n        r\"Do you want to\",  # Common prompt phrase\n        r\"Enter password\",  # Password prompt\n        r\"Are you sure\",  # Confirmation prompt\n        r\"\\(y/N\\)\",  # Yes/No prompt\n        r\"Press any key to continue\",  # Awaiting keypress\n        r\"Waiting for input\",  # General waiting message\n    ]\n    compiled_patterns = [re.compile(pattern, re.IGNORECASE) for pattern in interaction_patterns]\n\n    proc = subprocess.Popen(\n        command,\n        shell=True,\n        stdin=subprocess.DEVNULL,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT,\n        text=True,\n    )\n    # this enables us to read lines without blocking\n    os.set_blocking(proc.stdout.fileno(), False)\n\n    # Accumulate the output logs while checking if it might be blocked\n    output_lines = []\n    last_output_time = time.time()\n    cutoff = 10\n    while proc.poll() is None:\n        self.notifier.status(\"running shell command\")\n        line = proc.stdout.readline()\n        if line:\n            output_lines.append(line)\n            last_output_time = time.time()\n\n        # If we see a clear pattern match, we plan to abort\n        exit_criteria = any(pattern.search(line) for pattern in compiled_patterns)\n\n        # and if we haven't seen a new line in 10+s, check with AI to see if it may be stuck\n        if not exit_criteria and time.time() - last_output_time &gt; cutoff:\n            self.notifier.status(\"checking on shell status\")\n            response = ask_an_ai(\n                input=\"\\n\".join([command] + output_lines),\n                prompt=(\n                    \"You will evaluate the output of shell commands to see if they may be stuck.\"\n                    \" Look for commands that appear to be awaiting user input, or otherwise running indefinitely (such as a web service).\"  # noqa\n                    \" A command that will take a while, such as downloading resources is okay.\"  # noqa\n                    \" return [Yes] if stuck, [No] otherwise.\"\n                ),\n                exchange=self.exchange_view.processor,\n                with_tools=False,\n            )\n            exit_criteria = \"[yes]\" in response.content[0].text.lower()\n            # We add exponential backoff for how often we check for the command being stuck\n            cutoff *= 10\n\n        if exit_criteria:\n            proc.terminate()\n            raise ValueError(\n                f\"The command `{command}` looks like it will run indefinitely or is otherwise stuck.\"\n                f\"You may be able to specify inputs if it applies to this command.\"\n                f\"Otherwise to enable continued iteration, you'll need to ask the user to run this command in another terminal.\"  # noqa\n            )\n\n    # read any remaining lines\n    while line := proc.stdout.readline():\n        output_lines.append(line)\n    output = \"\".join(output_lines)\n\n    # Determine the result based on the return code\n    if proc.returncode == 0:\n        result = \"Command succeeded\"\n    else:\n        result = f\"Command failed with returncode {proc.returncode}\"\n\n    # Return the combined result and outputs if we made it this far\n    return \"\\n\".join([result, output])\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer.system","title":"<code>system()</code>","text":"<p>Retrieve system configuration details for developer</p> Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>def system(self) -&gt; str:\n    \"\"\"Retrieve system configuration details for developer\"\"\"\n    hints_path = Path(\".goosehints\")\n    system_prompt = Message.load(\"prompts/developer.jinja\").text\n    home_hints_path = Path.home() / \".config/goose/.goosehints\"\n    hints = []\n    if hints_path.is_file():\n        hints.append(render_template(hints_path))\n    if home_hints_path.is_file():\n        hints.append(render_template(home_hints_path))\n    if hints:\n        hints_text = \"\\n\".join(hints)\n        system_prompt = f\"{system_prompt}\\n\\nHints:\\n{hints_text}\"\n    return system_prompt\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer.update_plan","title":"<code>update_plan(tasks)</code>","text":"<p>Update the plan by overwriting all current tasks</p> <p>This can be used to update the status of a task. This update will be shown to the user directly, you do not need to reiterate it</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list(dict</code> <p>The list of tasks, where each task is a dictionary with a key for the task \"description\" and the task \"status\". The status MUST be one of \"planned\", \"complete\", \"failed\", \"in-progress\".</p> required Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>@tool\ndef update_plan(self, tasks: list[dict]) -&gt; list[dict]:\n    \"\"\"\n    Update the plan by overwriting all current tasks\n\n    This can be used to update the status of a task. This update will be\n    shown to the user directly, you do not need to reiterate it\n\n    Args:\n        tasks (list(dict)): The list of tasks, where each task is a dictionary\n            with a key for the task \"description\" and the task \"status\". The status\n            MUST be one of \"planned\", \"complete\", \"failed\", \"in-progress\".\n\n    \"\"\"\n    # Validate the status of each task to ensure it is one of the accepted values.\n    for task in tasks:\n        if task[\"status\"] not in {\"planned\", \"complete\", \"failed\", \"in-progress\"}:\n            raise ValueError(f\"Invalid task status: {task['status']}\")\n\n    # Create a table with columns for the index, description, and status of each task.\n    table = Table(expand=True)\n    table.add_column(\"#\", justify=\"right\", style=\"magenta\")\n    table.add_column(\"Task\", justify=\"left\")\n    table.add_column(\"Status\", justify=\"left\")\n\n    # Mapping of statuses to emojis for better visual representation in the table.\n    emoji = {\"planned\": \"\u23f3\", \"complete\": \"\u2705\", \"failed\": \"\u274c\", \"in-progress\": \"\ud83d\udd51\"}\n    for i, entry in enumerate(tasks):\n        table.add_row(str(i), entry[\"description\"], emoji[entry[\"status\"]])\n\n    # Log the table to display it directly to the user\n    # `.log` method is used here to log the command execution in the application's UX\n    self.notifier.log(table)\n\n    # Return the tasks unchanged as the function's primary purpose is to update and display the task status.\n    return tasks\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer.write_file","title":"<code>write_file(path, content)</code>","text":"<p>Write a file at the specified path with the provided content. This will create any directories if they do not exist. The content will fully overwrite the existing file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The destination file path, in the format \"path/to/file.txt\"</p> required <code>content</code> <code>str</code> <p>The raw file content.</p> required Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>@tool\ndef write_file(self, path: str, content: str) -&gt; str:\n    \"\"\"\n    Write a file at the specified path with the provided content. This will create any directories if they do not exist.\n    The content will fully overwrite the existing file.\n\n    Args:\n        path (str): The destination file path, in the format \"path/to/file.txt\"\n        content (str): The raw file content.\n    \"\"\"  # noqa: E501\n    self.notifier.status(\"writing file\")\n    # Get the programming language for syntax highlighting in logs\n    language = get_language(path)\n    md = f\"```{language}\\n{content}\\n```\"\n\n    # Log the content that will be written to the file\n    # .log` method is used here to log the command execution in the application's UX\n    # this method is dynamically attached to functions in the Goose framework\n    self.notifier.log(Rule(RULEPREFIX + path, style=RULESTYLE, align=\"left\"))\n    self.notifier.log(Markdown(md))\n\n    _path = Path(path)\n    if path in self.timestamps:\n        last_read_timestamp = self.timestamps.get(path, 0.0)\n        current_timestamp = os.path.getmtime(path)\n        if current_timestamp &gt; last_read_timestamp:\n            raise RuntimeError(\n                f\"File '{path}' has been modified since it was last read.\"\n                + \" Read the file to incorporate changes or update your plan.\"\n            )\n\n    # Prepare the path and create any necessary parent directories\n    _path.parent.mkdir(parents=True, exist_ok=True)\n\n    # Write the content to the file\n    _path.write_text(content)\n\n    # Update the last read timestamp after writing to the file\n    self.timestamps[path] = os.path.getmtime(path)\n\n    # Return a success message\n    return f\"Successfully wrote to {path}\"\n</code></pre>"},{"location":"reference/goose/toolkit/github.html","title":"Github","text":""},{"location":"reference/goose/toolkit/github.html#goose.toolkit.github.Github","title":"<code>Github</code>","text":"<p>               Bases: <code>Toolkit</code></p> <p>Provides an additional prompt on how to interact with Github</p> Source code in <code>src/goose/toolkit/github.py</code> <pre><code>class Github(Toolkit):\n    \"\"\"Provides an additional prompt on how to interact with Github\"\"\"\n\n    def system(self) -&gt; str:\n        \"\"\"Retrieve detailed configuration and procedural guidelines for GitHub operations\"\"\"\n        return Message.load(\"prompts/github.jinja\").text\n</code></pre>"},{"location":"reference/goose/toolkit/github.html#goose.toolkit.github.Github.system","title":"<code>system()</code>","text":"<p>Retrieve detailed configuration and procedural guidelines for GitHub operations</p> Source code in <code>src/goose/toolkit/github.py</code> <pre><code>def system(self) -&gt; str:\n    \"\"\"Retrieve detailed configuration and procedural guidelines for GitHub operations\"\"\"\n    return Message.load(\"prompts/github.jinja\").text\n</code></pre>"},{"location":"reference/goose/toolkit/lint.html","title":"Lint","text":""},{"location":"reference/goose/toolkit/screen.html","title":"Screen","text":""},{"location":"reference/goose/toolkit/screen.html#goose.toolkit.screen.Screen","title":"<code>Screen</code>","text":"<p>               Bases: <code>Toolkit</code></p> <p>Provides an instructions on when and how to work with screenshots</p> Source code in <code>src/goose/toolkit/screen.py</code> <pre><code>class Screen(Toolkit):\n    \"\"\"Provides an instructions on when and how to work with screenshots\"\"\"\n\n    @tool\n    def take_screenshot(self, display: int = 1) -&gt; str:\n        \"\"\"\n        Take a screenshot to assist the user in debugging or designing an app. They may need\n        help with moving a screen element, or interacting in some way where you could do with\n        seeing the screen.\n\n        Args:\n            display (int): Display to take the screen shot in. Default is the main display (1). Must be a value greater than 1.\n        \"\"\"  # noqa: E501\n        # Generate a random tmp filename for screenshot\n        filename = f\"/tmp/goose_screenshot_{uuid.uuid4().hex}.jpg\"\n        screen_capture_command = [\"screencapture\", \"-x\", \"-D\", str(display), filename, \"-f\", \"jpg\"]\n\n        subprocess.run(screen_capture_command, check=True, capture_output=True)\n\n        resize_command = [\"sips\", \"--resampleWidth\", \"768\", filename, \"-s\", \"format\", \"jpeg\"]\n        subprocess.run(resize_command, check=True, capture_output=True)\n\n        self.notifier.log(\n            Panel.fit(\n                Markdown(f\"```bash\\n{' '.join(screen_capture_command)}\"),\n                title=\"screen\",\n            )\n        )\n\n        return f\"image:{filename}\"\n\n    # Provide any system instructions for the model\n    # This can be generated dynamically, and is run at startup time\n    def system(self) -&gt; str:\n        return \"\"\"**When the user wants you to help debug, or work on a visual design by looking at their screen, IDE or browser, call the take_screenshot and send the output from the user.**\"\"\"  # noqa: E501\n</code></pre>"},{"location":"reference/goose/toolkit/screen.html#goose.toolkit.screen.Screen.take_screenshot","title":"<code>take_screenshot(display=1)</code>","text":"<p>Take a screenshot to assist the user in debugging or designing an app. They may need help with moving a screen element, or interacting in some way where you could do with seeing the screen.</p> <p>Parameters:</p> Name Type Description Default <code>display</code> <code>int</code> <p>Display to take the screen shot in. Default is the main display (1). Must be a value greater than 1.</p> <code>1</code> Source code in <code>src/goose/toolkit/screen.py</code> <pre><code>@tool\ndef take_screenshot(self, display: int = 1) -&gt; str:\n    \"\"\"\n    Take a screenshot to assist the user in debugging or designing an app. They may need\n    help with moving a screen element, or interacting in some way where you could do with\n    seeing the screen.\n\n    Args:\n        display (int): Display to take the screen shot in. Default is the main display (1). Must be a value greater than 1.\n    \"\"\"  # noqa: E501\n    # Generate a random tmp filename for screenshot\n    filename = f\"/tmp/goose_screenshot_{uuid.uuid4().hex}.jpg\"\n    screen_capture_command = [\"screencapture\", \"-x\", \"-D\", str(display), filename, \"-f\", \"jpg\"]\n\n    subprocess.run(screen_capture_command, check=True, capture_output=True)\n\n    resize_command = [\"sips\", \"--resampleWidth\", \"768\", filename, \"-s\", \"format\", \"jpeg\"]\n    subprocess.run(resize_command, check=True, capture_output=True)\n\n    self.notifier.log(\n        Panel.fit(\n            Markdown(f\"```bash\\n{' '.join(screen_capture_command)}\"),\n            title=\"screen\",\n        )\n    )\n\n    return f\"image:{filename}\"\n</code></pre>"},{"location":"reference/goose/toolkit/utils.html","title":"Utils","text":""},{"location":"reference/goose/toolkit/utils.html#goose.toolkit.utils.get_language","title":"<code>get_language(filename)</code>","text":"<p>Determine the programming language of a file based on its filename extension.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file for which to determine the programming language.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the programming language if recognized, otherwise an empty string.</p> Source code in <code>src/goose/toolkit/utils.py</code> <pre><code>def get_language(filename: Path) -&gt; str:\n    \"\"\"\n    Determine the programming language of a file based on its filename extension.\n\n    Args:\n        filename (str): The name of the file for which to determine the programming language.\n\n    Returns:\n        str: The name of the programming language if recognized, otherwise an empty string.\n    \"\"\"\n    try:\n        lexer = get_lexer_for_filename(filename)\n        return lexer.name\n    except ClassNotFound:\n        return \"\"\n</code></pre>"},{"location":"reference/goose/toolkit/utils.html#goose.toolkit.utils.render_template","title":"<code>render_template(template_path, context=None)</code>","text":"<p>Renders a Jinja2 template given a Pathlib path, with no context needed.</p> <p>:param template_path: Path to the Jinja2 template file. :param context: Optional dictionary containing the context for rendering the template. :return: Rendered template as a string.</p> Source code in <code>src/goose/toolkit/utils.py</code> <pre><code>def render_template(template_path: Path, context: Optional[dict] = None) -&gt; str:\n    \"\"\"\n    Renders a Jinja2 template given a Pathlib path, with no context needed.\n\n    :param template_path: Path to the Jinja2 template file.\n    :param context: Optional dictionary containing the context for rendering the template.\n    :return: Rendered template as a string.\n    \"\"\"\n    # Ensure the path is absolute and exists\n    if not template_path.is_absolute():\n        template_path = template_path.resolve()\n\n    if not template_path.exists():\n        raise FileNotFoundError(f\"Template file {template_path} does not exist.\")\n\n    env = Environment(loader=FileSystemLoader(template_path.parent))\n    template = env.get_template(template_path.name)\n    return template.render(context or {})\n</code></pre>"},{"location":"reference/goose/toolkit/repo_context/index.html","title":"Index","text":""},{"location":"reference/goose/toolkit/repo_context/repo_context.html","title":"Repo context","text":""},{"location":"reference/goose/toolkit/repo_context/repo_context.html#goose.toolkit.repo_context.repo_context.RepoContext","title":"<code>RepoContext</code>","text":"<p>               Bases: <code>Toolkit</code></p> <p>Provides context about the current repository</p> Source code in <code>src/goose/toolkit/repo_context/repo_context.py</code> <pre><code>class RepoContext(Toolkit):\n    \"\"\"Provides context about the current repository\"\"\"\n\n    def __init__(self, notifier: Notifier, requires: Requirements) -&gt; None:\n        super().__init__(notifier=notifier, requires=requires)\n\n        self.repo_project_root, self.is_git_repo, self.goose_session_root = self.determine_git_proj()\n\n    def determine_git_proj(self) -&gt; tuple[str, bool, str]:\n        \"\"\"Determines the root as well as where Goose is currently running\n\n        If the project is not part of a Github repo, the root of the project will be defined as the current working\n        directory\n\n        Returns:\n            str: path to the root of the project (if part of a local repository) or the CWD if not\n            boolean: if Goose is operating within local repository or not\n            str: path to where the Goose session is running (the CWD)\n        \"\"\"\n        # FIXME: monorepos\n        cwd = os.getcwd()\n        command = \"git rev-parse --show-toplevel\"\n        result: CompletedProcess = run(command, shell=True, text=True, capture_output=True, check=False)\n        if result.returncode == 0:\n            project_root = result.stdout.strip()\n            return project_root, True, cwd\n        else:\n            self.notifier.log(\"Not part of a Git repository. Returning current working directory\")\n            return cwd, False, cwd\n\n    @property\n    @cache\n    def repo_size(self) -&gt; float:\n        \"\"\"Returns the size of the repo in MB (if Goose detects its running in a local repository\n\n        This measurement can be used to guess if the local repository is a monorepo\n\n        Returns:\n            float: size of project in MB\n        \"\"\"\n        # in MB\n        if self.is_git_repo:\n            return get_repo_size(self.repo_project_root)\n        else:\n            self.notifier.log(\"Not a git repo. Returning 0.\")\n            return 0.0\n\n    @property\n    def is_mono_repo(self) -&gt; bool:\n        \"\"\"An boolean indicator of whether the local repository is part of a monorepo\n\n        Returns:\n            boolean: True if above 2000 MB; False otherwise\n        \"\"\"\n        # java: 6394.367112159729\n        # go: 3729.93 MB\n        return self.repo_size &gt; 2000\n\n    @tool\n    def summarize_current_project(self) -&gt; dict[str, str]:\n        \"\"\"Summarizes the current project based on repo root (if git repo) or current project_directory (if not)\n\n        Returns:\n            summary (dict[str, str]): Keys are file paths and values are the summaries\n        \"\"\"\n\n        self.notifier.log(\"Summarizing the most relevant files in the current project. This may take a while...\")\n\n        if self.is_mono_repo:\n            self.notifier.log(\"This might be a monorepo. Goose performs better on smaller projects. Using CWD.\")\n            # TODO: prompt user to specify a subdirectory\n            project_directory = self.goose_session_root\n        else:\n            project_directory = self.repo_project_root\n\n        # before selecting files and summarizing look for summarization file\n        project_name = project_directory.split(\"/\")[-1]\n        summary = load_summary_file_if_exists(project_name=project_name)\n        if summary:\n            self.notifier.log(\"Summary file for project exists already -- loading into the context\")\n            return summary\n\n        # clear exchange and replace the system prompt with instructions on why and how to select files to summarize\n        file_select_exchange = clear_exchange(self.exchange_view.accelerator, clear_tools=True)\n        system = Message.load(\"prompts/repo_context.jinja\").text\n        file_select_exchange = replace_prompt(exchange=file_select_exchange, prompt=system)\n        files = goose_picks_files(root=project_directory, exchange=file_select_exchange)\n\n        # summarize the selected files using a blank exchange with no tools\n        summary = summarize_files_concurrent(\n            exchange=clear_exchange(self.exchange_view.accelerator, clear_tools=True),\n            file_list=files,\n            project_name=project_directory.split(\"/\")[-1],\n        )\n\n        return summary\n</code></pre>"},{"location":"reference/goose/toolkit/repo_context/repo_context.html#goose.toolkit.repo_context.repo_context.RepoContext.is_mono_repo","title":"<code>is_mono_repo: bool</code>  <code>property</code>","text":"<p>An boolean indicator of whether the local repository is part of a monorepo</p> <p>Returns:</p> Name Type Description <code>boolean</code> <code>bool</code> <p>True if above 2000 MB; False otherwise</p>"},{"location":"reference/goose/toolkit/repo_context/repo_context.html#goose.toolkit.repo_context.repo_context.RepoContext.repo_size","title":"<code>repo_size: float</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the size of the repo in MB (if Goose detects its running in a local repository</p> <p>This measurement can be used to guess if the local repository is a monorepo</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>size of project in MB</p>"},{"location":"reference/goose/toolkit/repo_context/repo_context.html#goose.toolkit.repo_context.repo_context.RepoContext.determine_git_proj","title":"<code>determine_git_proj()</code>","text":"<p>Determines the root as well as where Goose is currently running</p> <p>If the project is not part of a Github repo, the root of the project will be defined as the current working directory</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>path to the root of the project (if part of a local repository) or the CWD if not</p> <code>boolean</code> <code>bool</code> <p>if Goose is operating within local repository or not</p> <code>str</code> <code>str</code> <p>path to where the Goose session is running (the CWD)</p> Source code in <code>src/goose/toolkit/repo_context/repo_context.py</code> <pre><code>def determine_git_proj(self) -&gt; tuple[str, bool, str]:\n    \"\"\"Determines the root as well as where Goose is currently running\n\n    If the project is not part of a Github repo, the root of the project will be defined as the current working\n    directory\n\n    Returns:\n        str: path to the root of the project (if part of a local repository) or the CWD if not\n        boolean: if Goose is operating within local repository or not\n        str: path to where the Goose session is running (the CWD)\n    \"\"\"\n    # FIXME: monorepos\n    cwd = os.getcwd()\n    command = \"git rev-parse --show-toplevel\"\n    result: CompletedProcess = run(command, shell=True, text=True, capture_output=True, check=False)\n    if result.returncode == 0:\n        project_root = result.stdout.strip()\n        return project_root, True, cwd\n    else:\n        self.notifier.log(\"Not part of a Git repository. Returning current working directory\")\n        return cwd, False, cwd\n</code></pre>"},{"location":"reference/goose/toolkit/repo_context/repo_context.html#goose.toolkit.repo_context.repo_context.RepoContext.summarize_current_project","title":"<code>summarize_current_project()</code>","text":"<p>Summarizes the current project based on repo root (if git repo) or current project_directory (if not)</p> <p>Returns:</p> Name Type Description <code>summary</code> <code>dict[str, str]</code> <p>Keys are file paths and values are the summaries</p> Source code in <code>src/goose/toolkit/repo_context/repo_context.py</code> <pre><code>@tool\ndef summarize_current_project(self) -&gt; dict[str, str]:\n    \"\"\"Summarizes the current project based on repo root (if git repo) or current project_directory (if not)\n\n    Returns:\n        summary (dict[str, str]): Keys are file paths and values are the summaries\n    \"\"\"\n\n    self.notifier.log(\"Summarizing the most relevant files in the current project. This may take a while...\")\n\n    if self.is_mono_repo:\n        self.notifier.log(\"This might be a monorepo. Goose performs better on smaller projects. Using CWD.\")\n        # TODO: prompt user to specify a subdirectory\n        project_directory = self.goose_session_root\n    else:\n        project_directory = self.repo_project_root\n\n    # before selecting files and summarizing look for summarization file\n    project_name = project_directory.split(\"/\")[-1]\n    summary = load_summary_file_if_exists(project_name=project_name)\n    if summary:\n        self.notifier.log(\"Summary file for project exists already -- loading into the context\")\n        return summary\n\n    # clear exchange and replace the system prompt with instructions on why and how to select files to summarize\n    file_select_exchange = clear_exchange(self.exchange_view.accelerator, clear_tools=True)\n    system = Message.load(\"prompts/repo_context.jinja\").text\n    file_select_exchange = replace_prompt(exchange=file_select_exchange, prompt=system)\n    files = goose_picks_files(root=project_directory, exchange=file_select_exchange)\n\n    # summarize the selected files using a blank exchange with no tools\n    summary = summarize_files_concurrent(\n        exchange=clear_exchange(self.exchange_view.accelerator, clear_tools=True),\n        file_list=files,\n        project_name=project_directory.split(\"/\")[-1],\n    )\n\n    return summary\n</code></pre>"},{"location":"reference/goose/toolkit/repo_context/utils.html","title":"Utils","text":""},{"location":"reference/goose/toolkit/repo_context/utils.html#goose.toolkit.repo_context.utils.get_files_and_directories","title":"<code>get_files_and_directories(root_dir)</code>","text":"<p>Gets file names and directory names. Checks that goose has correctly typed the file and directory names and that the files actually exist (to avoid downstream file read errors).</p> <p>Parameters:</p> Name Type Description Default <code>root_dir</code> <code>str</code> <p>Path to the directory to examine for files and sub-directories</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, list]</code> <p>A list of files and directories in the form {'files': [], 'directories: []}. Paths are all relative (i.e. ['src'] not ['goose/src'])</p> Source code in <code>src/goose/toolkit/repo_context/utils.py</code> <pre><code>def get_files_and_directories(root_dir: str) -&gt; dict[str, list]:\n    \"\"\"Gets file names and directory names. Checks that goose has correctly typed the file and directory names and that\n    the files actually exist (to avoid downstream file read errors).\n\n    Args:\n        root_dir (str): Path to the directory to examine for files and sub-directories\n\n    Returns:\n        dict: A list of files and directories in the form {'files': [], 'directories: []}. Paths\n            are all relative (i.e. ['src'] not ['goose/src'])\n    \"\"\"\n    files = []\n    dirs = []\n\n    # check dir exists\n    try:\n        os.listdir(root_dir)\n    except FileNotFoundError:\n        # FIXME: fuzzy match might work here to recover directories 'lost' to goose mistyping\n        # hallucination: Goose mistyped the path (e.g. `metrichandler` vs `metricshandler`)\n        return {\"files\": files, \"directories\": dirs}\n\n    for entry in os.listdir(root_dir):\n        if entry.startswith(\".\") or entry.startswith(\"~\"):\n            continue  # Skip hidden files and directories\n\n        full_path = os.path.join(root_dir, entry)\n        if os.path.isdir(full_path):\n            dirs.append(entry)\n        elif os.path.isfile(full_path):\n            files.append(entry)\n\n    return {\"files\": files, \"directories\": dirs}\n</code></pre>"},{"location":"reference/goose/toolkit/repo_context/utils.html#goose.toolkit.repo_context.utils.get_repo_size","title":"<code>get_repo_size(repo_path)</code>","text":"<p>Returns repo size in MB</p> Source code in <code>src/goose/toolkit/repo_context/utils.py</code> <pre><code>def get_repo_size(repo_path: str) -&gt; int:\n    \"\"\"Returns repo size in MB\"\"\"\n    git_dir = os.path.join(repo_path, \".git\")\n    return get_directory_size(git_dir) / (1024**2)\n</code></pre>"},{"location":"reference/goose/toolkit/repo_context/utils.html#goose.toolkit.repo_context.utils.goose_picks_files","title":"<code>goose_picks_files(root, exchange, max_workers=4)</code>","text":"<p>Lets goose pick files in a BFS manner</p> Source code in <code>src/goose/toolkit/repo_context/utils.py</code> <pre><code>def goose_picks_files(root: str, exchange: Exchange, max_workers: int = 4) -&gt; list[str]:\n    \"\"\"Lets goose pick files in a BFS manner\"\"\"\n    queue = deque([root])\n\n    all_files = []\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:\n        while queue:\n            current_batch = [queue.popleft() for _ in range(min(max_workers, len(queue)))]\n            futures = {executor.submit(process_directory, dir, exchange): dir for dir in current_batch}\n\n            for future in concurrent.futures.as_completed(futures):\n                files, next_dirs = future.result()\n                all_files.extend(files)\n                queue.extend(next_dirs)\n\n    return all_files\n</code></pre>"},{"location":"reference/goose/toolkit/repo_context/utils.html#goose.toolkit.repo_context.utils.process_directory","title":"<code>process_directory(current_dir, exchange)</code>","text":"<p>Allows goose to pick files and subdirectories contained in a given directory (current_dir). Get the list of file and directory names in the current folder, then ask Goose to pick which ones to keep.</p> Source code in <code>src/goose/toolkit/repo_context/utils.py</code> <pre><code>def process_directory(current_dir: str, exchange: Exchange) -&gt; tuple[list[str], list[str]]:\n    \"\"\"Allows goose to pick files and subdirectories contained in a given directory (current_dir). Get the list of file\n    and directory names in the current folder, then ask Goose to pick which ones to keep.\n\n    \"\"\"\n    files_and_dirs = get_files_and_directories(current_dir)\n    ai_response = ask_an_ai(str(files_and_dirs), exchange)\n\n    # FIXME: goose response validation\n    try:\n        as_dict = ast.literal_eval(ai_response.text)\n    except Exception:\n        # can happen if goose returns anything but {result: dict} (e.g. ```json\\n {results: dict} \\n```)\n        return [], []\n    if not isinstance(as_dict, dict):\n        # can happen if goose returns something like `{'files': ['x.py'] 'directories': ['dir1']}` (missing comma)\n        return [], []\n\n    files = [f\"{current_dir}/{file}\" for file in as_dict.get(\"files\", [])]\n    next_dirs = [f\"{current_dir}/{next_dir}\" for next_dir in as_dict.get(\"directories\", [])]\n\n    return files, next_dirs\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/index.html","title":"Index","text":""},{"location":"reference/goose/toolkit/summarization/summarize_file.html","title":"Summarize file","text":""},{"location":"reference/goose/toolkit/summarization/summarize_file.html#goose.toolkit.summarization.summarize_file.SummarizeFile","title":"<code>SummarizeFile</code>","text":"<p>               Bases: <code>Toolkit</code></p> Source code in <code>src/goose/toolkit/summarization/summarize_file.py</code> <pre><code>class SummarizeFile(Toolkit):\n    @tool\n    def summarize_file(self, filepath: str, prompt: Optional[str] = None) -&gt; str:\n        \"\"\"\n        Tool to summarize a specific file\n\n        Args:\n            filepath (str): Path to the file to summarize\n            prompt (str): Optional prompt giving the model instructions on how to summarize the file.\n                Under the hood this defaults to \"Please summarize this file\"\n\n        Returns:\n            summary (Optional[str]): Summary of the file contents\n\n        \"\"\"\n\n        exchange = self.exchange_view.accelerator\n\n        _, summary = summarize_file(filepath=filepath, exchange=exchange, prompt=prompt)\n\n        return summary\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/summarize_file.html#goose.toolkit.summarization.summarize_file.SummarizeFile.summarize_file","title":"<code>summarize_file(filepath, prompt=None)</code>","text":"<p>Tool to summarize a specific file</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the file to summarize</p> required <code>prompt</code> <code>str</code> <p>Optional prompt giving the model instructions on how to summarize the file. Under the hood this defaults to \"Please summarize this file\"</p> <code>None</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>Optional[str]</code> <p>Summary of the file contents</p> Source code in <code>src/goose/toolkit/summarization/summarize_file.py</code> <pre><code>@tool\ndef summarize_file(self, filepath: str, prompt: Optional[str] = None) -&gt; str:\n    \"\"\"\n    Tool to summarize a specific file\n\n    Args:\n        filepath (str): Path to the file to summarize\n        prompt (str): Optional prompt giving the model instructions on how to summarize the file.\n            Under the hood this defaults to \"Please summarize this file\"\n\n    Returns:\n        summary (Optional[str]): Summary of the file contents\n\n    \"\"\"\n\n    exchange = self.exchange_view.accelerator\n\n    _, summary = summarize_file(filepath=filepath, exchange=exchange, prompt=prompt)\n\n    return summary\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/summarize_project.html","title":"Summarize project","text":""},{"location":"reference/goose/toolkit/summarization/summarize_project.html#goose.toolkit.summarization.summarize_project.SummarizeProject","title":"<code>SummarizeProject</code>","text":"<p>               Bases: <code>Toolkit</code></p> Source code in <code>src/goose/toolkit/summarization/summarize_project.py</code> <pre><code>class SummarizeProject(Toolkit):\n    @tool\n    def get_project_summary(\n        self,\n        project_dir_path: Optional[str] = os.getcwd(),\n        extensions: Optional[list[str]] = None,\n        summary_instructions_prompt: Optional[str] = None,\n    ) -&gt; dict:\n        \"\"\"Generates or retrieves a project summary based on specified file extensions.\n\n        Args:\n            project_dir_path (Optional[Path]): Path to the project directory. Defaults to the current working directory\n                if None\n            extensions (Optional[list[str]]): Specific file extensions to summarize.\n            summary_instructions_prompt (Optional[str]): Instructions to give to the LLM about how to summarize each file. E.g.\n                \"Summarize the file in two sentences.\". The default instruction is \"Please summarize this file.\"\n\n        Returns:\n            summary (dict): Project summary.\n        \"\"\"  # noqa: E501\n\n        summary = summarize_directory(\n            project_dir_path,\n            exchange=self.exchange_view.accelerator,\n            extensions=extensions,\n            summary_instructions_prompt=summary_instructions_prompt,\n        )\n\n        return summary\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/summarize_project.html#goose.toolkit.summarization.summarize_project.SummarizeProject.get_project_summary","title":"<code>get_project_summary(project_dir_path=os.getcwd(), extensions=None, summary_instructions_prompt=None)</code>","text":"<p>Generates or retrieves a project summary based on specified file extensions.</p> <p>Parameters:</p> Name Type Description Default <code>project_dir_path</code> <code>Optional[Path]</code> <p>Path to the project directory. Defaults to the current working directory if None</p> <code>getcwd()</code> <code>extensions</code> <code>Optional[list[str]]</code> <p>Specific file extensions to summarize.</p> <code>None</code> <code>summary_instructions_prompt</code> <code>Optional[str]</code> <p>Instructions to give to the LLM about how to summarize each file. E.g. \"Summarize the file in two sentences.\". The default instruction is \"Please summarize this file.\"</p> <code>None</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>dict</code> <p>Project summary.</p> Source code in <code>src/goose/toolkit/summarization/summarize_project.py</code> <pre><code>@tool\ndef get_project_summary(\n    self,\n    project_dir_path: Optional[str] = os.getcwd(),\n    extensions: Optional[list[str]] = None,\n    summary_instructions_prompt: Optional[str] = None,\n) -&gt; dict:\n    \"\"\"Generates or retrieves a project summary based on specified file extensions.\n\n    Args:\n        project_dir_path (Optional[Path]): Path to the project directory. Defaults to the current working directory\n            if None\n        extensions (Optional[list[str]]): Specific file extensions to summarize.\n        summary_instructions_prompt (Optional[str]): Instructions to give to the LLM about how to summarize each file. E.g.\n            \"Summarize the file in two sentences.\". The default instruction is \"Please summarize this file.\"\n\n    Returns:\n        summary (dict): Project summary.\n    \"\"\"  # noqa: E501\n\n    summary = summarize_directory(\n        project_dir_path,\n        exchange=self.exchange_view.accelerator,\n        extensions=extensions,\n        summary_instructions_prompt=summary_instructions_prompt,\n    )\n\n    return summary\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/summarize_repo.html","title":"Summarize repo","text":""},{"location":"reference/goose/toolkit/summarization/summarize_repo.html#goose.toolkit.summarization.summarize_repo.SummarizeRepo","title":"<code>SummarizeRepo</code>","text":"<p>               Bases: <code>Toolkit</code></p> Source code in <code>src/goose/toolkit/summarization/summarize_repo.py</code> <pre><code>class SummarizeRepo(Toolkit):\n    @tool\n    def summarize_repo(\n        self,\n        repo_url: str,\n        specified_extensions: Optional[list[str]] = None,\n        summary_instructions_prompt: Optional[str] = None,\n    ) -&gt; dict:\n        \"\"\"\n        Retrieves a summary of a repository. Clones the repository if not already cloned and summarizes based on the\n        specified file extensions. If no extensions are specified, it summarizes the top `max_extensions` extensions.\n\n        Args:\n            repo_url (str): The URL of the repository to summarize.\n            specified_extensions (Optional[list[str]]): list of file extensions to summarize, e.g., [\"tf\", \"md\"]. If\n                this list is empty, then all files in the repo are summarized\n            summary_instructions_prompt (Optional[str]): Instructions to give to the LLM about how to summarize each file. E.g.\n                \"Summarize the file in two sentences.\". The default instruction is \"Please summarize this file.\"\n\n        Returns:\n            summary (dict): A summary of the repository where keys are the file extensions and values are their\n                summaries.\n        \"\"\"  # noqa: E501\n\n        return summarize_repo(\n            repo_url=repo_url,\n            exchange=self.exchange_view.accelerator,\n            extensions=specified_extensions,\n            summary_instructions_prompt=summary_instructions_prompt,\n        )\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/summarize_repo.html#goose.toolkit.summarization.summarize_repo.SummarizeRepo.summarize_repo","title":"<code>summarize_repo(repo_url, specified_extensions=None, summary_instructions_prompt=None)</code>","text":"<p>Retrieves a summary of a repository. Clones the repository if not already cloned and summarizes based on the specified file extensions. If no extensions are specified, it summarizes the top <code>max_extensions</code> extensions.</p> <p>Parameters:</p> Name Type Description Default <code>repo_url</code> <code>str</code> <p>The URL of the repository to summarize.</p> required <code>specified_extensions</code> <code>Optional[list[str]]</code> <p>list of file extensions to summarize, e.g., [\"tf\", \"md\"]. If this list is empty, then all files in the repo are summarized</p> <code>None</code> <code>summary_instructions_prompt</code> <code>Optional[str]</code> <p>Instructions to give to the LLM about how to summarize each file. E.g. \"Summarize the file in two sentences.\". The default instruction is \"Please summarize this file.\"</p> <code>None</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>dict</code> <p>A summary of the repository where keys are the file extensions and values are their summaries.</p> Source code in <code>src/goose/toolkit/summarization/summarize_repo.py</code> <pre><code>@tool\ndef summarize_repo(\n    self,\n    repo_url: str,\n    specified_extensions: Optional[list[str]] = None,\n    summary_instructions_prompt: Optional[str] = None,\n) -&gt; dict:\n    \"\"\"\n    Retrieves a summary of a repository. Clones the repository if not already cloned and summarizes based on the\n    specified file extensions. If no extensions are specified, it summarizes the top `max_extensions` extensions.\n\n    Args:\n        repo_url (str): The URL of the repository to summarize.\n        specified_extensions (Optional[list[str]]): list of file extensions to summarize, e.g., [\"tf\", \"md\"]. If\n            this list is empty, then all files in the repo are summarized\n        summary_instructions_prompt (Optional[str]): Instructions to give to the LLM about how to summarize each file. E.g.\n            \"Summarize the file in two sentences.\". The default instruction is \"Please summarize this file.\"\n\n    Returns:\n        summary (dict): A summary of the repository where keys are the file extensions and values are their\n            summaries.\n    \"\"\"  # noqa: E501\n\n    return summarize_repo(\n        repo_url=repo_url,\n        exchange=self.exchange_view.accelerator,\n        extensions=specified_extensions,\n        summary_instructions_prompt=summary_instructions_prompt,\n    )\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/utils.html","title":"Utils","text":""},{"location":"reference/goose/toolkit/summarization/utils.html#goose.toolkit.summarization.utils.load_summary_file_if_exists","title":"<code>load_summary_file_if_exists(project_name)</code>","text":"<p>Checks if a summary file exists at '.goose/summaries/projectname-summary.json. Returns contents of the file if it exists, otherwise returns None</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>name of the project or repo</p> required <p>Returns:</p> Type Description <code>Optional[dict]</code> <p>Optional[dict]: File contents, else None</p> Source code in <code>src/goose/toolkit/summarization/utils.py</code> <pre><code>def load_summary_file_if_exists(project_name: str) -&gt; Optional[dict]:\n    \"\"\"Checks if a summary file exists at '.goose/summaries/projectname-summary.json. Returns contents of the file if\n    it exists, otherwise returns None\n\n    Args:\n        project_name (str): name of the project or repo\n\n    Returns:\n        Optional[dict]: File contents, else None\n    \"\"\"\n    summary_file_path = f\"{SUMMARIES_FOLDER}/{project_name}-summary.json\"\n    if Path(summary_file_path).exists():\n        with open(summary_file_path, \"r\") as f:\n            return json.load(f)\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/utils.html#goose.toolkit.summarization.utils.summarize_directory","title":"<code>summarize_directory(directory, exchange, extensions, summary_instructions_prompt=None)</code>","text":"<p>Summarize files in a given directory based on extensions. Will also recursively find files in subdirectories and summarize them.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>path to the top-level directory to summarize</p> required <code>exchange</code> <code>Exchange</code> <p>Exchange to use to summarize</p> required <code>extensions</code> <code>list[str]</code> <p>list of file-type extensions to summarize (and ignore all other extensions).</p> required <code>summary_instructions_prompt</code> <code>Optional[str]</code> <p>Optional instructions to give to the exchange regarding summarization.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>file_summaries</code> <code>dict</code> <p>Keys are file names and values are summaries.</p> Source code in <code>src/goose/toolkit/summarization/utils.py</code> <pre><code>def summarize_directory(\n    directory: str, exchange: Exchange, extensions: list[str], summary_instructions_prompt: Optional[str] = None\n) -&gt; dict[str, str]:\n    \"\"\"Summarize files in a given directory based on extensions. Will also recursively find files in subdirectories and\n    summarize them.\n\n    Args:\n        directory (str): path to the top-level directory to summarize\n        exchange (Exchange): Exchange to use to summarize\n        extensions (list[str]): list of file-type extensions to summarize (and ignore all other extensions).\n        summary_instructions_prompt (Optional[str]): Optional instructions to give to the exchange regarding summarization.\n\n    Returns:\n        file_summaries (dict): Keys are file names and values are summaries.\n\n    \"\"\"  # noqa: E501\n\n    # TODO: make sure that '.goose/summaries' is\n    # in the root of the current not relative to current dir or in cloned repo root\n    project_name = directory.split(\"/\")[-1]\n    summary_file = load_summary_file_if_exists(project_name)\n    if summary_file:\n        return summary_file\n\n    summary_file_path = f\"{SUMMARIES_FOLDER}/{project_name}-summary.json\"\n\n    # create the .goose/summaries folder if not already created\n    Path(SUMMARIES_FOLDER).mkdir(exist_ok=True, parents=True)\n\n    # select a subset of files to summarize based on file extension\n    files_to_summarize = create_file_list(directory, extensions=extensions)\n\n    file_summaries = summarize_files_concurrent(\n        exchange=exchange,\n        file_list=files_to_summarize,\n        project_name=project_name,\n        summary_instructions_prompt=summary_instructions_prompt,\n    )\n\n    summary_file_contents = {\"extensions\": extensions, \"summaries\": file_summaries}\n\n    # Write the summaries into a json\n    with open(summary_file_path, \"w\") as f:\n        json.dump(summary_file_contents, f, indent=2)\n\n    return file_summaries\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/utils.html#goose.toolkit.summarization.utils.summarize_file","title":"<code>summarize_file(filepath, exchange, prompt=None)</code>","text":"<p>Summarizes a single file</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the file to summarize.</p> required <code>exchange</code> <code>Exchange</code> <p>Exchange object to use for summarization.</p> required <code>prompt</code> <code>Optional[str]</code> <p>Defaults to \"Please summarize this file.\"</p> <code>None</code> Source code in <code>src/goose/toolkit/summarization/utils.py</code> <pre><code>def summarize_file(filepath: str, exchange: Exchange, prompt: Optional[str] = None) -&gt; tuple[str, str]:\n    \"\"\"Summarizes a single file\n\n    Args:\n        filepath (str): Path to the file to summarize.\n        exchange (Exchange): Exchange object to use for summarization.\n        prompt (Optional[str]): Defaults to \"Please summarize this file.\"\n    \"\"\"\n    try:\n        with open(filepath, \"r\") as f:\n            file_text = f.read()\n    except Exception as e:\n        return filepath, f\"Error reading file {filepath}: {str(e)}\"\n\n    if not file_text:\n        return filepath, \"Empty file\"\n\n    try:\n        reply = ask_an_ai(\n            input=file_text, exchange=exchange, prompt=prompt if prompt else \"Please summarize this file.\"\n        )\n    except InitialMessageTooLargeError:\n        return filepath, \"File too large\"\n\n    return filepath, reply.text\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/utils.html#goose.toolkit.summarization.utils.summarize_files_concurrent","title":"<code>summarize_files_concurrent(exchange, file_list, project_name, summary_instructions_prompt=None)</code>","text":"<p>Takes in a list of files and summarizes them. Exchange does not keep history of the summarized files.</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>Exchange</code> <p>Underlying exchange</p> required <code>file_list</code> <code>list[str]</code> <p>list of paths to files to summarize</p> required <code>project_name</code> <code>str</code> <p>Used to save the summary of the files to .goose/summaries/-summary.json required <code>summary_instructions_prompt</code> <code>Optional[str]</code> <p>Summary instructions for the LLM. Defaults to \"Please summarize this file.\"</p> <code>None</code> <p>Returns:</p> Name Type Description <code>file_summaries</code> <code>dict[str, str]</code> <p>Keys are file paths and values are the summaries returned by the Exchange</p> Source code in <code>src/goose/toolkit/summarization/utils.py</code> <pre><code>def summarize_files_concurrent(\n    exchange: Exchange, file_list: list[str], project_name: str, summary_instructions_prompt: Optional[str] = None\n) -&gt; dict[str, str]:\n    \"\"\"Takes in a list of files and summarizes them. Exchange does not keep history of the summarized files.\n\n    Args:\n        exchange (Exchange): Underlying exchange\n        file_list (list[str]): list of paths to files to summarize\n        project_name (str): Used to save the summary of the files to .goose/summaries/&lt;project_name&gt;-summary.json\n        summary_instructions_prompt (Optional[str]): Summary instructions for the LLM. Defaults to \"Please summarize\n            this file.\"\n\n    Returns:\n        file_summaries (dict[str, str]): Keys are file paths and values are the summaries returned by the Exchange\n    \"\"\"\n    summary_file = load_summary_file_if_exists(project_name)\n    if summary_file:\n        return summary_file\n\n    file_summaries = {}\n    # compile the individual file summaries into a single summary dict\n    # TODO: add progress bar as this step can take quite some time and it's nice to see something is happening\n    with ThreadPoolExecutor() as executor:\n        future_to_file = {\n            executor.submit(summarize_file, file, exchange, summary_instructions_prompt): file for file in file_list\n        }\n\n        for future in as_completed(future_to_file):\n            file_name, file_summary = future.result()\n            file_summaries[file_name] = file_summary\n\n    # create summaries folder if it doesn't exist\n    Path(SUMMARIES_FOLDER).mkdir(exist_ok=True, parents=True)\n    summary_file_path = f\"{SUMMARIES_FOLDER}/{project_name}-summary.json\"\n\n    # Write the summaries into a json\n    with open(summary_file_path, \"w\") as f:\n        json.dump(file_summaries, f, indent=2)\n\n    return file_summaries\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/utils.html#goose.toolkit.summarization.utils.summarize_repo","title":"<code>summarize_repo(repo_url, exchange, extensions, summary_instructions_prompt=None)</code>","text":"<p>Clones (if needed) and summarizes a repo</p> <p>Parameters:</p> Name Type Description Default <code>repo_url</code> <code>str</code> <p>Repository url</p> required <code>exchange</code> <code>Exchange</code> <p>Exchange for summarizing the repo.</p> required <code>extensions</code> <code>list[str]</code> <p>list of file-types to summarize.</p> required <code>summary_instructions_prompt</code> <code>Optional[str]</code> <p>Optional parameter to customize summarization results. Defaults to \"Please summarize this file\"</p> <code>None</code> Source code in <code>src/goose/toolkit/summarization/utils.py</code> <pre><code>def summarize_repo(\n    repo_url: str,\n    exchange: Exchange,\n    extensions: list[str],\n    summary_instructions_prompt: Optional[str] = None,\n) -&gt; dict[str, str]:\n    \"\"\"Clones (if needed) and summarizes a repo\n\n    Args:\n        repo_url (str): Repository url\n        exchange (Exchange): Exchange for summarizing the repo.\n        extensions (list[str]): list of file-types to summarize.\n        summary_instructions_prompt (Optional[str]): Optional parameter to customize summarization results. Defaults to\n            \"Please summarize this file\"\n    \"\"\"\n    # set up the paths for the repository and the summary file\n    repo_name = repo_url.split(\"/\")[-1]\n    repo_dir = f\"{CLONED_REPOS_FOLDER}/{repo_name}\"  # e.g. '.goose/cloned_repos/&lt;project-name&gt;'\n\n    if Path(repo_dir).exists():\n        # TODO: re-add ability to log\n        return summarize_directory(\n            directory=repo_dir,\n            exchange=exchange,\n            extensions=extensions,\n            summary_instructions_prompt=summary_instructions_prompt,\n        )\n\n    clone_repo(repo_url, target_directory=repo_dir)\n\n    return summarize_directory(\n        directory=repo_dir,\n        exchange=exchange,\n        extensions=extensions,\n        summary_instructions_prompt=summary_instructions_prompt,\n    )\n</code></pre>"},{"location":"reference/goose/utils/index.html","title":"Index","text":""},{"location":"reference/goose/utils/index.html#goose.utils.ensure","title":"<code>ensure(cls)</code>","text":"<p>Convert dictionary to a class instance</p> Source code in <code>src/goose/utils/__init__.py</code> <pre><code>def ensure(cls: type[T]) -&gt; Callable[[any], T]:\n    \"\"\"Convert dictionary to a class instance\"\"\"\n\n    def converter(val: any) -&gt; T:  # noqa: ANN401\n        if isinstance(val, cls):\n            return val\n        elif isinstance(val, dict):\n            return cls(**val)\n        elif isinstance(val, list):\n            return cls(*val)\n        else:\n            return cls(val)\n\n    return converter\n</code></pre>"},{"location":"reference/goose/utils/index.html#goose.utils.ensure_list","title":"<code>ensure_list(cls)</code>","text":"<p>Convert a list of dictionaries to class instances</p> Source code in <code>src/goose/utils/__init__.py</code> <pre><code>def ensure_list(cls: type[T]) -&gt; Callable[[list[dict[str, any]]], type[T]]:\n    \"\"\"Convert a list of dictionaries to class instances\"\"\"\n\n    def converter(val: list[dict[str, any]]) -&gt; list[T]:\n        output = []\n        for entry in val:\n            output.append(ensure(cls)(entry))\n        return output\n\n    return converter\n</code></pre>"},{"location":"reference/goose/utils/index.html#goose.utils.load_plugins","title":"<code>load_plugins(group)</code>","text":"<p>Load plugins based on a specified entry point group.</p> <p>This function iterates through all entry points registered under a specified group</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>The entry point group to load plugins from. This should match the group specified          in the package setup where plugins are defined.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary where each key is the entry point name, and the value is the loaded plugin object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Propagates exceptions raised by entry point loading, which might occur if a plugin        is not found or if there are issues with the plugin's code.</p> Source code in <code>src/goose/utils/__init__.py</code> <pre><code>def load_plugins(group: str) -&gt; dict:\n    \"\"\"\n    Load plugins based on a specified entry point group.\n\n    This function iterates through all entry points registered under a specified group\n\n    Args:\n        group (str): The entry point group to load plugins from. This should match the group specified\n                     in the package setup where plugins are defined.\n\n    Returns:\n        dict: A dictionary where each key is the entry point name, and the value is the loaded plugin object.\n\n    Raises:\n        Exception: Propagates exceptions raised by entry point loading, which might occur if a plugin\n                   is not found or if there are issues with the plugin's code.\n    \"\"\"\n    plugins = {}\n    # Access all entry points for the specified group and load each.\n    for entrypoint in entry_points(group=group):\n        plugin = entrypoint.load()  # Load the plugin.\n        plugins[entrypoint.name] = plugin  # Store the loaded plugin in the dictionary.\n    return plugins\n</code></pre>"},{"location":"reference/goose/utils/ask.html","title":"Ask","text":""},{"location":"reference/goose/utils/ask.html#goose.utils.ask.ask_an_ai","title":"<code>ask_an_ai(input, exchange, prompt='', no_history=True, with_tools=True)</code>","text":"<p>Sends a separate message to an LLM using a separate Exchange than the one underlying the Goose session.</p> <p>Can be used to summarize a file, or submit any other request that you'd like to an AI. The Exchange can have a history/prior context, or be wiped clean (by setting no_history to True).</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str</code> <p>The user's input string to be processed by the AI. Must be a non-empty string. Example: text from a file.</p> required <code>exchange</code> <code>Exchange</code> <p>An object representing the AI exchange system which manages the state and flow of the conversation.</p> required <code>prompt</code> <code>str</code> <p>An optional new prompt to replace the current one in the exchange system. Defaults to None. Example: \"Please summarize this file.\"</p> <code>''</code> <code>no_history</code> <code>bool</code> <p>A flag to determine if the conversation history should be cleared before processing the new input. True clears the context, False retains it. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>reply</code> <code>str</code> <p>The AI's reply as a string.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the <code>input</code> is not a non-empty string.</p> <code>Exception</code> <p>If there is an issue within the exchange system, including errors from the provider or model.</p> Example Source code in <code>src/goose/utils/ask.py</code> <pre><code>def ask_an_ai(\n    input: str,\n    exchange: Exchange,\n    prompt: str = \"\",\n    no_history: bool = True,\n    with_tools: bool = True,\n) -&gt; Message:\n    \"\"\"Sends a separate message to an LLM using a separate Exchange than the one underlying the Goose session.\n\n    Can be used to summarize a file, or submit any other request that you'd like to an AI. The Exchange can have a\n    history/prior context, or be wiped clean (by setting no_history to True).\n\n    Parameters:\n        input (str): The user's input string to be processed by the AI. Must be a non-empty string. Example: text from\n            a file.\n        exchange (Exchange): An object representing the AI exchange system which manages the state and flow of the\n            conversation.\n        prompt (str, optional): An optional new prompt to replace the current one in the exchange system. Defaults to\n            None. Example: \"Please summarize this file.\"\n        no_history (bool, optional): A flag to determine if the conversation history should be cleared before\n            processing the new input. True clears the context, False retains it. Defaults to True.\n\n    Returns:\n        reply (str): The AI's reply as a string.\n\n    Raises:\n        TypeError: If the `input` is not a non-empty string.\n        Exception: If there is an issue within the exchange system, including errors from the provider or model.\n\n    Example:\n        # Create an instance of an Exchange system\n        exchange_system = Exchange(provider=OpenAIProvider.from_env(), model=\"gpt-4\")\n\n        # Simulate asking the AI a question\n        response = ask_an_ai(\"What is the weather today?\", exchange_system)\n\n        print(response)  # Outputs the AI's response to the question.\n    \"\"\"\n    if no_history:\n        exchange = clear_exchange(exchange)\n\n    if not with_tools:\n        exchange = exchange.replace(tools=())\n\n    if prompt:\n        exchange = replace_prompt(exchange, prompt)\n\n    if not input:\n        raise TypeError(\"`input` must be a string of finite length\")\n\n    msg = Message.user(input)\n    exchange.add(msg)\n    reply = exchange.reply()\n\n    return reply\n</code></pre>"},{"location":"reference/goose/utils/ask.html#goose.utils.ask.ask_an_ai--create-an-instance-of-an-exchange-system","title":"Create an instance of an Exchange system","text":"<p>exchange_system = Exchange(provider=OpenAIProvider.from_env(), model=\"gpt-4\")</p>"},{"location":"reference/goose/utils/ask.html#goose.utils.ask.ask_an_ai--simulate-asking-the-ai-a-question","title":"Simulate asking the AI a question","text":"<p>response = ask_an_ai(\"What is the weather today?\", exchange_system)</p> <p>print(response)  # Outputs the AI's response to the question.</p>"},{"location":"reference/goose/utils/ask.html#goose.utils.ask.clear_exchange","title":"<code>clear_exchange(exchange, clear_tools=False)</code>","text":"<p>Clears the exchange object</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>Exchange</code> <p>Exchange object to be overwritten. Messages and checkpoints are replaced with empty lists.</p> required <code>clear_tools</code> <code>bool</code> <p>Boolean to indicate whether tools should be dropped from the exchange.</p> <code>False</code> <p>Returns:</p> Type Description <code>Exchange</code> <p>new_exchange (Exchange)</p> Source code in <code>src/goose/utils/ask.py</code> <pre><code>def clear_exchange(exchange: Exchange, clear_tools: bool = False) -&gt; Exchange:\n    \"\"\"Clears the exchange object\n\n    Args:\n        exchange (Exchange): Exchange object to be overwritten. Messages and checkpoints are replaced with empty lists.\n        clear_tools (bool): Boolean to indicate whether tools should be dropped from the exchange.\n\n    Returns:\n        new_exchange (Exchange)\n\n    \"\"\"\n    if clear_tools:\n        new_exchange = exchange.replace(messages=[], checkpoint_data=CheckpointData(), tools=())\n    else:\n        new_exchange = exchange.replace(messages=[], checkpoint_data=CheckpointData())\n    return new_exchange\n</code></pre>"},{"location":"reference/goose/utils/ask.html#goose.utils.ask.replace_prompt","title":"<code>replace_prompt(exchange, prompt)</code>","text":"<p>Replaces the system prompt</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>Exchange</code> <p>Exchange object to be overwritten. Messages and checkpoints are replaced with empty lists.</p> required <code>prompt</code> <code>str</code> <p>The system prompt.</p> required <p>Returns:</p> Type Description <code>Exchange</code> <p>new_exchange (Exchange)</p> Source code in <code>src/goose/utils/ask.py</code> <pre><code>def replace_prompt(exchange: Exchange, prompt: str) -&gt; Exchange:\n    \"\"\"Replaces the system prompt\n\n    Args:\n        exchange (Exchange): Exchange object to be overwritten. Messages and checkpoints are replaced with empty lists.\n        prompt (str): The system prompt.\n\n    Returns:\n        new_exchange (Exchange)\n    \"\"\"\n\n    new_exchange = exchange.replace(system=prompt)\n    return new_exchange\n</code></pre>"},{"location":"reference/goose/utils/check_shell_command.html","title":"Check shell command","text":""},{"location":"reference/goose/utils/check_shell_command.html#goose.utils.check_shell_command.is_dangerous_command","title":"<code>is_dangerous_command(command)</code>","text":"<p>Check if the command matches any dangerous patterns.</p> <p>Dangerous patterns in this function are defined as commands that may present risk to system stability.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The shell command to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the command is dangerous, False otherwise.</p> Source code in <code>src/goose/utils/check_shell_command.py</code> <pre><code>def is_dangerous_command(command: str) -&gt; bool:\n    \"\"\"\n    Check if the command matches any dangerous patterns.\n\n    Dangerous patterns in this function are defined as commands that may present risk to system stability.\n\n    Args:\n        command (str): The shell command to check.\n\n    Returns:\n        bool: True if the command is dangerous, False otherwise.\n    \"\"\"\n    dangerous_patterns = [\n        # Commands that are generally unsafe\n        r\"\\brm\\b\",  # rm command\n        r\"\\bgit\\s+push\\b\",  # git push command\n        r\"\\bsudo\\b\",  # sudo command\n        r\"\\bmv\\b\",  # mv command\n        r\"\\bchmod\\b\",  # chmod command\n        r\"\\bchown\\b\",  # chown command\n        r\"\\bmkfs\\b\",  # mkfs command\n        r\"\\bsystemctl\\b\",  # systemctl command\n        r\"\\breboot\\b\",  # reboot command\n        r\"\\bshutdown\\b\",  # shutdown command\n        # Target files that are unsafe\n        r\"\\b~\\/\\.|\\/\\.\\w+\",  # commands that point to files or dirs in home that start with a dot (dotfiles)\n    ]\n    for pattern in dangerous_patterns:\n        if re.search(pattern, command):\n            return True\n    return False\n</code></pre>"},{"location":"reference/goose/utils/file_utils.html","title":"File utils","text":""},{"location":"reference/goose/utils/file_utils.html#goose.utils.file_utils.create_extensions_list","title":"<code>create_extensions_list(project_root, max_n)</code>","text":"<p>Get the top N file extensions in the current project Args:     project_root (str): Root of the project to analyze     max_n (int): The number of file extensions to return Returns:     extensions (list[str]): A list of the top N file extensions</p> Source code in <code>src/goose/utils/file_utils.py</code> <pre><code>def create_extensions_list(project_root: str, max_n: int) -&gt; list:\n    \"\"\"Get the top N file extensions in the current project\n    Args:\n        project_root (str): Root of the project to analyze\n        max_n (int): The number of file extensions to return\n    Returns:\n        extensions (list[str]): A list of the top N file extensions\n    \"\"\"\n    if max_n == 0:\n        raise (ValueError(\"Number of file extensions must be greater than 0\"))\n\n    files = create_file_list(project_root, [])\n\n    counter = Counter()\n\n    for file in files:\n        file_path = Path(file)\n        if file_path.suffix:  # omit ''\n            counter[file_path.suffix] += 1\n\n    top_n = counter.most_common(max_n)\n    extensions = [ext for ext, _ in top_n]\n\n    return extensions\n</code></pre>"},{"location":"reference/goose/utils/file_utils.html#goose.utils.file_utils.create_file_list","title":"<code>create_file_list(dir_path, extensions)</code>","text":"<p>Creates a list of files with certain extensions</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>str</code> <p>Directory to list files of. Will include files recursively in sub-directories.</p> required <code>extensions</code> <code>list[str]</code> <p>list of file extensions to select for. If empty list, return all files</p> required <p>Returns:</p> Name Type Description <code>final_file_list</code> <code>list[str]</code> <p>list of file paths with specified extensions.</p> Source code in <code>src/goose/utils/file_utils.py</code> <pre><code>def create_file_list(dir_path: str, extensions: list[str]) -&gt; list[str]:\n    \"\"\"Creates a list of files with certain extensions\n\n    Args:\n        dir_path (str): Directory to list files of. Will include files recursively in sub-directories.\n        extensions (list[str]): list of file extensions to select for. If empty list, return all files\n\n    Returns:\n        final_file_list (list[str]): list of file paths with specified extensions.\n    \"\"\"\n    # if extensions is empty list, return all files\n    if not extensions:\n        return glob.glob(f\"{dir_path}/**/*\", recursive=True)\n\n    # prune out files that do not end with any of the extensions in extensions\n    final_file_list = []\n    for ext in extensions:\n        if ext and not ext.startswith(\".\"):\n            ext = f\".{ext}\"\n\n        files = glob.glob(f\"{dir_path}/**/*{ext}\", recursive=True)\n        final_file_list += files\n\n    return final_file_list\n</code></pre>"},{"location":"reference/goose/utils/file_utils.html#goose.utils.file_utils.create_language_weighting","title":"<code>create_language_weighting(files_in_directory)</code>","text":"<p>Calculate language weighting by file size to match GitHub's methodology.</p> <p>Parameters:</p> Name Type Description Default <code>files_in_directory</code> <code>list[str]</code> <p>Paths to files in the project directory</p> required <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>dict[str, float]: A dictionary with languages as keys and their percentage of the total codebase as values</p> Source code in <code>src/goose/utils/file_utils.py</code> <pre><code>def create_language_weighting(files_in_directory: list[str]) -&gt; dict[str, float]:\n    \"\"\"Calculate language weighting by file size to match GitHub's methodology.\n\n    Args:\n        files_in_directory (list[str]): Paths to files in the project directory\n\n    Returns:\n        dict[str, float]: A dictionary with languages as keys and their percentage of the total codebase as values\n    \"\"\"\n\n    # Initialize counters for sizes\n    size_by_language = Counter()\n\n    # Calculate size for files by language\n    for file_path in files_in_directory:\n        path = Path(file_path)\n        if path.suffix:\n            size_by_language[path.suffix] += os.path.getsize(file_path)\n\n    # Calculate total size and language percentages\n    total_size = sum(size_by_language.values())\n    language_percentages = {\n        lang: (size / total_size * 100) if total_size else 0 for lang, size in size_by_language.items()\n    }\n\n    return dict(sorted(language_percentages.items(), key=lambda item: item[1], reverse=True))\n</code></pre>"},{"location":"reference/goose/utils/file_utils.html#goose.utils.file_utils.list_files_with_extension","title":"<code>list_files_with_extension(dir_path, extension='')</code>","text":"<p>List all files in a directory with a given extension. Set extension to '' to return all files.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>str</code> <p>The path to the directory</p> required <code>extension</code> <code>Optional[str]</code> <p>extension to lookup. Defaults to '' which will return all files.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>files</code> <code>list[str]</code> <p>list of file paths</p> Source code in <code>src/goose/utils/file_utils.py</code> <pre><code>def list_files_with_extension(dir_path: str, extension: Optional[str] = \"\") -&gt; list[str]:\n    \"\"\"List all files in a directory with a given extension. Set extension to '' to return all files.\n\n    Args:\n        dir_path (str): The path to the directory\n        extension (Optional[str]): extension to lookup. Defaults to '' which will return all files.\n\n    Returns:\n        files (list[str]): list of file paths\n    \"\"\"\n    # add a leading '.' to extension if needed\n    if extension and not extension.startswith(\".\"):\n        extension = f\".{extension}\"\n\n    files = glob.glob(f\"{dir_path}/**/*{extension}\", recursive=True)\n    return files\n</code></pre>"},{"location":"reference/goose/utils/session_file.html","title":"Session file","text":""}]}